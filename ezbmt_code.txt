ezbmt-tracked/App.tsx
 
import React from 'react';
import { StatusBar, useColorScheme, Linking } from 'react-native';
import { NavigationContainer, useNavigationContainerRef } from '@react-navigation/native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import AppNavigator from './src/AppNavigator';
import { startSyncLoop, stopSyncLoop } from './src/lib/sync';
import GlobalBackground from './src/components/GlobalBackground';
import { useBgStore } from './src/store/bg';
import { supa } from './src/lib/supabase';

export default function App() {
const isDarkMode = useColorScheme() === 'dark';

// 登入狀態：未登入不顯示背景
const [signedIn, setSignedIn] = React.useState(false);

// 取得目前 Route 名稱，用來決定哪些畫面要隱藏背景
const navRef = useNavigationContainerRef();
const [routeName, setRouteName] = React.useState<string | undefined>(undefined);

// 這些畫面不顯示背景（依你的命名調整）
const EXCLUDE_BG = React.useMemo(
() =>
new Set([
'Record', // 記錄
'SpeedCam', // 測速
'Analysis', // 分析
]),
[]
);

// 是否顯示背景
const showBg = signedIn && routeName && !EXCLUDE_BG.has(routeName);

// 深連結處理（Email 驗證回跳）
React.useEffect(() => {
const handleUrl = (urlStr: string) => {
try {
const u = new URL(urlStr);
const code = u.searchParams.get('code') || u.searchParams.get('token');
if (code) {
// supabase-js v2: 傳入字串
supa.auth.exchangeCodeForSession(code).catch(() => {});
}
} catch {}
};

// App 冷啟時的連結
Linking.getInitialURL().then((initialUrl) => {
  if (initialUrl) handleUrl(initialUrl);
});

// App 前景時的連結
const sub = Linking.addEventListener('url', ({ url }: { url: string }) => handleUrl(url));
return () => sub.remove();
}, []);

React.useEffect(() => {
startSyncLoop();
// 載入本機背景設定（登入後才會渲染）
useBgStore.getState().load().catch(() => {});

// 初始化與監聽登入狀態
(async () => {
  try {
    const { data } = await supa.auth.getUser();
    setSignedIn(!!data?.user);
  } catch {
    setSignedIn(false);
  }
})();

const { data: sub } = supa.auth.onAuthStateChange((_event, session) => {
  setSignedIn(!!session?.user);
});

return () => {
  stopSyncLoop();
  try {
    sub?.subscription?.unsubscribe?.();
  } catch {}
};
}, []);

return (
<SafeAreaProvider>
<StatusBar barStyle={isDarkMode ? 'light-content' : 'dark-content'} />
<NavigationContainer
ref={navRef}
onReady={() => setRouteName(navRef.getCurrentRoute()?.name)}
onStateChange={() => setRouteName(navRef.getCurrentRoute()?.name)}
>
<AppNavigator />
</NavigationContainer>

  {/* 只有登入後且不在排除清單才顯示背景 */}
  {showBg ? <GlobalBackground /> : null}
</SafeAreaProvider>
);
}ezbmt-tracked/app.json
 
{
  "name": "ezbmt",
  "displayName": "ezbmt"
}
ezbmt-tracked/jest.config.js
 
module.exports = {
  preset: 'react-native',
};
ezbmt-tracked/index.js
 
/**
 * @format
 */

import 'react-native-gesture-handler';
import 'react-native-url-polyfill/auto';
import 'react-native-get-random-values';
import {AppRegistry} from 'react-native';
import App from './App';
import {name as appName} from './app.json';

AppRegistry.registerComponent(appName, () => App);
ezbmt-tracked/ios/ezbmt/Images.xcassets/AppIcon.appiconset/Contents.json
 
{
  "images" : [
    {
      "filename" : "ezBmticon.jpg",
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "dark"
        }
      ],
      "filename" : "ezBmticon 1.jpg",
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "tinted"
        }
      ],
      "filename" : "ezBmticon 2.jpg",
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
ezbmt-tracked/ios/ezbmt/Images.xcassets/Contents.json
 
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
ezbmt-tracked/ios/ezbmt/AppDelegate.swift
 
import UIKit
import React
import React_RCTAppDelegate
import ReactAppDependencyProvider

@main
class AppDelegate: UIResponder, UIApplicationDelegate {
  var window: UIWindow?

  var reactNativeDelegate: ReactNativeDelegate?
  var reactNativeFactory: RCTReactNativeFactory?

  func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil
  ) -> Bool {
    let delegate = ReactNativeDelegate()
    let factory = RCTReactNativeFactory(delegate: delegate)
    delegate.dependencyProvider = RCTAppDependencyProvider()

    reactNativeDelegate = delegate
    reactNativeFactory = factory

    window = UIWindow(frame: UIScreen.main.bounds)

    factory.startReactNative(
      withModuleName: "ezbmt",
      in: window,
      launchOptions: launchOptions
    )

    return true
  }
}

class ReactNativeDelegate: RCTDefaultReactNativeFactoryDelegate {
  override func sourceURL(for bridge: RCTBridge) -> URL? {
    self.bundleURL()
  }

  override func bundleURL() -> URL? {
#if DEBUG
    RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: "index")
#else
    Bundle.main.url(forResource: "main", withExtension: "jsbundle")
#endif
  }
}
ezbmt-tracked/ios/SpeedTracker.swift
 
import Foundation
import AVFoundation
import VisionCamera

@objc(SpeedTracker)
public class SpeedTracker: NSObject, FrameProcessorPlugin {
static var prevWidth: Int = 0
static var prevHeight: Int = 0
static var prevStride: Int = 0
static var prevData: Data? = nil
static var prevTs: Double = 0

public static func callback(_ frame: Frame!, withArgs args: [Any]!) -> Any! {
guard let pb = frame.buffer else { return nil }
let ts = frame.timestamp // seconds

// 只取 Y plane
let planeIndex = 0
CVPixelBufferLockBaseAddress(pb, .readOnly)
defer { CVPixelBufferUnlockBaseAddress(pb, .readOnly) }

guard let base = CVPixelBufferGetBaseAddressOfPlane(pb, planeIndex) else { return nil }
let width = CVPixelBufferGetWidthOfPlane(pb, planeIndex)
let height = CVPixelBufferGetHeightOfPlane(pb, planeIndex)
let stride = CVPixelBufferGetBytesPerRowOfPlane(pb, planeIndex)

// 建立當幀的 luma Data（注意 stride）
let currData = Data(bytes: base, count: stride * height)

var bestX = 0
var bestY = 0
var bestDiff = 0

if let prev = SpeedTracker.prevData,
   SpeedTracker.prevWidth == width,
   SpeedTracker.prevHeight == height,
   SpeedTracker.prevStride == stride {

  prev.withUnsafeBytes { (prevPtrRaw: UnsafeRawBufferPointer) in
    currData.withUnsafeBytes { (currPtrRaw: UnsafeRawBufferPointer) in
      guard let prevPtr = prevPtrRaw.baseAddress?.assumingMemoryBound(to: UInt8.self),
            let currPtr = currPtrRaw.baseAddress?.assumingMemoryBound(to: UInt8.self) else { return }

      let step = 8 // 採樣步距，越小越精準但越吃效能
      var y = 0
      while y < height {
        let prevRow = prevPtr.advanced(by: y * stride)
        let currRow = currPtr.advanced(by: y * stride)
        var x = 0
        while x < width {
          let d = abs(Int(currRow[x]) - Int(prevRow[x]))
          if d > bestDiff {
            bestDiff = d
            bestX = x
            bestY = y
          }
          x += step
        }
        y += step
      }
    }
  }
}

// 更新前一幀快取
SpeedTracker.prevData = currData
SpeedTracker.prevWidth = width
SpeedTracker.prevHeight = height
SpeedTracker.prevStride = stride
SpeedTracker.prevTs = ts

if bestDiff == 0 {
  return nil
}
let nx = Double(bestX) / Double(width)
let ny = Double(bestY) / Double(height)

return [
  "x": nx,
  "y": ny,
  "ts": ts,
  "w": width,
  "h": height,
  "score": bestDiff
]
}
}

ezbmt-tracked/ios/Podfile
 
# Resolve react_native_pods.rb with node to allow for hoisting
require Pod::Executable.execute_command('node', ['-p',
  'require.resolve(
    "react-native/scripts/react_native_pods.rb",
    {paths: [process.argv[1]]},
  )', __dir__]).strip

platform :ios, min_ios_version_supported
prepare_react_native_project!

linkage = ENV['USE_FRAMEWORKS']
if linkage
Pod::UI.puts "Configuring Pod with #{linkage}ally linked Frameworks".green
use_frameworks! :linkage => linkage.to_sym
else
use_frameworks! :linkage => :static
end

target 'ezbmt' do
config = use_native_modules!

use_react_native!(
:path => config[:reactNativePath],
# An absolute path to your application root.
:app_path => "#{Pod::Config.instance.installation_root}/.."
# :hermes_enabled => true, # 預設為 true，如需暫時關閉可設 false
)

post_install do |installer|
# React Native 預設後處理
react_native_post_install(
installer,
config[:reactNativePath],
:mac_catalyst_enabled => false
)

# 關閉 Xcode 15 的 User Script Sandboxing（解 rsync sandbox 錯誤）
installer.pods_project.targets.each do |t|
  t.build_configurations.each do |bc|
    bc.build_settings['ENABLE_USER_SCRIPT_SANDBOXING'] = 'NO'
  end
end
installer.pods_project.save

installer.aggregate_targets.each do |agg|
  agg.user_project.native_targets.each do |t|
    t.build_configurations.each do |bc|
      bc.build_settings['ENABLE_USER_SCRIPT_SANDBOXING'] = 'NO'
    end
  end
  agg.user_project.save
end

# 讓 VisionCamera 以 module 方式匯入（避免 modulemap 類型錯誤）
vc = installer.pods_project.targets.find { |t| t.name == 'VisionCamera' }
if vc
  vc.build_configurations.each do |bc|
    bc.build_settings['DEFINES_MODULE'] = 'YES'
    bc.build_settings['CLANG_ENABLE_MODULES'] = 'YES'
  end
end
end end
ezbmt-tracked/metro.config.js
 
const { getDefaultConfig, mergeConfig } = require('@react-native/metro-config');

/**
 * Metro configuration
 * https://reactnative.dev/docs/metro
 *
 * @type {import('@react-native/metro-config').MetroConfig}
 */
const config = {};

module.exports = mergeConfig(getDefaultConfig(__dirname), config);
ezbmt-tracked/babel.config.js
 
module.exports = {
presets: ['module:@react-native/babel-preset'],
plugins: [
'react-native-reanimated/plugin',
],
};ezbmt-tracked/__tests__/App.test.tsx
 
/**
 * @format
 */

import React from 'react';
import ReactTestRenderer from 'react-test-renderer';
import App from '../App';

test('renders correctly', async () => {
  await ReactTestRenderer.act(() => {
    ReactTestRenderer.create(<App />);
  });
});
ezbmt-tracked/package.json
 
{
  "name": "ezbmt",
  "version": "0.0.1",
  "private": true,
  "scripts": {
    "android": "react-native run-android",
    "ios": "react-native run-ios",
    "lint": "eslint .",
    "start": "react-native start",
    "test": "jest",
    "gen:icons": "node scripts/gen-icons.js"
  },
  "dependencies": {
    "@react-native-async-storage/async-storage": "^2.2.0",
    "@react-native-picker/picker": "^2.11.2",
    "@react-native/new-app-screen": "0.81.1",
    "@react-navigation/native": "^7.1.17",
    "@react-navigation/native-stack": "^7.3.26",
    "@supabase/supabase-js": "^2.57.4",
    "cd": "^0.3.3",
    "date-fns": "^4.1.0",
    "ios": "^0.0.1",
    "react": "19.1.0",
    "react-hook-form": "^7.62.0",
    "react-native": "0.81.1",
    "react-native-badminton-speed": "file:../react-native-badminton-speed",
    "react-native-bootsplash": "^6.3.11",
    "react-native-fs": "^2.20.0",
    "react-native-gesture-handler": "^2.28.0",
    "react-native-get-random-values": "^1.11.0",
    "react-native-html-to-pdf": "^1.3.0",
    "react-native-image-picker": "^8.2.1",
    "react-native-reanimated": "^4.1.0",
    "react-native-safe-area-context": "^5.6.1",
    "react-native-screens": "^4.16.0",
    "react-native-share": "^12.2.0",
    "react-native-sqlite-storage": "^6.0.1",
    "react-native-svg": "^15.13.0",
    "react-native-url-polyfill": "^2.0.0",
    "react-native-vision-camera": "^4.7.2",
    "react-native-webview": "^13.16.0",
    "react-native-worklets": "^0.5.1",
    "react-native-worklets-core": "^1.6.2",
    "react-native-youtube-iframe": "^2.4.1",
    "uuid": "^13.0.0",
    "zod": "^4.1.5",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@babel/preset-env": "^7.25.3",
    "@babel/runtime": "^7.25.0",
    "@react-native-community/cli": "20.0.0",
    "@react-native-community/cli-platform-android": "20.0.0",
    "@react-native-community/cli-platform-ios": "20.0.0",
    "@react-native/babel-preset": "0.81.1",
    "@react-native/eslint-config": "0.81.1",
    "@react-native/metro-config": "0.81.1",
    "@react-native/typescript-config": "0.81.1",
    "@types/jest": "^29.5.13",
    "@types/react": "^19.1.0",
    "@types/react-test-renderer": "^19.1.0",
    "@types/uuid": "^10.0.0",
    "eslint": "^8.19.0",
    "jest": "^29.6.3",
    "prettier": "2.8.8",
    "react-test-renderer": "19.1.0",
    "sharp": "^0.34.3",
    "typescript": "^5.8.3"
  },
  "engines": {
    "node": ">=20"
  }
}
ezbmt-tracked/.prettierrc.js
 
module.exports = {
  arrowParens: 'avoid',
  singleQuote: true,
  trailingComma: 'all',
};
ezbmt-tracked/scripts/gen-icons.js
 
/* scripts/gen-icons.js */
const fs = require('fs');
const path = require('path');
const sharp = require('sharp');

const SRC = path.resolve(__dirname, '../assets/appicon.svg');

// iOS AppIcon 尺寸（pt × scale）
const ios = [
{ size: 20,  scales: [2,3] },
{ size: 29,  scales: [2,3] },
{ size: 40,  scales: [2,3] },
{ size: 60,  scales: [2,3] },
{ size: 1024, scales: [1], marketing: true },
];

// Android mipmap（px）
const android = [
{ dir: 'mipmap-mdpi',    size: 48 },
{ dir: 'mipmap-hdpi',    size: 72 },
{ dir: 'mipmap-xhdpi',   size: 96 },
{ dir: 'mipmap-xxhdpi',  size: 144 },
{ dir: 'mipmap-xxxhdpi', size: 192 },
];

(async () => {
// iOS
const iosDir = path.resolve(__dirname, '../ios/ezbmt/Images.xcassets/AppIcon.appiconset');
if (!fs.existsSync(iosDir)) fs.mkdirSync(iosDir, { recursive: true });
const contents = { images: [], info: { version: 1, author: 'xcode' } };

for (const row of ios) {
if (row.marketing) {
const out = path.join(iosDir, 'ios-marketing-1024.png');
await sharp(SRC).resize(1024, 1024).png().toFile(out);
contents.images.push({ idiom: 'ios-marketing', size: '1024x1024', scale: '1x', filename: 'ios-marketing-1024.png' });
continue;
}
for (const s of row.scales) {
const px = row.size * s;
const name = `icon-${row.size}pt@${s}x.png`;
const out = path.join(iosDir, name);
await sharp(SRC).resize(px, px).png().toFile(out);
contents.images.push({ idiom: 'iphone', size: `${row.size}x${row.size}`, scale: `${s}x`, filename: name });
}
}
fs.writeFileSync(path.join(iosDir, 'Contents.json'), JSON.stringify(contents, null, 2));

// Android
const resDir = path.resolve(__dirname, '../android/app/src/main/res');
for (const a of android) {
const dir = path.join(resDir, a.dir);
if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
await sharp(SRC).resize(a.size, a.size).png().toFile(path.join(dir, 'ic_launcher.png'));
await sharp(SRC).resize(a.size, a.size).png().toFile(path.join(dir, 'ic_launcher_round.png'));
}
console.log('✓ Icons generated for iOS/Android');
})();ezbmt-tracked/.eslintrc.js
 
module.exports = {
  root: true,
  extends: '@react-native',
};
ezbmt-tracked/tsconfig.json
 

{ "extends": "@react-native/typescript-config"
 , 
 "compilerOptions": { "skipLibCheck": true, "typeRoots": ["./src/@types", "./node_modules/@types"] }
 , "include": ["src//*.ts", "src//*.tsx"], "exclude": ["/node_modules", "/Pods"] }
ezbmt-tracked/src/@types:react-native-sqlite-storage/index.d.ts
 
declare module 'react-native-sqlite-storage' {
export type SQLResultSetRow = { [key: string]: any };

export type SQLResultSet = {
rows: {
length: number;
item: (index: number) => SQLResultSetRow;
};
insertId?: number;
rowsAffected?: number;
};

export interface SQLiteDatabase {
executeSql: (sqlStatement: string, args?: any[]) => Promise<[SQLResultSet]>;
close: () => Promise<void>;
}

// default export 物件
const SQLiteDefault: {
enablePromise: (enable: boolean) => void;
openDatabase: (
config:
| { name: string; location?: 'default' | 'Library' | 'Documents' }
| string
) => Promise<SQLiteDatabase>;
};

// 額外提供命名空間（讓 SQLite.SQLiteDatabase 也可用）
export as namespace SQLite;
export { SQLiteDatabase };
export default SQLiteDefault;
}
ezbmt-tracked/src/AppNavigator.tsx
 
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import EventsScreen from './screens/EventsScreen';
import MatchesScreen from './screens/MatchesScreen';
import PlayerSetupScreen from './screens/PlayerSetupScreen';
import RecordScreen from './screens/RecordScreen';
import AnalysisScreen from './screens/AnalysisScreen';
import LiveScreen from './screens/LiveScreen';
import ChatScreen from './screens/ChatScreen';
import MediaScreen from './screens/MediaScreen';
import SettingsScreen from './screens/SettingsScreen';
import ReplayScreen from './screens/ReplayScreen';
import AuthScreen from './screens/AuthScreen';
import { BACKEND } from './lib/backend';
import JoinEventScreen from './screens/JoinEventScreen';
import ProfileScreen from './screens/ProfileScreen';
import EventMembersScreen from './screens/EventMembersScreen';
import MatchMembersScreen from './screens/MatchMembersScreen';
import SpeedCam from './screens/SpeedCamScreen';


const Stack = createNativeStackNavigator();

export default function AppNavigator() {
const headerDark = React.useMemo(() => ({
headerStyle: { backgroundColor: '#111' },   // 標題列底色
headerTitleStyle: { color: '#fff' },        // 標題文字
headerTintColor: '#fff',                    // 返回箭頭/右上角按鈕顏色
headerShadowVisible: false,                 // 移除底部陰影（更貼近深色）
// 若 iOS 想做霧面可用：headerBlurEffect: 'systemChromeMaterialDark'
}), []);
return (
<Stack.Navigator
initialRouteName="Events"
screenOptions={{ headerBackTitle: '', ...headerDark }}
>
{BACKEND === 'supabase' && (
<Stack.Screen name="Auth" component={AuthScreen} options={{ title: '登入' }} />
)}
<Stack.Screen name="JoinEvent" component={JoinEventScreen} options={{ title: '加入事件' }} />
<Stack.Screen name="Profile" component={ProfileScreen} options={{ title: '個人' }} />
<Stack.Screen name="EventMembers" component={EventMembersScreen} options={{ title: '事件成員' }} />
<Stack.Screen name="MatchMembers" component={MatchMembersScreen} options={{ title: '場次成員' }} />
<Stack.Screen name="Events" component={EventsScreen} options={{ title: '賽事' }} />
<Stack.Screen name="Matches" component={MatchesScreen} options={{ title: '場次' }} />
<Stack.Screen name="PlayerSetup" component={PlayerSetupScreen} options={{ title: '球員與起始設定' }} />
<Stack.Screen name="Record" component={RecordScreen} options={{ title: '記錄' }} />
<Stack.Screen name="Analysis" component={AnalysisScreen} options={{ title: '分析' }} />
<Stack.Screen name="Live" component={LiveScreen} options={{ title: '即時分數' }} />
<Stack.Screen name="Chat" component={ChatScreen} options={{ title: '聊天室' }} />
<Stack.Screen name="Media" component={MediaScreen} options={{ title: '媒體' }} />
<Stack.Screen name="Settings" component={SettingsScreen} options={{ title: '設定' }} />
<Stack.Screen name="Replay" component={ReplayScreen} options={{ title: '路徑回放' }} />
<Stack.Screen name="SpeedCam" component={SpeedCam} options={{ title: '測速' }} />
</Stack.Navigator>
);
}ezbmt-tracked/src/SpeedTracker.swift
 
import Foundation
import AVFoundation
import VisionCamera

@objc(SpeedTracker)
public class SpeedTracker: NSObject, FrameProcessorPlugin {
static var prevWidth: Int = 0
static var prevHeight: Int = 0
static var prevStride: Int = 0
static var prevData: Data? = nil

public static func callback(_ frame: Frame!, withArgs args: [Any]!) -> Any! {
guard let pb = frame.buffer else { return nil }
let ts = frame.timestamp // seconds

let planeIndex = 0 // Y(luma)
CVPixelBufferLockBaseAddress(pb, .readOnly)
defer { CVPixelBufferUnlockBaseAddress(pb, .readOnly) }

guard let base = CVPixelBufferGetBaseAddressOfPlane(pb, planeIndex) else { return nil }
let width = CVPixelBufferGetWidthOfPlane(pb, planeIndex)
let height = CVPixelBufferGetHeightOfPlane(pb, planeIndex)
let stride = CVPixelBufferGetBytesPerRowOfPlane(pb, planeIndex)

// 當幀 luma
let currData = Data(bytes: base, count: stride * height)

var bestX = 0
var bestY = 0
var bestDiff = 0

if let prev = SpeedTracker.prevData,
   SpeedTracker.prevWidth == width,
   SpeedTracker.prevHeight == height,
   SpeedTracker.prevStride == stride {

  prev.withUnsafeBytes { (prevRaw: UnsafeRawBufferPointer) in
    currData.withUnsafeBytes { (currRaw: UnsafeRawBufferPointer) in
      guard let pPrev = prevRaw.baseAddress?.assumingMemoryBound(to: UInt8.self),
            let pCurr = currRaw.baseAddress?.assumingMemoryBound(to: UInt8.self) else { return }

      let step = 8 // 採樣步距：8px，效能/精度折衷
      var y = 0
      while y < height {
        let rowPrev = pPrev.advanced(by: y * stride)
        let rowCurr = pCurr.advanced(by: y * stride)
        var x = 0
        while x < width {
          let d = abs(Int(rowCurr[x]) - Int(rowPrev[x]))
          if d > bestDiff {
            bestDiff = d
            bestX = x
            bestY = y
          }
          x += step
        }
        y += step
      }
    }
  }
}

// 更新前幀快取
SpeedTracker.prevData = currData
SpeedTracker.prevWidth = width
SpeedTracker.prevHeight = height
SpeedTracker.prevStride = stride

if bestDiff == 0 { return nil }

let nx = Double(bestX) / Double(width)
let ny = Double(bestY) / Double(height)

return [
  "x": nx,
  "y": ny,
  "ts": ts,
  "w": width,
  "h": height,
  "score": bestDiff
]
}
}

ezbmt-tracked/src/tests/serve.test.ts
 
import assert from 'assert';
import {
createMatch,
getRotationSnapshot,
nextRally,
} from '../serve';

function makeMatch() {
return createMatch({
teams: [
{ players: [{ id: 'A0' }, { id: 'A1' }], startRightIndex: 0 },
{ players: [{ id: 'B0' }, { id: 'B1' }], startRightIndex: 0 },
],
startingServerTeam: 0,
startingServerPlayerIndex: 0,
rules: { bestOf: 3, pointsToWin: 21, winBy: 2, cap: 30 },
});
}

// Test 1: same server continues on wins, court alternates
{
const m = makeMatch();
let snap = getRotationSnapshot(m);
assert.equal(snap.servingTeam, 0);
assert.equal(snap.server.team, 0);
assert.equal(snap.server.index, 0);
assert.equal(snap.server.court, 'R'); // 0-0 right court

nextRally(m, 0); // A wins, 1-0
snap = getRotationSnapshot(m);
assert.equal(snap.server.team, 0);
assert.equal(snap.server.index, 0);
assert.equal(snap.server.court, 'L'); // alternates

nextRally(m, 0); // 2-0
snap = getRotationSnapshot(m);
assert.equal(snap.server.court, 'R');

nextRally(m, 0); // 3-0
snap = getRotationSnapshot(m);
assert.equal(snap.server.court, 'L');
}

// Test 2: receiving side wins => service changes; new server = right-court player of that side
{
const m = makeMatch();
nextRally(m, 0); // 1-0 (A serves continues)
nextRally(m, 1); // 1-1 (B wins while receiving) => B serves next
const snap = getRotationSnapshot(m);
// B score=1 (odd) with startRightIndex=0 => right index = 1
assert.equal(snap.servingTeam, 1);
assert.equal(snap.server.team, 1);
assert.equal(snap.server.index, 1);
assert.equal(snap.server.court, 'R');
// Receiver should be A right court (A score=1 => right=A1)
assert.equal(snap.receiver.team, 0);
assert.equal(snap.receiver.index, 1);
}

// Test 3: deuce to cap
{
const m = createMatch({
teams: [
{ players: [{ id: 'A0' }, { id: 'A1' }] },
{ players: [{ id: 'B0' }, { id: 'B1' }] },
],
rules: { pointsToWin: 21, winBy: 2, cap: 30, bestOf: 1 },
});

// Drive to 29-29
let a = 0, b = 0;
while (a < 29 || b < 29) {
if (a <= b) { nextRally(m, 0); a++; } else { nextRally(m, 1); b++; }
}
let snap = getRotationSnapshot(m);
assert.deepEqual(snap.score, [29, 29]);

// Next rally decides at cap 30
nextRally(m, 0);
snap = getRotationSnapshot(m);
// Game over, but state advanced to next game only if bestOf>1; here bestOf=1, we stay with 1 game finished.
assert.equal(m.games[0].winner, 0);
}

// Test 4: best-of-3 match completion
{
const m = makeMatch();

// Game1: A wins 21-0
for (let i = 0; i < 21; i++) nextRally(m, 0);
assert.equal(m.games[0].winner, 0);

// Game2: B wins 21-0
for (let i = 0; i < 21; i++) nextRally(m, 1);
assert.equal(m.games[1].winner, 1);

// Game3: A wins 21-0 => match over
for (let i = 0; i < 21; i++) nextRally(m, 0);
assert.equal(m.games[2].winner, 0);
}
ezbmt-tracked/src/logic/serve.ts
 
export type TeamId = 0 | 1;
export type PairIndex = 0 | 1;
export type Court = 'R' | 'L';

export interface PlayerMeta {
id: string;
name?: string;
gender?: 'M' | 'F' | 'U';
handedness?: 'L' | 'R' | 'U';
}

export interface TeamConfig {
players: [PlayerMeta, PlayerMeta];
startRightIndex?: PairIndex;
}

export interface RuleConfig {
bestOf?: 1 | 3 | 5;
pointsToWin?: number;
winBy?: number;
cap?: number | null;
technicalTimeoutAt?: number | null;
changeEndsInDeciderAt?: number | null;
}

export interface MatchConfig {
teams: [TeamConfig, TeamConfig];
startingServerTeam?: TeamId;
startingServerPlayerIndex?: PairIndex;
rules?: RuleConfig;
metadata?: { category?: 'MD' | 'WD' | 'XD' | 'CUSTOM' };
}

export interface GameScore {
points: [number, number];
winner?: TeamId;
intervalTaken?: boolean;
deciderSidesSwitched?: boolean;
}

export interface MatchState {
teams: [Required<TeamConfig>, Required<TeamConfig>];
rules: Required<RuleConfig>;
metadata?: MatchConfig['metadata'];

currentGameIndex: number;
games: GameScore[];

// 目前發球方與發球員索引（以 teams[servingTeam].players 的索引）
servingTeam: TeamId;
serverPlayerIndex: PairIndex;

// 新增：目前兩隊「在右區」的是誰（0/1）
posRight: [PairIndex, PairIndex];

_version?: number;
}

/* defaults */
const DEFAULT_RULES: Required<RuleConfig> = {
bestOf: 3,
pointsToWin: 21,
winBy: 2,
cap: 30,
technicalTimeoutAt: 11,
changeEndsInDeciderAt: 11,
};

function opp(i: PairIndex): PairIndex { return i === 0 ? 1 : 0; }
function inferStartRight(team: TeamConfig, cat?: 'MD' | 'WD' | 'XD' | 'CUSTOM'): PairIndex {
if (team.startRightIndex !== undefined) return team.startRightIndex;
if (cat === 'XD') {
const m = team.players.findIndex(p => p.gender === 'M');
if (m === 0 || m === 1) return m as PairIndex;
}
return 0;
}

export function createMatch(cfg: MatchConfig): MatchState {
const category = cfg.metadata?.category ?? 'CUSTOM';
const teams: [Required<TeamConfig>, Required<TeamConfig>] = [
{ players: cfg.teams[0].players, startRightIndex: inferStartRight(cfg.teams[0], category) },
{ players: cfg.teams[1].players, startRightIndex: inferStartRight(cfg.teams[1], category) },
];
const rules = { ...DEFAULT_RULES, ...(cfg.rules || {}) };
if (rules.bestOf % 2 === 0) throw new Error('bestOf must be odd (1/3/5)');

const srvTeam = cfg.startingServerTeam ?? 0;
const srvIdxSeed = cfg.startingServerPlayerIndex ?? teams[srvTeam].startRightIndex!;
if (srvIdxSeed !== teams[srvTeam].startRightIndex) teams[srvTeam].startRightIndex = srvIdxSeed;

// 初始右區人員
const posRight: [PairIndex, PairIndex] = [teams[0].startRightIndex!, teams[1].startRightIndex!];

// 開局時（0:0）皆在右發，serverPlayerIndex 依發球方目前「右區」者
const serverPlayerIndex = posRight[srvTeam];

return {
teams,
rules,
metadata: cfg.metadata,
currentGameIndex: 0,
games: [{ points: [0, 0] }],
servingTeam: srvTeam,
serverPlayerIndex,
posRight,
_version: 2,
};
}

export function getCurrentPoints(s: MatchState): [number, number] {
return s.games[s.currentGameIndex].points;
}

export function getNeedGamesToWin(s: MatchState): number {
return Math.floor(s.rules.bestOf / 2) + 1;
}

export function isGameOver(s: MatchState): boolean {
const [a, b] = getCurrentPoints(s);
const { pointsToWin, winBy, cap } = s.rules;
const mx = Math.max(a, b), mn = Math.min(a, b);
if (cap != null && mx >= cap) return true;
if (mx >= pointsToWin && (mx - mn) >= winBy) return true;
return false;
}

export function isMatchOver(s: MatchState): boolean {
const wonA = s.games.filter(g => g.winner === 0).length;
const wonB = s.games.filter(g => g.winner === 1).length;
return (wonA >= getNeedGamesToWin(s) || wonB >= getNeedGamesToWin(s));
}

export interface PlayerRef { team: TeamId; index: PairIndex; }
export interface RotationSnapshot {
score: [number, number];
servingTeam: TeamId;
server: PlayerRef & { court: Court };
receiver: PlayerRef & { court: Court };
teamPositions: [
{ right: PairIndex; left: PairIndex },
{ right: PairIndex; left: PairIndex },
];
}

/**

由當前 posRight 決定站位；server/receiver 由「發球者是否站右」判定。 */ export function getRotationSnapshot(s: MatchState): RotationSnapshot { const [a, b] = getCurrentPoints(s); const prA = s.posRight?.[0] ?? s.teams[0].startRightIndex!; const prB = s.posRight?.[1] ?? s.teams[1].startRightIndex!; const plA = opp(prA), plB = opp(prB);
const srvTeam = s.servingTeam;
const srvRightIdx = srvTeam === 0 ? prA : prB;
const serverCourt: Court = (s.serverPlayerIndex === srvRightIdx) ? 'R' : 'L';

const recTeam = (srvTeam === 0 ? 1 : 0) as TeamId;
const recRightIdx = recTeam === 0 ? prA : prB;
const receiverIndex = (serverCourt === 'R') ? recRightIdx : opp(recRightIdx);

return {
score: [a, b],
servingTeam: srvTeam,
server: { team: srvTeam, index: s.serverPlayerIndex, court: serverCourt },
receiver: { team: recTeam, index: receiverIndex, court: serverCourt },
teamPositions: [{ right: prA, left: plA }, { right: prB, left: plB }],
};
}

function markInterval(g: GameScore, pts: [number, number], rules: Required<RuleConfig>) {
if (g.intervalTaken || rules.technicalTimeoutAt == null) return;
const tt = rules.technicalTimeoutAt;
if (pts[0] >= tt || pts[1] >= tt) g.intervalTaken = true;
}
function markDeciderSwitch(g: GameScore, s: MatchState) {
if (g.deciderSidesSwitched) return;
const last = s.rules.bestOf - 1;
if (s.currentGameIndex !== last) return;
const at = s.rules.changeEndsInDeciderAt;
if (at == null) return;
const [a, b] = g.points;
if (a >= at || b >= at) g.deciderSidesSwitched = true;
}

/**

新規則：
連續得分：僅發球方換邊（posRight 互換），續發。
轉折（得→失或失→得）：兩邊都不換邊，改由對方發球。
發球區：
主場發球：看「得分」(pts[0]) 偶數右、奇數左。
客場發球：看「失分」= 客場得分 (pts[1]) 偶數右、奇數左。 */ export function nextRally(s: MatchState, rallyWinner: TeamId): MatchState { if (isMatchOver(s)) return s;
// 相容舊狀態：沒有 posRight 時初始化
if (!s.posRight) s.posRight = [s.teams[0].startRightIndex!, s.teams[1].startRightIndex!];

const g = s.games[s.currentGameIndex];
const pts = g.points.slice() as [number, number];

// 先加分
pts[rallyWinner] += 1;
g.points = pts;

if (rallyWinner === s.servingTeam) {
// 連續得分：發球方換邊，續發
s.posRight[rallyWinner] = opp(s.posRight[rallyWinner]);
// 發球區依規則 2/3
const court: Court = (rallyWinner === 0)
? (pts[0] % 2 === 0 ? 'R' : 'L') // 主場看得分
: (pts[1] % 2 === 0 ? 'R' : 'L'); // 客場看失分=客場得分
s.serverPlayerIndex = (court === 'R') ? s.posRight[rallyWinner] : opp(s.posRight[rallyWinner]);
} else {
// 轉折：不換邊；改由對方發
s.servingTeam = rallyWinner;
// 發球區依規則 2/3
const court: Court = (rallyWinner === 0)
? (pts[0] % 2 === 0 ? 'R' : 'L')
: (pts[1] % 2 === 0 ? 'R' : 'L');
s.serverPlayerIndex = (court === 'R') ? s.posRight[rallyWinner] : opp(s.posRight[rallyWinner]);
}

// 技術暫停 / 決勝局換邊旗標（僅作提示，不影響站位）
markInterval(g, pts, s.rules);
markDeciderSwitch(g, s);

if (isGameOver(s)) {
g.winner = (pts[0] > pts[1]) ? 0 : 1;

const wonA = s.games.filter(x => x.winner === 0).length;
const wonB = s.games.filter(x => x.winner === 1).length;

if (wonA < getNeedGamesToWin(s) && wonB < getNeedGamesToWin(s)) {
  // 新局：上一局勝方先發；站位復位到 startRightIndex
  const opening = g.winner!;
  s.currentGameIndex += 1;
  s.games.push({ points: [0, 0] });
  s.posRight = [s.teams[0].startRightIndex!, s.teams[1].startRightIndex!];
  s.servingTeam = opening;
  // 0:0 皆在右區發球
  s.serverPlayerIndex = s.posRight[opening];
}
}

s._version = (s._version ?? 0) + 1;
return s;
}

export function getUiSnapshot(s: MatchState) {
const rot = getRotationSnapshot(s);
const [a, b] = rot.score;
return {
scoreA: a, scoreB: b,
servingTeam: rot.servingTeam,
server: rot.server,
receiver: rot.receiver,
positions: { teamA: rot.teamPositions[0], teamB: rot.teamPositions[1] },
players: [
s.teams[0].players[0], s.teams[0].players[1],
s.teams[1].players[0], s.teams[1].players[1],
],
};
}

export function serialize(s: MatchState): string { return JSON.stringify(s); }
export function deserialize(json: string): MatchState {
const s = JSON.parse(json) as MatchState;
// 回溯：沒有 posRight 的舊狀態補上目前起始右區
if (!(s as any).posRight) {
(s as any).posRight = [s.teams[0].startRightIndex!, s.teams[1].startRightIndex!];
}
return s;
}

/* Validation: 檢查 UI 指定的 server/receiver 是否與當前應有對角一致 */
export interface ServeValidationResult {
ok: boolean;
expectedServer: { team: TeamId; index: PairIndex; court: Court };
expectedReceiver: { team: TeamId; index: PairIndex; court: Court };
errors: string[];
}

export function validateServeSelection(
s: MatchState,
chosen: { server?: { team: TeamId; index: PairIndex }, receiver?: { team: TeamId; index: PairIndex } }
): ServeValidationResult {
const snap = getRotationSnapshot(s);
const errors: string[] = [];
if (chosen.server && (chosen.server.team !== snap.server.team || chosen.server.index !== snap.server.index)) {
errors.push('WRONG_SERVER');
}
if (chosen.receiver && (chosen.receiver.team !== snap.receiver.team || chosen.receiver.index !== snap.receiver.index)) {
errors.push('WRONG_RECEIVER');
}
return {
ok: errors.length === 0,
expectedServer: snap.server,
expectedReceiver: snap.receiver,
errors,
};
}ezbmt-tracked/src/supabase/functions/invite-by-email/index.ts
 
import { serve } from 'https://deno.land/std@0.224.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'
type MemberRole = 'owner'|'coach'|'recorder'|'player'|'viewer'

serve(async (req) => {
try {
const url = Deno.env.get('SUPABASE_URL')!
const serviceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
const anonKey = Deno.env.get('SUPABASE_ANON_KEY')!

const body = await req.json().catch(() => ({}))
const { eventId, email, role } = body as { eventId?: string; email?: string; role?: MemberRole }
if (!eventId || !email || !role) return new Response('missing params', { status: 400 })

const authHeader = req.headers.get('Authorization') || ''
const jwt = authHeader.startsWith('Bearer ') ? authHeader.slice(7) : null
if (!jwt) return new Response('unauthorized', { status: 401 })

// 使用使用者 JWT 驗身分與權限（需身為該事件 owner/coach 才能邀請）
const userClient = createClient(url, anonKey, { global: { headers: { Authorization: `Bearer ${jwt}` } } })
const { data: me, error: meErr } = await userClient.auth.getUser()
if (meErr || !me?.user?.id) return new Response('unauthorized', { status: 401 })
const uid = me.user.id

const { data: can, error: roleErr } = await userClient
  .from('event_members')
  .select('role').eq('event_id', eventId).eq('user_id', uid).single()
if (roleErr || !can || !['owner','coach'].includes(String(can.role))) return new Response('forbidden', { status: 403 })

// 用 service role 查詢 auth.users by email
const admin = createClient(url, serviceKey)
const { data: userList, error: findErr } = await admin.auth.admin.listUsers({ page: 1, perPage: 1, email: email })
if (findErr) return new Response(findErr.message, { status: 500 })
const target = userList?.users?.[0]
if (!target) return new Response('user not found', { status: 404 })

// upsert event_members
const { error: upErr } = await admin.from('event_members').upsert({
  event_id: eventId, user_id: target.id, role
}, { onConflict: 'event_id,user_id' })
if (upErr) return new Response(upErr.message, { status: 400 })

return new Response(JSON.stringify({ ok: true, userId: target.id }), { status: 200, headers: { 'content-type': 'application/json' } })
} catch (e) {
return new Response(String(e?.message || e), { status: 500 })
}
})
ezbmt-tracked/src/supabase/functions/sign-upload/index.ts
 
import { serve } from 'https://deno.land/std@0.224.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

serve(async (req) => {
try {
const url = Deno.env.get('SUPABASE_URL')!
const anonKey = Deno.env.get('SUPABASE_ANON_KEY')!

const body = await req.json().catch(()=>({}))
const { matchId, contentType, ext } = body as { matchId?: string; contentType?: string; ext?: string }
if (!matchId || !contentType || !ext) return new Response('missing params', { status: 400 })

const authHeader = req.headers.get('Authorization') || ''
const jwt = authHeader.startsWith('Bearer ') ? authHeader.slice(7) : null
if (!jwt) return new Response('unauthorized', { status: 401 })

const client = createClient(url, anonKey, { global: { headers: { Authorization: `Bearer ${jwt}` } } })

// 驗證：當前使用者需為事件成員且角色為 owner/coach/recorder 才能上傳
const { data: m, error: mErr } = await client.from('matches').select('event_id').eq('id', matchId).single()
if (mErr || !m?.event_id) return new Response('match not found', { status: 404 })
const { data: em, error: emErr } = await client
  .from('event_members').select('role').eq('event_id', m.event_id).eq('user_id', (await client.auth.getUser()).data.user?.id).single()
if (emErr || !em || !['owner','coach','recorder'].includes(String(em.role))) return new Response('forbidden', { status: 403 })

// 產生路徑與簽名上傳 URL
const path = `match/${matchId}/${Date.now()}-${Math.floor(Math.random()*1e7)}.${ext}`
const { data, error } = await client.storage.from('media').createSignedUploadUrl(path)
if (error) return new Response(error.message, { status: 400 })

return new Response(JSON.stringify({ path, signedUrl: data.signedUrl }), { status: 200, headers: { 'content-type':'application/json' } })
} catch (e) {
return new Response(String(e?.message || e), { status: 500 })
}
})
ezbmt-tracked/src/supabase/functions/send_notify/index.ts
 
import { serve } from 'https://deno.land/std@0.224.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

type Payload = {
kind: 'event'|'match';
targetId: string; // event_id or match_id
title: string;
body: string;
data?: Record<string,string>;
};

serve(async (req) => {
try {
const SUPABASE_URL = Deno.env.get('SUPABASE_URL')!;
const ANON_KEY = Deno.env.get('SUPABASE_ANON_KEY')!;
const FCM_KEY = Deno.env.get('FCM_SERVER_KEY')!;
const client = createClient(SUPABASE_URL, ANON_KEY, { global: { headers: { Authorization: req.headers.get('Authorization') || '' }}});

const payload = await req.json() as Payload;
if (!payload?.targetId) return new Response('bad request', { status: 400 });

// 查所有訂閱者的 token
const { data: subs, error: se } = await client
  .from('push_subscriptions')
  .select('user_id')
  .eq('kind', payload.kind).eq('target_id', payload.targetId);
if (se) throw se;
const uids = Array.from(new Set((subs||[]).map(s => s.user_id)));

if (!uids.length) return new Response(JSON.stringify({ sent:0 }), { status:200, headers: {'content-type':'application/json'} });

const { data: tokens, error: te } = await client
  .from('device_tokens')
  .select('token')
  .in('user_id', uids as any);
if (te) throw te;

const regs = Array.from(new Set((tokens||[]).map(t => t.token))).slice(0, 900); // FCM建議每次 < 1000
if (!regs.length) return new Response(JSON.stringify({ sent:0 }), { status:200, headers:{'content-type':'application/json'}});

// 發送（FCM HTTP v1/Legacy）
const res = await fetch('https://fcm.googleapis.com/fcm/send', {
  method:'POST',
  headers: { 'Content-Type':'application/json', 'Authorization': `key=${FCM_KEY}` },
  body: JSON.stringify({
    registration_ids: regs,
    notification: { title: payload.title, body: payload.body },
    data: payload.data || {},
    priority: 'high',
  }),
});
const txt = await res.text();
return new Response(txt, { status: 200, headers: {'content-type':'application/json'} });
} catch (e) {
return new Response(String(e?.message||e), { status: 500 });
}
});
ezbmt-tracked/src/screens/EventMembersScreen.tsx
 
import React from 'react'; 
import { View, Text, FlatList, Pressable, Alert, TextInput, KeyboardAvoidingView, Platform, } from 'react-native'; 
import { useRoute } from '@react-navigation/native'; 
import { useHeaderHeight } from '@react-navigation/elements'; 
import { useSafeAreaInsets } from 'react-native-safe-area-context'; 
import { listEventMembers, getMyEventRole, upsertEventMember, deleteEventMember, getEventJoinCode, setEventJoinCode, inviteEventMemberByEmail, setEventOwnerRPC, } from '../db';
type MemberRole = 'owner'|'coach'|'recorder'|'player'|'viewer';

const ROLES: Array<{ key: MemberRole; label: string }> = [
{ key: 'owner',    label: '擁有者' },
{ key: 'coach',    label: '教練'   },
{ key: 'recorder', label: '記錄'   },
{ key: 'player',   label: '選手'   },
{ key: 'viewer',   label: '觀看'   },
];

const C = {
bg: '#111',
card: '#222',
border: '#333',
field: '#111',
fieldBorder: '#444',
text: '#fff',
sub: '#ddd',
hint: '#888',
chipOn: '#90caf9',
chipOff: '#555',
};

export default function EventMembersScreen() {
const route = useRoute<any>();
const eventId = route.params?.eventId as string;

const headerHeight = useHeaderHeight();
const insets = useSafeAreaInsets();

const [mine, setMine] = React.useState<MemberRole | null>(null);
const [items, setItems] = React.useState<Array<{ id:string; user_id:string; role:MemberRole; name:string }>>([]);
const [code, setCode] = React.useState<string>('');
const [editingCode, setEditingCode] = React.useState(false);
const [loading, setLoading] = React.useState(true);

// 邀請
const [inviteEmail, setInviteEmail] = React.useState('');
const [inviteRole, setInviteRole] = React.useState<MemberRole>('viewer');

const canManage = mine === 'owner' || mine === 'coach';
const ownersCount = React.useMemo(() => items.filter(m => m.role === 'owner').length, [items]);

const load = React.useCallback(async () => {
if (!eventId) return;
setLoading(true);
try {
const [role, members, joinCode] = await Promise.all([
getMyEventRole(eventId),
listEventMembers(eventId),
getEventJoinCode(eventId),
]);
setMine(role);
setItems(members);
setCode(joinCode || '');
} catch (e: any) {
Alert.alert('載入失敗', String(e?.message || e));
} finally {
setLoading(false);
}
}, [eventId]);

React.useEffect(() => { load(); }, [load]);

async function changeRole(memberId: string, userId: string, newRole: MemberRole) {
const isTargetOwner = items.find(m => m.id === memberId)?.role === 'owner';
if (isTargetOwner && newRole !== 'owner' && ownersCount <= 1) {
Alert.alert('無法變更', '事件至少需保留 1 位擁有者');
return;
}
try {
await upsertEventMember({ eventId, userId, role: newRole });
load();
} catch (e:any) { Alert.alert('變更失敗', String(e?.message || e)); }
}

async function removeMember(memberId: string) {
const target = items.find(m => m.id === memberId);
if (!target) return;
if (target.role === 'owner' && ownersCount <= 1) {
Alert.alert('無法移除', '事件至少需保留 1 位擁有者');
return;
}
try { await deleteEventMember(memberId); load(); }
catch (e:any) { Alert.alert('移除失敗', String(e?.message || e)); }
}

async function saveJoinCode() {
try { await setEventJoinCode(eventId, code.trim() || null); setEditingCode(false); Alert.alert('成功','加入代碼已更新'); }
catch (e:any) { Alert.alert('失敗', String(e?.message||e)); }
}
function genCode() {
const s = Math.random().toString(36).slice(2, 8).toUpperCase();
setCode(s); setEditingCode(true);
}

const renderItem = ({ item }: { item: { id:string; user_id:string; role:MemberRole; name:string } }) => (
<View style={{ padding:10, borderWidth:1, borderColor: C.border, backgroundColor: C.card, borderRadius:8, marginBottom:8 }}>
<Text style={{ fontWeight:'600', marginBottom:6, color: C.text }}>{item.name}</Text>
<View style={{ flexDirection:'row', flexWrap:'wrap', alignItems:'center' }}>
{ROLES.map(r => {
const selected = item.role === r.key;
const disabled = !canManage || (item.role === 'owner' && r.key !== 'owner' && ownersCount <= 1);
return (
<Pressable
key={r.key}
onPress={() => !disabled && changeRole(item.id, item.user_id, r.key)}
style={{
paddingVertical:6, paddingHorizontal:10, borderRadius:14,
borderWidth:1, borderColor: selected ? C.chipOn : C.chipOff,
backgroundColor: selected ? 'rgba(144,202,249,0.15)' : C.card,
marginRight:8, marginBottom:8, opacity: disabled ? 0.5 : 1
}}
>
<Text style={{ color: C.text }}>{r.label}</Text>
</Pressable>
);
})}

    {mine === 'owner' && item.role !== 'owner' && (
      <Pressable
        onPress={async()=>{
          try { await setEventOwnerRPC({ eventId, userId: item.user_id }); load(); }
          catch(e:any){ Alert.alert('失敗', String(e?.message || e)); }
        }}
        style={{ paddingVertical:6, paddingHorizontal:10, backgroundColor:'#0277bd', borderRadius:8, marginLeft:8 }}
      >
        <Text style={{ color:'#fff' }}>設為擁有者</Text>
      </Pressable>
    )}

    {canManage && (
      <Pressable
        onPress={() => removeMember(item.id)}
        style={{ paddingVertical:6, paddingHorizontal:10, backgroundColor:'#d32f2f', borderRadius:8, marginLeft:8 }}
      >
        <Text style={{ color:'#fff' }}>移除</Text>
      </Pressable>
    )}
  </View>
</View>
);

const ListHeader = (
<View style={{ borderWidth:1, borderColor:C.border, backgroundColor:C.card, borderRadius:8, padding:10, marginBottom:10 }}>
<Text style={{ fontWeight:'600', marginBottom:6, color: C.text }}>加入代碼</Text>
{editingCode ? (
<View>
<TextInput
value={code}
onChangeText={setCode}
autoCapitalize="characters"
placeholder="如：AB12CD"
placeholderTextColor={C.hint}
style={{ borderWidth:1, borderColor:C.fieldBorder, borderRadius:8, paddingHorizontal:10, paddingVertical:8, marginBottom:8, color: C.text, backgroundColor: C.field }}
/>
<View style={{ flexDirection:'row' }}>
<Pressable onPress={saveJoinCode} style={{ paddingVertical:8, paddingHorizontal:12, backgroundColor:'#1976d2', borderRadius:8, marginRight:8 }}>
<Text style={{ color:'#fff' }}>儲存</Text>
</Pressable>
<Pressable onPress={()=>{ setEditingCode(false); load(); }} style={{ paddingVertical:8, paddingHorizontal:12 }}>
<Text style={{ color: C.text }}>取消</Text>
</Pressable>
</View>
</View>
) : (
<View style={{ flexDirection:'row', alignItems:'center', flexWrap:'wrap' }}>
<Text style={{ fontSize:16, marginRight:8, color: C.text }}>{code || '未設定'}</Text>
{(mine === 'owner' || mine === 'coach') && (
<>
<Pressable onPress={()=>setEditingCode(true)} style={{ paddingVertical:6, paddingHorizontal:10, backgroundColor:'#455a64', borderRadius:8, marginRight:8 }}>
<Text style={{ color:'#fff' }}>編輯</Text>
</Pressable>
<Pressable onPress={genCode} style={{ paddingVertical:6, paddingHorizontal:10, backgroundColor:'#00897b', borderRadius:8 }}>
<Text style={{ color:'#fff' }}>重新產生</Text>
</Pressable>
</>
)}
</View>
)}
</View>
);

const ListFooter = (
<View style={{ borderTopWidth:1, borderColor:C.border, paddingTop:10, marginTop:10, paddingBottom: (insets.bottom || 12) + 12 }}>
<Text style={{ fontWeight:'600', marginBottom:6, color: C.text }}>邀請成員（Email）</Text>
<TextInput
value={inviteEmail}
onChangeText={setInviteEmail}
placeholder="example@mail.com"
placeholderTextColor={C.hint}
autoCapitalize="none"
keyboardType="email-address"
style={{ borderWidth:1, borderColor:C.fieldBorder, borderRadius:8, paddingHorizontal:10, paddingVertical:8, marginBottom:8, color: C.text, backgroundColor: C.field }}
/>
<View style={{ flexDirection:'row', flexWrap:'wrap', marginBottom:8 }}>
{(['viewer','recorder','coach','player','owner'] as const).map(r => (
<Pressable
key={r}
onPress={()=>setInviteRole(r)}
style={{ paddingVertical:6, paddingHorizontal:10, borderRadius:14, borderWidth:1, borderColor: inviteRole===r? C.chipOn:'#555', backgroundColor: inviteRole===r?'rgba(144,202,249,0.15)':C.card, marginRight:8, marginBottom:8 }}
>
<Text style={{ color: C.text }}>{r}</Text>
</Pressable>
))}
</View>
<Pressable
onPress={async()=>{
try {
await inviteEventMemberByEmail({ eventId, email: inviteEmail.trim(), role: inviteRole });
Alert.alert('成功','邀請已送出'); setInviteEmail('');
} catch(e:any){ Alert.alert('失敗', String(e?.message || e)); }
}}
style={{ backgroundColor:'#1976d2', paddingVertical:10, borderRadius:8, alignItems:'center' }}
>
<Text style={{ color:'#fff' }}>送出邀請</Text>
</Pressable>
</View>
);

return (
<KeyboardAvoidingView
style={{ flex:1, backgroundColor: C.bg }}
behavior={Platform.OS === 'ios' ? 'padding' : undefined}
keyboardVerticalOffset={headerHeight}
>
<FlatList
data={items}
keyExtractor={(i)=>i.id}
renderItem={renderItem}
ListHeaderComponent={ListHeader}
ListFooterComponent={ListFooter}
contentContainerStyle={{ padding:12 }}
keyboardShouldPersistTaps="handled"
/>
</KeyboardAvoidingView>
);
}ezbmt-tracked/src/screens/RecordScreen拷貝.tsx
 
import React from 'react';
import {
  View, Text, Modal, Pressable, FlatList, Alert, Dimensions, Animated, Easing, ScrollView,
} from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import Court from '../components/Court';
import MarkerSheet from '../components/MarkerSheet';
import type { Orientation, Side, Zone, TapEvent, Point } from '../types';
import { useRecordsStore } from '../store/records';
import {
  getMatch, getMatchPlayers, saveMatchState, upsertGameSummary,
  listRecentRallies, listRalliesOrdered, getLastRally, deleteRally, listDictionary, listGamesByMatch,
} from '../db';
import {
  createMatch as createServeMatch,
  deserialize, serialize, getUiSnapshot, nextRally,
  MatchState, RuleConfig
} from '../logic/serve';
import { publishLiveState } from '../lib/supabase';

type Marker = { id: string; rx: number; ry: number; kind: 'win' | 'loss'; meta: any; gi: number };

export default function RecordScreen({ navigation }: any) {
  const orientation: Orientation = 'portrait';

  const currentMatchId = useRecordsStore(s => s.currentMatchId);
  const loadRecent = useRecordsStore(s => s.loadRecent);
  const addRecord = useRecordsStore(s => s.addRecord);
  const records = useRecordsStore(s => s.records);

  const [panel, setPanel] = React.useState<null | {
    isWin: boolean; zone: Zone;
    tapPoint?: Point; norm?: { x: number; y: number };
    meta: any;
    route?: { start: Point; end: Point };
  }>(null);

  const [routeStart, setRouteStart] = React.useState<Point | null>(null);
  const [routeStartNorm, setRouteStartNorm] = React.useState<{ x: number; y: number } | null>(null);
  const [routeHover, setRouteHover] = React.useState<Point | null>(null);

  const [serveState, setServeState] = React.useState<MatchState | null>(null);
  const [ui, setUi] = React.useState<any>(null);

  const [loading, setLoading] = React.useState(true);
  const [mode, setMode] = React.useState<'tap' | 'route'>('tap');
  const [isSingles, setIsSingles] = React.useState<boolean>(false);

  const [shotTypes, setShotTypes] = React.useState<string[]>([]);
  const [errorReasons, setErrorReasons] = React.useState<string[]>([]);

  const [markers, setMarkers] = React.useState<Marker[]>([]);
  const [markerSheet, setMarkerSheet] = React.useState<{ visible: boolean; data: { id: string; kind: 'win' | 'loss'; meta: any } | null }>({ visible: false, data: null });

  const [endModal, setEndModal] = React.useState<{ type: 'game' | 'match'; gameIndex: number; score: [number, number] } | null>(null);
  const [deciderSwitchShownForGame, setDeciderSwitchShownForGame] = React.useState<number | null>(null);
  const [intervalShownForGame, setIntervalShownForGame] = React.useState<number | null>(null);

  // 黑點與上移
  const [focus, setFocus] = React.useState<Point | null>(null);
  const courtWrapRef = React.useRef<View>(null);
  const baseTopRef = React.useRef<number | null>(null);
  const baseHRef = React.useRef<number>(0);
  const [panelH, setPanelH] = React.useState(0);
  const [shiftY, setShiftY] = React.useState(0);

  const insets = useSafeAreaInsets();
  const winH = Dimensions.get('window').height;

  // 只顯示當前局／全部落點
  const [showOnlyCurrent, setShowOnlyCurrent] = React.useState(true);
  const currentGameNo = (serveState?.currentGameIndex ?? 0) + 1;
  const filteredMarkers = React.useMemo(
    () => showOnlyCurrent ? markers.filter(m => m.gi === currentGameNo) : markers,
    [markers, showOnlyCurrent, currentGameNo]
  );

  // 局分 chips
  const [gameRows, setGameRows] = React.useState<Array<{ index_no: number; home_score: number; away_score: number; winner_team: 0|1|null }>>([]);

  React.useEffect(() => { init(); }, [currentMatchId, loadRecent]);

  const measureCourtBase = React.useCallback(() => {
    requestAnimationFrame(() => {
      courtWrapRef.current?.measureInWindow((x, y, w, h) => {
        if (!panel && shiftY === 0) { baseTopRef.current = y; baseHRef.current = h; }
      });
    });
  }, [panel, shiftY]);
  React.useEffect(() => { measureCourtBase(); }, [measureCourtBase]);

  React.useEffect(() => {
    if (!panel) { if (shiftY !== 0) setShiftY(0); return; }
    if (!focus || panelH <= 0 || baseTopRef.current == null) return;
    const margin = 16;
    const panelTop = winH - panelH;
    const dotAbsY = baseTopRef.current + focus.y;
    const needed = Math.max(0, dotAbsY - (panelTop - margin));
    if (Math.abs(needed - shiftY) > 0.5) setShiftY(needed);
  }, [panel, panelH, focus, winH]);

  async function init() {
    if (!currentMatchId) { setLoading(false); return; }
    setLoading(true);
    try {
      const m = await getMatch(currentMatchId);
      setMode(m?.record_mode === 'route' ? 'route' : 'tap');
      setIsSingles(m?.type === 'MS' || m?.type === 'WS');

      try {
        const st = await listDictionary('shot_type');
        const er = await listDictionary('error_reason');
        setShotTypes(st.map(x => x.label));
        setErrorReasons(er.map(x => x.label));
      } catch {
        setShotTypes(['切球','網前','封網','殺球','高遠球','挑球及推後場','過渡','平抽','發球']);
        setErrorReasons(['出界','掛網','質量不好','發球失誤']);
      }

      const players = await getMatchPlayers(currentMatchId);
      let s: MatchState | null = null;
      if (m?.state_json) { try { s = deserialize(m.state_json); } catch {} }

      const homePlayers: [any, any] = [
        { id: 'A0', name: players.find(p => p.side === 'home' && p.idx === 0)?.name || '主#1' },
        { id: 'A1', name: players.find(p => p.side === 'home' && p.idx === 1)?.name || '主#2' },
      ];
      const awayPlayers: [any, any] = [
        { id: 'B0', name: players.find(p => p.side === 'away' && p.idx === 0)?.name || '客#1' },
        { id: 'B1', name: players.find(p => p.side === 'away' && p.idx === 1)?.name || '客#2' },
      ];

      const dbHomeRight = (typeof m?.home_right_when_even_index === 'number' ? (m.home_right_when_even_index as 0 | 1) : 0);
      const dbAwayRight = (typeof m?.away_right_when_even_index === 'number' ? (m.away_right_when_even_index as 0 | 1) : 0);

      if (!s) {
        const rules = normalizeRules(m?.rules_json);
        s = createServeMatch({
          teams: [
            { players: homePlayers as any, startRightIndex: dbHomeRight },
            { players: awayPlayers as any, startRightIndex: dbAwayRight },
          ],
          startingServerTeam: (typeof m?.starting_server_team === 'number' ? (m.starting_server_team as 0 | 1) : 0),
          startingServerPlayerIndex: (typeof m?.starting_server_index === 'number' ? (m.starting_server_index as 0 | 1) : undefined),
          rules,
          metadata: { category: (m?.type as any) || 'MD' },
        });
        await saveMatchState(currentMatchId, serialize(s));
      } else {
        s.teams[0].players = homePlayers as any;
        s.teams[1].players = awayPlayers as any;
        s.teams[0].startRightIndex = dbHomeRight;
        s.teams[1].startRightIndex = dbAwayRight;
        await saveMatchState(currentMatchId, serialize(s));
      }

      setServeState(s);
      setUi(getUiSnapshot(s));
      await loadRecent();

      // 最近落點
      const rows: any[] = await listRecentRallies(currentMatchId, 300);
      const ms: Marker[] = rows
        .map((r) => {
          const rx = r.route_end_rx ?? r.route_start_rx;
          const ry = r.route_end_ry ?? r.route_start_ry;
          if (rx == null || ry == null) return null;
          const kind: 'win' | 'loss' = r.winner_side === 'home' ? 'win' : 'loss';
          return { id: r.id, rx, ry, kind, meta: JSON.parse(r.meta_json || '{}'), gi: Number(r.game_index) };
        })
        .filter(Boolean) as Marker[];
      setMarkers(ms);

      // 局分 chips
      try {
        const gs = await listGamesByMatch(currentMatchId);
        setGameRows(gs as any);
      } catch {}
    } catch (e: any) {
      Alert.alert('載入失敗', String(e?.message || e));
    } finally {
      setLoading(false);
      measureCourtBase();
    }
  }

  function normalizeRules(json: string | null | undefined): RuleConfig {
    try {
      const r = json ? JSON.parse(json) : {};
      const pointsToWin = r.pointsToWin ?? r.pointsPerGame ?? 21;
      const winBy = (r.deuce === false) ? 1 : (r.winBy ?? 2);
      const cap = r.cap ?? 30;
      const bestOf = r.bestOf ?? 3;
      return { pointsToWin, winBy, cap, bestOf };
    } catch {
      return { pointsToWin: 21, winBy: 2, cap: 30, bestOf: 3 };
    }
  }

  if (!currentMatchId) {
    return (
      <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center', padding: 20 }}>
        <Text style={{ fontSize: 16, marginBottom: 8 }}>尚未選擇場次</Text>
        <Text style={{ color: '#666', textAlign: 'center' }}>請先在賽事/場次頁面建立並選取一個場次，再回到此頁記錄。</Text>
      </View>
    );
  }

  function decideWinInTap(e: TapEvent): boolean { return e.side === 'away'; }

  const openPanel = (isWin: boolean, zone: Zone, tap: TapEvent, defaults: Partial<any>, route?: { start: Point; end: Point }) => {
    if (tap?.point) setFocus({ x: tap.point.x, y: tap.point.y });
    setPanel({ isWin, zone, tapPoint: tap.point, norm: tap.norm, meta: { ...defaults }, route });
  };

  const onTap = (e: TapEvent) => {
    if (mode === 'tap') {
      const isWin = decideWinInTap(e);
      const pointRoute = { start: e.point, end: e.point };
      if (e.zone === 'out') openPanel(isWin, 'out', e, isWin ? { forceType: '對手失誤', errorReason: '出界' } : { forceType: '主動失誤', errorReason: '出界' }, pointRoute);
      else openPanel(isWin, e.zone, e, isWin ? { forceType: '主動得分' } : { forceType: '主動失誤' }, pointRoute);
    } else {
      if (!routeStart) { setRouteStart(e.point); setRouteStartNorm(e.norm ?? null); setRouteHover(null); }
      else {
        const start = routeStart, end = e.point;
        const startNorm = routeStartNorm;
        let isWin = false;
        if (startNorm && e.norm) {
          const startUpper = startNorm.y < 0.5;
          const endLower = e.norm.y > 0.5;
          isWin = startUpper && endLower && e.inBounds;
        }
        const defaults = isWin ? { forceType: '主動得分' } : { forceType: '主動失誤', errorReason: e.inBounds ? undefined : '出界' };
        openPanel(isWin, e.inBounds ? (e.zone as Zone) : 'out', e, defaults, { start, end });
        setRouteStart(null); setRouteStartNorm(null); setRouteHover(null);
      }
    }
  };

  const onPressMarker = (id: string) => {
    const m = markers.find(x => x.id === id);
    if (!m) return;
    setMarkerSheet({ visible: true, data: { id: m.id, kind: m.kind, meta: m.meta } });
  };

  async function rebuildServeFromDB() {
    const m = await getMatch(currentMatchId!);
    const players = await getMatchPlayers(currentMatchId!);
    const homePlayers: [any, any] = [
      { id: 'A0', name: players.find(p => p.side === 'home' && p.idx === 0)?.name || '主#1' },
      { id: 'A1', name: players.find(p => p.side === 'home' && p.idx === 1)?.name || '主#2' },
    ];
    const awayPlayers: [any, any] = [
      { id: 'B0', name: players.find(p => p.side === 'away' && p.idx === 0)?.name || '客#1' },
      { id: 'B1', name: players.find(p => p.side === 'away' && p.idx === 1)?.name || '客#2' },
    ];
    const dbHomeRight = (typeof m?.home_right_when_even_index === 'number' ? (m.home_right_when_even_index as 0 | 1) : 0);
    const dbAwayRight = (typeof m?.away_right_when_even_index === 'number' ? (m.away_right_when_even_index as 0 | 1) : 0);
    const rules = normalizeRules(m?.rules_json);

    let s = createServeMatch({
      teams: [
        { players: homePlayers as any, startRightIndex: dbHomeRight },
        { players: awayPlayers as any, startRightIndex: dbAwayRight },
      ],
      startingServerTeam: (typeof m?.starting_server_team === 'number' ? (m.starting_server_team as 0 | 1) : 0),
      startingServerPlayerIndex: (typeof m?.starting_server_index === 'number' ? (m.starting_server_index as 0 | 1) : undefined),
      rules,
      metadata: { category: (m?.type as any) || 'MD' },
    });

    const all = await listRalliesOrdered(currentMatchId!);
    for (const r of all) {
      const winTeam = r.winner_side === 'home' ? 0 : 1;
      s = nextRally(s, winTeam);
    }
    await saveMatchState(currentMatchId!, serialize(s));
    setServeState(s);
    setUi(getUiSnapshot(s));
    try { publishLiveState(currentMatchId!, getUiSnapshot(s)); } catch {}
  }

  async function handleDeleteRally(id: string) {
    try {
      await deleteRally(id);
      setMarkerSheet({ visible: false, data: null });
      const rows: any[] = await listRecentRallies(currentMatchId!, 300);
      const ms: Marker[] = rows
        .map((r) => {
          const rx = r.route_end_rx ?? r.route_start_rx;
          const ry = r.route_end_ry ?? r.route_start_ry;
          if (rx == null || ry == null) return null;
          const kind: 'win' | 'loss' = r.winner_side === 'home' ? 'win' : 'loss';
          return { id: r.id, rx, ry, kind, meta: JSON.parse(r.meta_json || '{}'), gi: Number(r.game_index) };
        })
        .filter(Boolean) as Marker[];
      setMarkers(ms);
      await loadRecent();
      await rebuildServeFromDB();
    } catch (e: any) {
      Alert.alert('刪除失敗', String(e?.message || e));
    }
  }

  async function undoLast() {
    const last = await getLastRally(currentMatchId!);
    if (!last) return Alert.alert('提示', '沒有可撤銷的記錄');
    await handleDeleteRally(last.id);
  }

  const savePanel = async () => {
    if (!panel || !serveState) return;
    try {
      const winnerSide: Side = panel.isWin ? 'home' : 'away';

      await addRecord({
        gameIndex: (serveState.currentGameIndex + 1),
        rallyNo: records.filter(r => r.gameIndex === (serveState.currentGameIndex + 1)).length + 1,
        winnerSide,
        endZone: panel.zone,
        route: panel.route ?? (panel.tapPoint ? { start: panel.tapPoint, end: panel.tapPoint } : undefined),
        routeNorm: panel.norm ? { start: panel.norm, end: panel.norm } : undefined,
        meta: panel.meta,
      });

      const beforeIdx = serveState.currentGameIndex;
      let next = nextRally({ ...serveState }, (winnerSide === 'home') ? 0 : 1);
      setServeState(next);
      setUi(getUiSnapshot(next));
      try { publishLiveState(currentMatchId!, getUiSnapshot(next)); } catch {}

      if (next.currentGameIndex > beforeIdx) {
        const ended = next.games[beforeIdx];
        const score = ended.points as [number, number];
        const wonA = next.games.filter(x => x.winner === 0).length;
        const wonB = next.games.filter(x => x.winner === 1).length;
        const need = Math.floor((next.rules.bestOf || 3) / 2) + 1;
        const isMatchOver = (wonA >= need || wonB >= need);
        setEndModal({ type: isMatchOver ? 'match' : 'game', gameIndex: beforeIdx + 1, score });
        setIntervalShownForGame(null);
        setDeciderSwitchShownForGame(null);
      } else {
        const idx = next.currentGameIndex;
        const cur = next.games[idx];
        if (cur.intervalTaken && intervalShownForGame !== idx) {
          Alert.alert('技術暫停', '已達技術暫停分數，請暫停與休息。');
          setIntervalShownForGame(idx);
        }
        if (cur.deciderSidesSwitched && deciderSwitchShownForGame !== idx) {
          Alert.alert('換邊提示', '決勝局中場換邊，請注意場地交換。');
          setDeciderSwitchShownForGame(idx);
        }
      }

      const idx = next.currentGameIndex;
      const cur = next.games[idx];
      const [a, b] = cur.points;
      await upsertGameSummary({
        matchId: currentMatchId!,
        gameIndex: idx + 1,
        home: a, away: b,
        winnerTeam: cur.winner ?? null,
        intervalTaken: !!cur.intervalTaken,
        deciderSwitched: !!cur.deciderSidesSwitched,
      });

      if (panel.norm) {
        const giForMarker = (serveState.currentGameIndex ?? 0) + 1;
        setMarkers((ms) => [
          { id: Math.random().toString(36).slice(2), rx: panel.norm!.x, ry: panel.norm!.y, kind: panel.isWin ? 'win' : 'loss', meta: panel.meta, gi: giForMarker },
          ...ms,
        ]);
      }

      await saveMatchState(currentMatchId!, serialize(next));

      setPanel(null);
      setShiftY(0);
      setFocus(null);

      try { await loadRecent(); } catch {}
      try { const gs = await listGamesByMatch(currentMatchId!); setGameRows(gs as any); } catch {}
    } catch (e: any) {
      Alert.alert('儲存失敗', String(e?.message || e));
    }
  };

  const servingTeam = ui?.servingTeam ?? 0;
  const serverTeam = ui?.server?.team ?? 0;
  const serverIdx0 = ui?.server?.index ?? 0;
  const serverCourt = ui?.server?.court === 'R' ? '右' : '左';
  const receiverTeam = ui?.receiver?.team ?? 1;
  const receiverIdx0 = ui?.receiver?.index ?? 0;
  const scoreA = ui?.scoreA ?? 0;
  const scoreB = ui?.scoreB ?? 0;

  const posA = ui?.positions?.teamA, posB = ui?.positions?.teamB;
  const A_right = typeof posA?.right === 'number' ? serveState?.teams?.[0]?.players?.[posA.right]?.name : '';
  const A_left  = typeof posA?.left  === 'number' ? serveState?.teams?.[0]?.players?.[posA.left ]?.name : '';
  const B_right = typeof posB?.right === 'number' ? serveState?.teams?.[1]?.players?.[posB?.right]?.name : '';
  const B_left  = typeof posB?.left  === 'number' ? serveState?.teams?.[1]?.players?.[posB?.left ]?.name : '';

  // 右側滑出記錄側欄
  const [historyOpen, setHistoryOpen] = React.useState(false);
  const [historyRows, setHistoryRows] = React.useState<any[]>([]);
  const histAnim = React.useRef(new Animated.Value(0)).current;
  const sheetW = Math.min(320, Math.floor(Dimensions.get('window').width * 0.85));

  const openHistory = React.useCallback(async () => {
    try {
      if (currentMatchId) {
        const rows = await listRalliesOrdered(currentMatchId);
        setHistoryRows([...rows].reverse());
      }
    } catch {}
    setHistoryOpen(true);
    Animated.timing(histAnim, { toValue: 1, duration: 220, easing: Easing.out(Easing.cubic), useNativeDriver: true }).start();
  }, [currentMatchId, histAnim]);

  const closeHistory = React.useCallback(() => {
    Animated.timing(histAnim, { toValue: 0, duration: 200, easing: Easing.in(Easing.cubic), useNativeDriver: true })
      .start(() => setHistoryOpen(false));
  }, [histAnim]);

  const sheetTx = histAnim.interpolate({ inputRange: [0, 1], outputRange: [sheetW, 0] });
  const overlayOpacity = histAnim.interpolate({ inputRange: [0, 1], outputRange: [0, 0.35] });

  const Badge = ({ kind }: { kind: 'win' | 'loss' }) => (
    <View style={{ width: 10, height: 10, borderRadius: 5, backgroundColor: kind === 'win' ? '#1976d2' : '#d32f2f', marginRight: 8, marginTop: 6 }} />
  );

  const Row = ({ item }: { item: any }) => {
    const meta = safeMeta(item.meta_json);
    const isWin = item.winner_side === 'home';
    const color = isWin ? '#1976d2' : '#d32f2f';
    const label = `第${item.game_index}局 #${item.rally_no} ${isWin ? '得分' : '失分'} 區${String(item.end_zone)} ${meta.shotType || ''} ${meta.forceType || ''} ${meta.errorReason || ''}`;
    return (
      <View style={{ flexDirection: 'row', alignItems: 'flex-start', paddingVertical: 8, borderBottomWidth: 1, borderColor: '#f2f2f2' }}>
        <Badge kind={isWin ? 'win' : 'loss'} />
        <Text style={{ color }}>{label}</Text>
      </View>
    );
  };

  // 局分 Chips（含「落點篩選」小 chip）
  const renderGameChips = () => {
    const map = new Map<number, { a: number; b: number; w: 0 | 1 | null }>();
    gameRows.forEach(g => map.set(Number(g.index_no), { a: Number(g.home_score||0), b: Number(g.away_score||0), w: (g.winner_team==0||g.winner_team==1)?(g.winner_team as 0|1):null }));
    if (serveState) {
      serveState.games.forEach((g, i) => {
        const idx = i + 1;
        const cur = map.get(idx) || { a: 0, b: 0, w: null };
        const [a, b] = g.points || [0, 0];
        map.set(idx, { a, b, w: (g.winner==0||g.winner==1)?(g.winner as 0|1):cur.w });
      });
    }
    const list = Array.from(map.entries()).sort((a,b)=>a[0]-b[0]);
    if (list.length === 0) return null;

    return (
      <View style={{ height: 36 }}>
        <ScrollView horizontal showsHorizontalScrollIndicator={false} contentContainerStyle={{ paddingHorizontal: 12, alignItems: 'center' }}>
          {list.map(([i, g]) => {
            const isCur = i === currentGameNo;
            const bg = isCur ? '#1976d2' : '#eceff1';
            const fg = isCur ? '#fff' : '#333';
            const ring = g.w==null ? 'transparent' : (g.w===0 ? '#42a5f5' : '#ef5350');
            return (
              <View key={i} style={{ height: 28, paddingHorizontal: 10, borderRadius: 14, backgroundColor: bg, marginRight: 8, flexDirection:'row', alignItems:'center' }}>
                {g.w!=null && <View style={{ width:6, height:6, borderRadius:3, backgroundColor:ring, marginRight:6 }} />}
                <Text style={{ color: fg, fontSize: 13 }}>{`G${i}  ${g.a} - ${g.b}`}</Text>
              </View>
            );
          })}
          {/* 右側：落點篩選 Chip（不佔版面） */}
          <Pressable
            onPress={() => setShowOnlyCurrent(v => !v)}
            style={{
              height: 28, paddingHorizontal: 10, borderRadius: 14, marginLeft: 2,
              backgroundColor: showOnlyCurrent ? '#9e9e9e' : '#1976d2', alignItems: 'center', justifyContent: 'center'
            }}
          >
            <Text style={{ color: '#fff', fontSize: 12 }}>{showOnlyCurrent ? '本局落點' : '全部落點'}</Text>
          </Pressable>
        </ScrollView>
      </View>
    );
  };

  return (
    <View style={{ flex: 1 }}>
      {/* 可位移內容（頂部 + 局分 Chips + 球場） */}
      <View style={{ flex: 1, transform: [{ translateY: -shiftY }] }}>
        <View style={{ paddingHorizontal: 12, paddingTop: 8, paddingBottom: 6, backgroundColor: '#fafafa', borderBottomWidth: 1, borderColor: '#eee' }}>
          <View style={{ flexDirection:'row', justifyContent:'space-between', alignItems:'center' }}>
            <Text style={{ fontSize: 16, fontWeight: '600' }}>記錄模式（{isSingles ? '單打' : '雙打'}）</Text>
            <View style={{ flexDirection:'row' }}>
              <Pressable onPress={undoLast} style={{ paddingVertical:6, paddingHorizontal:10, backgroundColor:'#455a64', borderRadius:8, marginRight:8 }}>
                <Text style={{ color:'#fff' }}>撤銷上一筆</Text>
              </Pressable>
              <Pressable onPress={()=>navigation.navigate('Analysis',{ matchId: currentMatchId })} style={{ paddingVertical:6, paddingHorizontal:10, backgroundColor:'#1976d2', borderRadius:8, marginRight:8 }}>
                <Text style={{ color:'#fff' }}>分析</Text>
              </Pressable>
              <Pressable onPress={openHistory} style={{ paddingVertical:6, paddingHorizontal:10, backgroundColor:'#00695c', borderRadius:8 }}>
                <Text style={{ color:'#fff' }}>記錄</Text>
              </Pressable>
            </View>
          </View>
          <Text style={{ color: '#555', marginTop: 6 }}>
            發球方：{ui?.servingTeam === 0 ? '主隊' : '客隊'}，發：
            {serveState?.teams?.[serverTeam]?.players?.[serverIdx0]?.name || ''}（{serverCourt}），接：
            {serveState?.teams?.[receiverTeam]?.players?.[receiverIdx0]?.name || ''}，比分：{ui?.scoreA ?? 0} - {ui?.scoreB ?? 0}
          </Text>
        </View>

        {renderGameChips()}

        <View ref={courtWrapRef} onLayout={measureCourtBase} style={{ flex: 1 }}>
          <Court
            orientation={orientation}
            singles={isSingles}
            mode={mode}
            routeStart={routeStart}
            routeHover={routeHover}
            onHover={setRouteHover}
            onTap={onTap}
            markers={filteredMarkers}
            onPressMarker={onPressMarker}
            overlay={{
              homeRight: (typeof ui?.positions?.teamA?.right === 'number' ? serveState?.teams?.[0]?.players?.[ui.positions.teamA.right]?.name : '') || '',
              homeLeft:  (typeof ui?.positions?.teamA?.left  === 'number' ? serveState?.teams?.[0]?.players?.[ui.positions.teamA.left ]?.name : '') || '',
              awayRight: (typeof ui?.positions?.teamB?.right === 'number' ? serveState?.teams?.[1]?.players?.[ui.positions.teamB.right]?.name : '') || '',
              awayLeft:  (typeof ui?.positions?.teamB?.left  === 'number' ? serveState?.teams?.[1]?.players?.[ui.positions.teamB.left ]?.name : '') || '',
              server: ui?.server ? { team: ui.server.team as 0|1, index: ui.server.index as 0|1 } : undefined,
              receiver: ui?.receiver ? { team: ui.receiver.team as 0|1, index: ui.receiver.index as 0|1 } : undefined,
              positions: {
                A: { right: (ui?.positions?.teamA?.right ?? 0) as 0|1, left: (ui?.positions?.teamA?.left ?? 1) as 0|1 },
                B: { right: (ui?.positions?.teamB?.right ?? 0) as 0|1, left: (ui?.positions?.teamB?.left ?? 1) as 0|1 },
              },
              opacity: 0.85,
            }}
            focusPoint={focus}
          />
        </View>
      </View>

      {(historyOpen || (histAnim as any)._value > 0) && (
        <View pointerEvents="box-none" style={{ position: 'absolute', left: 0, right: 0, top: 0, bottom: 0 }}>
          <Animated.View pointerEvents={historyOpen ? 'auto' : 'none'} style={{ position: 'absolute', left: 0, top: 0, right: 0, bottom: 0, backgroundColor: '#000', opacity: overlayOpacity }} />
          <Pressable onPress={closeHistory} style={{ position: 'absolute', left: 0, top: 0, right: 0, bottom: 0 }} />
          <Animated.View style={{ position: 'absolute', right: 0, top: insets.top + 8, bottom: insets.bottom + 8, width: sheetW, backgroundColor: '#fff', borderTopLeftRadius: 16, borderBottomLeftRadius: 16, shadowColor: '#000', shadowOpacity: 0.2, shadowOffset: { width: -2, height: 0 }, shadowRadius: 8, elevation: 6, transform: [{ translateX: sheetTx }], overflow: 'hidden' }}>
            <View style={{ paddingHorizontal: 12, paddingVertical: 10, borderBottomWidth: 1, borderColor: '#eee', flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' }}>
              <Text style={{ fontSize: 16, fontWeight: '700' }}>記錄清單</Text>
              <Pressable onPress={closeHistory} style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#1976d2', borderRadius: 8 }}>
                <Text style={{ color:'#fff' }}>關閉</Text>
              </Pressable>
            </View>
            <FlatList contentContainerStyle={{ padding: 12 }} data={historyRows} keyExtractor={(i:any)=>i.id} renderItem={({ item }:any)=><Row item={item}/>} />
          </Animated.View>
        </View>
      )}

      <MetaPanel
        visible={!!panel}
        isWin={!!panel?.isWin}
        meta={panel?.meta || {}}
        onChange={(m) => setPanel(p => p ? ({ ...p, meta: m }) : p)}
        onCancel={() => { setPanel(null); setShiftY(0); setFocus(null); }}
        onSave={savePanel}
        showErrorReason={!panel?.isWin}
        players={[
          { id: 'A0', name: serveState?.teams?.[0]?.players?.[0]?.name || '主#1' },
          { id: 'A1', name: serveState?.teams?.[0]?.players?.[1]?.name || '主#2' },
          { id: 'B0', name: serveState?.teams?.[1]?.players?.[0]?.name || '客#1' },
          { id: 'B1', name: serveState?.teams?.[1]?.players?.[1]?.name || '客#2' },
        ]}
        showLastHitter={mode === 'route'}
        options={{ shotTypes, errorReasons }}
        onMeasure={setPanelH}
      />

      <MarkerSheet visible={markerSheet.visible} data={markerSheet.data} onClose={() => setMarkerSheet({ visible:false, data:null })} onDelete={async (id)=>{ await handleDeleteRally(id); setShiftY(0); setFocus(null); }} />

      {endModal && (
        <Modal visible transparent animationType="fade" onRequestClose={() => setEndModal(null)}>
          <View style={{ flex:1, backgroundColor:'rgba(0,0,0,0.4)', justifyContent:'center', alignItems:'center' }}>
            <View style={{ backgroundColor:'#fff', padding:16, borderRadius:12, width:'80%' }}>
              <Text style={{ fontSize:16, fontWeight:'600', marginBottom:8 }}>
                {endModal.type === 'match' ? '比賽結束' : `第 ${endModal.gameIndex} 局結束`}
              </Text>
              <Text style={{ marginBottom:12 }}>比分：{ui?.scoreA ?? 0} - {ui?.scoreB ?? 0}</Text>
              <Pressable onPress={()=>setEndModal(null)} style={{ alignSelf:'flex-end', paddingVertical:8, paddingHorizontal:14, backgroundColor:'#1976d2', borderRadius:8 }}>
                <Text style={{ color:'#fff' }}>{endModal.type==='match' ? '完成' : '開始下一局'}</Text>
              </Pressable>
            </View>
          </View>
        </Modal>
      )}
    </View>
  );
}

/* 面板（底部按鈕固定） */
function MetaPanel({
  visible, isWin, meta, onChange, onCancel, onSave, showErrorReason, players, showLastHitter, options, onMeasure,
}: {
  visible: boolean; isWin: boolean; meta: any; onChange: (m: any) => void; onCancel: () => void; onSave: () => void; showErrorReason: boolean;
  players: Array<{ id: string; name?: string }>;
  showLastHitter?: boolean;
  options: { shotTypes: string[]; errorReasons: string[] };
  onMeasure?: (h: number) => void;
}) {
  const insets = useSafeAreaInsets();
  const forceOptions = isWin ? ['主動得分', '對手失誤'] : ['主動失誤', '受迫失誤'];
  return (
    <Modal visible={visible} transparent animationType="slide" onRequestClose={onCancel}>
      <View style={{ flex: 1, backgroundColor:'rgba(0,0,0,0.35)', justifyContent:'flex-end' }}>
        <View style={{ backgroundColor:'#fff', borderTopLeftRadius:16, borderTopRightRadius:16, maxHeight:'65%', overflow:'hidden' }} onLayout={(e)=>onMeasure?.(e.nativeEvent.layout.height)}>
          <View style={{ paddingHorizontal:16, paddingTop:12, paddingBottom:8 }}>
            <Text style={{ fontSize:16, fontWeight:'600' }}>{isWin?'得分選項':'失分選項'}</Text>
          </View>
          <View style={{ flexGrow:1 }}>
            <FlatList contentContainerStyle={{ paddingHorizontal:16, paddingBottom:12 }} data={[0]} keyExtractor={()=>'panel-content'} renderItem={()=>(<View>
              <Group title="球種"><ChipList options={options.shotTypes} value={meta.shotType} onSelect={(v)=>onChange({ ...meta, shotType: v===meta.shotType? undefined: v })} /></Group>
              <Group title="正手/反手"><ChipList options={['正手','反手']} value={meta.hand} onSelect={(v)=>onChange({ ...meta, hand: v as any })} /></Group>
              <Group title={isWin?'是否主動得分':'是否主動失誤'}><ChipList options={isWin?['主動得分','對手失誤']:['主動失誤','受迫失誤']} value={meta.forceType} onSelect={(v)=>onChange({ ...meta, forceType: v })} /></Group>
              {!isWin && showErrorReason && (<Group title="失誤原因"><ChipList options={options.errorReasons as any} value={meta.errorReason} onSelect={(v)=>onChange({ ...meta, errorReason: v })} /></Group>)}
            </View>)} />
          </View>
          <View style={{ borderTopWidth:1, borderColor:'#eee', paddingHorizontal:12, paddingTop:10, paddingBottom:Math.max(12,insets.bottom+10), flexDirection:'row', justifyContent:'flex-end' }}>
            <Pressable onPress={onCancel} style={{ padding:12, marginRight:8 }}><Text>取消</Text></Pressable>
            <Pressable onPress={onSave} style={{ padding:12, backgroundColor:'#1976d2', borderRadius:8 }}><Text style={{ color:'#fff' }}>儲存</Text></Pressable>
          </View>
        </View>
      </View>
    </Modal>
  );
}
function Group({ title, children }: any) { return (<View style={{ marginBottom: 10 }}><Text style={{ marginBottom: 6, color: '#333' }}>{title}</Text>{children}</View>); }
function ChipList({ options, value, onSelect }: { options: string[]; value?: string; onSelect: (v: string) => void }) {
  return (
    <View style={{ flexDirection:'row', flexWrap:'wrap' }}>
      {options.map((opt) => (
        <Pressable key={opt} onPress={() => onSelect(opt)} style={{ paddingVertical:6, paddingHorizontal:10, borderRadius:14, borderWidth:1, borderColor: value===opt? '#1976d2':'#ccc', backgroundColor: value===opt? 'rgba(25,118,210,0.1)':'#fff', marginRight:8, marginBottom:8 }}>
          <Text>{opt}</Text>
        </Pressable>
      ))}
    </View>
  );
}
function safeMeta(json: string) { try { return JSON.parse(json || '{}'); } catch { return {}; } }ezbmt-tracked/src/screens/SpeedCamScreen.tsx
 
import React from 'react';
import { View, Text, Pressable, Alert, Dimensions } from 'react-native';
import {
Camera,
useCameraDevice,
useFrameProcessor,
VisionCameraProxy,
type FrameProcessorPlugin,
} from 'react-native-vision-camera';
import { runOnJS } from 'react-native-reanimated';
import { insertSpeedSession, insertSpeedPoints } from '../db';

type Sample = { x: number; y: number; ts: number; score: number; w?: number; h?: number };
type Pt = { x: number; y: number };

export default function SpeedCamScreen() {
const device = useCameraDevice('back');

// 權限
const [hasPerm, setHasPerm] = React.useState(false);
React.useEffect(() => {
(async () => {
const cam = await Camera.requestCameraPermission();
setHasPerm(cam === 'granted');
})();
}, []);

// 即時速度
const [speedMs, setSpeedMs] = React.useState(0);
const updateSpeed = React.useCallback((msInst: number) => {
setSpeedMs((prev) => (prev === 0 ? msInst : prev * 0.7 + msInst * 0.3));
}, []);

// 上一筆樣本
const lastRef = React.useRef<Sample | null>(null);

// 校正
const [calibMode, setCalibMode] = React.useState(false);
const [calibA, setCalibA] = React.useState<Pt | null>(null);
const [calibB, setCalibB] = React.useState<Pt | null>(null);
const [metersPerUnit, setMetersPerUnit] = React.useState<number | null>(null);

// 視圖與幀尺寸
const [viewSize, setViewSize] = React.useState({
w: Dimensions.get('window').width,
h: Dimensions.get('window').height * 0.7,
});
const frameSizeRef = React.useRef<{ w: number; h: number } | null>(null);

// 錄製
const [recording, setRecording] = React.useState(false);
const recordBufRef = React.useRef<Array<{ idx: number; x: number; y: number; ts: number }>>([]);

// 取得原生 Frame Processor Plugin（相容多版本）
const speedPlugin = React.useMemo<FrameProcessorPlugin | undefined>(() => {
try {
const proxy: any = VisionCameraProxy as any;
const getter =
proxy?.getFrameProcessorPlugin /* VC v3/部分版本 / ??
proxy?.initFrameProcessorPlugin; / 你目前的版本 */
return typeof getter === 'function' ? getter('SpeedTracker') : undefined;
} catch {
return undefined;
}
}, []);

// 畫面點擊 -> 幀 normalized（0..1），含 aspectFill 修正
const toFrameNorm = React.useCallback(
(vx: number, vy: number): Pt | null => {
const fs = frameSizeRef.current;
if (!fs) return null;
const VW = viewSize.w, VH = viewSize.h;
const FW = fs.w, FH = fs.h;
if (!VW || !VH || !FW || !FH) return null;

  const scale = Math.max(VW / FW, VH / FH);
  const dispW = FW * scale, dispH = FH * scale;
  const offX = (dispW - VW) / 2;
  const offY = (dispH - VH) / 2;

  const fx = (vx + offX) / scale;
  const fy = (vy + offY) / scale;
  return { x: Math.min(1, Math.max(0, fx / FW)), y: Math.min(1, Math.max(0, fy / FH)) };
},
[viewSize],
);

// 點擊校正
const onTapOverlay = (evt: any) => {
if (!calibMode) return;
const { locationX, locationY } = evt.nativeEvent;
const p = toFrameNorm(locationX, locationY);
if (!p) { Alert.alert('等待相機幀尺寸…'); return; }
if (!calibA) setCalibA(p);
else if (!calibB) setCalibB(p);
else { setCalibA(p); setCalibB(null); }
};

const applyCalib = (knownMeters: number) => {
if (!calibA || !calibB) { Alert.alert('請在畫面上點兩點'); return; }
const du = Math.hypot(calibB.x - calibA.x, calibB.y - calibA.y);
if (du < 1e-4) { Alert.alert('兩點太近'); return; }
setMetersPerUnit(knownMeters / du);
setCalibMode(false);
};

// 錄製控制
const startRecord = () => {
recordBufRef.current = [];
setRecording(true);
};
const stopRecordAndSave = async () => {
setRecording(false);
const rows = recordBufRef.current.slice();
if (rows.length < 2) { Alert.alert('提示', '資料不足，未儲存'); return; }
try {
const sid = await insertSpeedSession('camera', 'kmh');
await insertSpeedPoints(
sid,
rows.map((r, i) => ({ idx: i, rx: r.x, ry: r.y, ts: Math.round(r.ts * 1000) })),
);
Alert.alert('已儲存', '共 ${rows.length} 筆！');
} catch (e: any) {
Alert.alert('儲存失敗', String(e?.message || e));
}
};

// JS 端樣本處理（一定要在 frameProcessor 前宣告）
const onSampleCalc = React.useCallback(
(s: Sample) => {
if (typeof s.w === 'number' && typeof s.h === 'number' && s.w > 0 && s.h > 0) {
frameSizeRef.current = { w: s.w, h: s.h };
}
const last = lastRef.current;
if (last && metersPerUnit != null) {
const dt = s.ts - last.ts;
if (dt > 0) {
const du = Math.hypot(s.x - last.x, s.y - last.y);
const meters = du * metersPerUnit;
const mps = meters / dt;
updateSpeed(mps);
}
}
lastRef.current = s;

  if (recording) {
    const buf = recordBufRef.current;
    buf.push({ idx: buf.length, x: s.x, y: s.y, ts: s.ts });
  }
},
[metersPerUnit, recording, updateSpeed],
);

// 唯一的 frameProcessor（從外層捕捉 speedPlugin）
const frameProcessor = useFrameProcessor(
(frame) => {
'worklet';

  // 30Hz 節流
  // @ts-ignore
  const last = globalThis.__lastFP || 0;
  const dt = frame.timestamp - last;
  if (dt < 1 / 30) return;
  // @ts-ignore
  globalThis.__lastFP = frame.timestamp;

  // 捕捉進來的 plugin（相容 .call 或直接呼叫）
  // @ts-ignore
  const p = speedPlugin as any;
  if (!p) return;
  // @ts-ignore
  const res = p.call ? p.call(frame, {}) : p(frame, {});
  if (!res) return;

  const s = {
    x: res.x as number,
    y: res.y as number,
    ts: res.ts as number,
    score: res.score as number,
    w: res.w as number,
    h: res.h as number,
  };
  if (s.score < 10) return;

  runOnJS(onSampleCalc)(s);
},
[onSampleCalc, speedPlugin],
);

if (!device)
return <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}><Text>找不到可用相機</Text></View>;
if (!hasPerm)
return <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}><Text>尚未取得相機權限</Text></View>;

const kmh = speedMs * 3.6;

return (
<View style={{ flex: 1 }}>
<Camera style={{ flex: 1 }} device={device} isActive frameProcessor={frameProcessor} />

  {/* 透明點擊層（校正用） */}
  <View
    onLayout={(e) => {
      const { width, height } = e.nativeEvent.layout;
      setViewSize({ w: width, h: height });
    }}
    onStartShouldSetResponder={() => true}
    onResponderRelease={onTapOverlay}
    pointerEvents="box-only"
    style={{ position: 'absolute', left: 0, right: 0, top: 0, bottom: 0 }}
  />

  {/* UI 面板 */}
  <View style={{ position: 'absolute', left: 10, right: 10, bottom: 10, backgroundColor: 'rgba(0,0,0,0.55)', borderRadius: 12, padding: 12 }}>
    <Text style={{ color: '#fff', fontSize: 18, fontWeight: '700' }}>{kmh.toFixed(1)} km/h ({speedMs.toFixed(2)} m/s)</Text>
    <Text style={{ color: '#fff', marginTop: 4 }}>
      校正：{metersPerUnit ? `${metersPerUnit.toFixed(3)} m / normalized-unit` : '尚未校正'}
    </Text>

    <View style={{ flexDirection: 'row', marginTop: 8, flexWrap: 'wrap' }}>
      <Pressable onPress={() => { setCalibMode((v) => !v); setCalibA(null); setCalibB(null); }}
        style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#1976d2', borderRadius: 8, marginRight: 8, marginBottom: 8 }}>
        <Text style={{ color: '#fff' }}>{calibMode ? '退出校正' : '校正模式'}</Text>
      </Pressable>

      {calibMode && (
        <>
          <Pressable onPress={() => applyCalib(6.1)}
            style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#2e7d32', borderRadius: 8, marginRight: 8, marginBottom: 8 }}>
            <Text style={{ color: '#fff' }}>雙打寬 6.1m</Text>
          </Pressable>
          <Pressable onPress={() => applyCalib(5.18)}
            style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#00796b', borderRadius: 8, marginRight: 8, marginBottom: 8 }}>
            <Text style={{ color: '#fff' }}>單打寬 5.18m</Text>
          </Pressable>
        </>
      )}

      <Pressable onPress={() => { setMetersPerUnit(null); setCalibA(null); setCalibB(null); }}
        style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#9e9e9e', borderRadius: 8, marginRight: 8, marginBottom: 8 }}>
        <Text style={{ color: '#fff' }}>清除校正</Text>
      </Pressable>

      {!recording ? (
        <Pressable onPress={startRecord}
          style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#e53935', borderRadius: 8, marginLeft: 8 }}>
          <Text style={{ color: '#fff' }}>開始錄製</Text>
        </Pressable>
      ) : (
        <Pressable onPress={stopRecordAndSave}
          style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#8e24aa', borderRadius: 8, marginLeft: 8 }}>
          <Text style={{ color: '#fff' }}>停止並儲存</Text>
        </Pressable>
      )}
    </View>

    {calibMode && (
      <Text style={{ color: '#fff', marginTop: 6 }}>
        校正說明：在預覽畫面上點兩點（例如球場左右邊線），再點選 6.1m 或 5.18m。
      </Text>
    )}
  </View>
</View>
);
}

ezbmt-tracked/src/screens/MatchesScreen.tsx
 
import React from 'react';
import { View, Text, FlatList, Pressable, TextInput, Alert, Platform, ActionSheetIOS } from 'react-native';
import { useRoute, useNavigation, useFocusEffect } from '@react-navigation/native';
import { insertMatch, listMatches, updateMatchRules, setMatchRecordMode, getMatchPlayers, deleteMatch, hasMatchRallies, openDB } from '../db';
import { useRecordsStore } from '../store/records';
import MatchRulesSheet from '../components/MatchRulesSheet';
import { BACKEND } from '../lib/backend';
import { supa } from '../lib/supabase';

type MatchRow = {
  id: string;
  type: 'MS' | 'WS' | 'MD' | 'WD' | 'XD';
  court_no: string | null;
  rules_json: string | null;
  record_mode?: 'tap' | 'route' | null;
};

type PlayerMap = Record<string, { home: [string|null, string|null]; away: [string|null, string|null] }>;
type GameSum = { i: number; home: number; away: number; winner: 0|1|null };
type GamesMap = Record<string, GameSum[]>;

const TYPE_OPTIONS: Array<{ label: string; value: MatchRow['type'] }> = [
  { label: 'MS', value: 'MS' },
  { label: 'WS', value: 'WS' },
  { label: 'MD', value: 'MD' },
  { label: 'WD', value: 'WD' },
  { label: 'XD', value: 'XD' },
];

export default function MatchesScreen() {
  const route = useRoute<any>();
  const navigation = useNavigation<any>();
  const eventId = route.params?.eventId as string;

  const [items, setItems] = React.useState<MatchRow[]>([]);
  const [type, setType] = React.useState<MatchRow['type']>('MD');
  const [court, setCourt] = React.useState('');
  const [playersMap, setPlayersMap] = React.useState<PlayerMap>({});
  const [gamesMap, setGamesMap] = React.useState<GamesMap>({});
  const [q, setQ] = React.useState(''); // 搜尋關鍵字

  const [sheetOpen, setSheetOpen] = React.useState(false);
  const [editingMatchId, setEditingMatchId] = React.useState<string | null>(null);
  const [editInitial, setEditInitial] = React.useState({ bestOf: 3, pointsToWin: 21, deuce: true, cap: 30 as number | null });

  const setCurrentMatch = useRecordsStore(s => s.setCurrentMatch);

  const load = React.useCallback(async () => {
    try {
      const rows = await listMatches(eventId);
      setItems(rows as any);
    } catch (e: any) {
      Alert.alert('載入失敗', String(e?.message || e));
    }
  }, [eventId]);

  React.useEffect(() => { load(); }, [load]);
  useFocusEffect(React.useCallback(() => { load(); }, [load]));

  // 讀球員
  React.useEffect(() => {
    let cancelled = false;
    (async () => {
      const map: PlayerMap = {};
      for (const m of items) {
        try {
          const rows = await getMatchPlayers(m.id);
          const home: [string|null, string|null] = [null, null];
          const away: [string|null, string|null] = [null, null];
          (rows || []).forEach((r: any) => {
            if (r.side === 'home') home[r.idx] = r.name ?? null;
            else if (r.side === 'away') away[r.idx] = r.name ?? null;
          });
          map[m.id] = { home, away };
        } catch {}
      }
      if (!cancelled) setPlayersMap(map);
    })();
    return () => { cancelled = true; };
  }, [items]);

  // 讀各局分數（games）
  React.useEffect(() => {
    let cancelled = false;
    (async () => {
      const gmap: GamesMap = {};
      for (const m of items) {
        try {
          let rows: any[] = [];
          if (BACKEND === 'supabase') {
            const { data, error } = await supa
              .from('games')
              .select('index_no,home_score,away_score,winner_team')
              .eq('match_id', m.id)
              .order('index_no', { ascending: true });
            if (error) throw error;
            rows = data || [];
          } else {
            const db = await openDB();
            const [res] = await db.executeSql(
              'SELECT index_no,home_score,away_score,winner_team FROM games WHERE match_id=? ORDER BY index_no ASC',
              [m.id]
            );
            rows = Array.from({ length: res.rows.length }, (_, i) => res.rows.item(i));
          }
          gmap[m.id] = rows.map(r => ({
            i: Number(r.index_no || 0),
            home: Number(r.home_score || 0),
            away: Number(r.away_score || 0),
            winner: (r.winner_team == null ? null : Number(r.winner_team)) as 0|1|null,
          }));
        } catch {
          gmap[m.id] = [];
        }
      }
      if (!cancelled) setGamesMap(gmap);
    })();
    return () => { cancelled = true; };
  }, [items]);

  const add = async () => {
    const t = type.trim().toUpperCase() as MatchRow['type'];
    if (!t) return;
    try {
      if (BACKEND === 'supabase') {
        await (require('../db') as any).createMatchRPC({
          event_id: eventId,
          type: t,
          court_no: court.trim() || undefined,
          rules: { bestOf: 3, pointsToWin: 21, deuce: true, cap: 30 },
        });
      } else {
        const id = Math.random().toString(36).slice(2);
        await insertMatch({
          id,
          event_id: eventId,
          type: t,
          court_no: court.trim() || undefined,
          rules_json: JSON.stringify({ bestOf: 3, pointsToWin: 21, deuce: true, cap: 30 }),
        } as any);
      }
      await load();
      setCourt('');
    } catch (e: any) {
      Alert.alert('新增失敗', String(e?.message || e));
    }
  };

  const openTypePicker = () => {
    if (Platform.OS === 'ios') {
      const options = ['取消', ...TYPE_OPTIONS.map(o => o.label)];
      ActionSheetIOS.showActionSheetWithOptions(
        { options, cancelButtonIndex: 0 },
        (idx) => {
          if (idx && idx > 0) setType(TYPE_OPTIONS[idx - 1].value);
        }
      );
    } else {
      Alert.alert(
        '選擇類型',
        '',
        [
          ...TYPE_OPTIONS.map(o => ({ text: o.label, onPress: () => setType(o.value) })),
          { text: '取消', style: 'cancel' },
        ],
        { cancelable: true }
      );
    }
  };

  const choose = (id: string) => {
    setCurrentMatch(id);
    navigation.navigate('Record');
  };

  function parseRules(json: string | null) {
    if (!json) return { bestOf: 3, pointsToWin: 21, deuce: true, cap: 30 as number | null };
    try {
      const r = JSON.parse(json);
      return {
        bestOf: r.bestOf ?? 3,
        pointsToWin: r.pointsToWin ?? r.pointsPerGame ?? 21,
        deuce: r.deuce ?? (r.winBy ? r.winBy > 1 : true),
        cap: r.cap ?? 30,
      };
    } catch {
      return { bestOf: 3, pointsToWin: 21, deuce: true, cap: 30 as number | null };
    }
  }

  const editRules = (item: MatchRow) => {
    const r = parseRules(item.rules_json);
    setEditInitial(r);
    setEditingMatchId(item.id);
    setSheetOpen(true);
  };

  const saveRules = async (rules: { bestOf: number; pointsToWin: number; deuce: boolean; cap?: number | null }) => {
    if (!editingMatchId) return;
    try {
      await updateMatchRules(editingMatchId, JSON.stringify(rules));
      setSheetOpen(false);
      setEditingMatchId(null);
      load();
    } catch (e: any) {
      Alert.alert('儲存失敗', String(e?.message || e));
    }
  };

  const setMode = async (id: string, mode: 'tap' | 'route') => {
    try {
      await setMatchRecordMode(id, mode);
      load();
    } catch (e: any) {
      Alert.alert('切換失敗', String(e?.message || e));
    }
  };

  const playerSummary = (m: MatchRow) => {
    const p = playersMap[m.id];
    if (!p) return null;
    const isDouble = m.type.endsWith('D');
    const left = isDouble ? ` ${p.home[0] ?? '—'} ${p.home[1] ?? '—'}`  : ` ${p.home[0] ?? '—'}` ;
    const right = isDouble ? ` ${p.away[0] ?? '—'} ${p.away[1] ?? '—'}`  : ` ${p.away[0] ?? '—'}` ;
    const hasAny = [p.home[0], p.home[1], p.away[0], p.away[1]].some(v => v && String(v).trim().length > 0);
    return hasAny ? ` ${left}  VS  ${right}`  : null;
  };

  // 搜尋
  const norm = (s: any) => String(s ?? '').toLowerCase().trim();
  const filtered = React.useMemo(() => {
    const kw = norm(q);
    if (!kw) return items;
    const tokens = kw.split(/\s+/).filter(Boolean);
    return items.filter(m => {
      const p = playersMap[m.id] || { home:[null,null], away:[null,null] };
      const hay = [
        m.type,
        m.court_no ?? '',
        p.home[0] ?? '', p.home[1] ?? '',
        p.away[0] ?? '', p.away[1] ?? ''
      ].map(norm).join(' ');
      return tokens.every(t => hay.includes(t));
    });
  }, [items, q, playersMap]);

  const onDeleteMatch = async (m: MatchRow) => {
    try {
      const has = await hasMatchRallies(m.id);
      if (has) {
        Alert.alert('刪除場次', '此場次已有記錄資料，確定要刪除？', [
          { text: '取消', style: 'cancel' },
          { text: '刪除', style: 'destructive', onPress: async () => {
              try { await deleteMatch(m.id); await load(); }
              catch(e:any){ Alert.alert('刪除失敗', String(e?.message || e)); }
            } },
        ]);
      } else {
        await deleteMatch(m.id);
        await load();
      }
    } catch (e:any) {
      Alert.alert('刪除失敗', String(e?.message || e));
    }
  };

  const renderGames = (m: MatchRow) => {
    const arr = gamesMap[m.id] || [];
    if (arr.length === 0) return null;
    return (
      <View style={{ marginTop: 6, flexDirection:'row', flexWrap:'wrap' }}>
        {arr.map(g => {
          const tag = `G${g.i} ${g.home}-${g.away}`;
          const winClr = g.winner === 0 ? '#1976d2' : g.winner === 1 ? '#d32f2f' : '#999';
          return (
            <View key={m.id + '-g' + g.i} style={{ paddingVertical:4, paddingHorizontal:8, borderRadius:12, borderWidth:1, borderColor:'#ccc', marginRight:6, marginBottom:6, backgroundColor:'#f7f7f7' }}>
              <Text style={{ color:'#333' }}>
                {tag}{g.winner!=null ? (g.winner===0 ? '（主）' : '（客）') : ''}
              </Text>
              <View style={{ position:'absolute', right:-2, top:-2, width:8, height:8, borderRadius:4, backgroundColor: winClr }} />
            </View>
          );
        })}
      </View>
    );
  };

  const renderItem = ({ item }: { item: MatchRow }) => {
    const summary = playerSummary(item);
    return (
      <View style={{ padding: 12, borderWidth: 1, borderColor: '#eee', borderRadius: 8, marginBottom: 8 }}>
        <Text style={{ fontSize: 16, fontWeight: '700' }}>
          {item.type} 場地 {item.court_no || '-'}
        </Text>
        {summary && <Text style={{ marginTop: 6, marginBottom: 2, color: '#333' }}>{summary}</Text>}

        {/* 各局分數 + 勝方 */}
        {renderGames(item)}

        <View style={{ flexDirection: 'row', marginTop: 8, flexWrap: 'wrap', alignItems: 'center' }}>
          <Pressable onPress={() => choose(item.id)} style={{ padding: 10, backgroundColor: '#2e7d32', borderRadius: 8, marginRight: 6, marginBottom: 6 }}>
            <Text style={{ color: '#fff' }}>選取為記錄中</Text>
          </Pressable>
          <Pressable onPress={() => editRules(item)} style={{ padding: 10, backgroundColor: '#616161', borderRadius: 8, marginRight: 6, marginBottom: 6 }}>
            <Text style={{ color: '#fff' }}>規則</Text>
          </Pressable>
          <Pressable onPress={() => navigation.navigate('PlayerSetup', { matchId: item.id })} style={{ padding: 10, backgroundColor: '#00897b', borderRadius: 8, marginRight: 6, marginBottom: 6 }}>
            <Text style={{ color: '#fff' }}>球員設定</Text>
          </Pressable>
          <Pressable onPress={() => navigation.navigate('Live', { matchId: item.id })} style={{ padding: 10, backgroundColor: '#5d4037', borderRadius: 8, marginRight: 6, marginBottom: 6 }}>
            <Text style={{ color: '#fff' }}>即時</Text>
          </Pressable>
          <Pressable onPress={() => navigation.navigate('Chat', { matchId: item.id })} style={{ padding: 10, backgroundColor: '#7b1fa2', borderRadius: 8, marginRight: 6, marginBottom: 6 }}>
            <Text style={{ color: '#fff' }}>聊天</Text>
          </Pressable>
          <Pressable onPress={() => navigation.navigate('Media', { matchId: item.id })} style={{ padding: 10, backgroundColor: '#f57c00', borderRadius: 8, marginRight: 6, marginBottom: 6 }}>
            <Text style={{ color: '#fff' }}>媒體</Text>
          </Pressable>
          <Pressable onPress={() => navigation.navigate('MatchMembers', { matchId: item.id })} style={{ padding: 10, backgroundColor: '#3949ab', borderRadius: 8, marginRight: 6, marginBottom: 6 }}>
            <Text style={{ color: '#fff' }}>成員</Text>
          </Pressable>
          <Pressable onPress={() => navigation.navigate('SpeedCam', { matchId: item.id })} style={{ padding: 10, backgroundColor: '#00695c', borderRadius: 8, marginRight: 6, marginBottom: 6 }}>
            <Text style={{ color: '#fff' }}>測速</Text>
          </Pressable>
          <Pressable onPress={() => onDeleteMatch(item)} style={{ padding: 10, backgroundColor: '#d32f2f', borderRadius: 8, marginRight: 6, marginBottom: 6 }}>
            <Text style={{ color: '#fff' }}>刪除</Text>
          </Pressable>
        </View>

        <View style={{ flexDirection: 'row', marginTop: 6 }}>
          <Pressable
            onPress={() => setMode(item.id, 'tap')}
            style={{ paddingVertical: 8, paddingHorizontal: 10, borderWidth: 1, borderColor: item.record_mode === 'tap' ? '#1976d2' : '#ccc', borderRadius: 8, marginRight: 6 }}
          >
            <Text style={{ color: item.record_mode === 'tap' ? '#1976d2' : '#444' }}>點擊模式</Text>
          </Pressable>
          <Pressable
            onPress={() => setMode(item.id, 'route')}
            style={{ paddingVertical: 8, paddingHorizontal: 10, borderWidth: 1, borderColor: item.record_mode === 'route' ? '#1976d2' : '#ccc', borderRadius: 8 }}
          >
            <Text style={{ color: item.record_mode === 'route' ? '#1976d2' : '#444' }}>線路模式</Text>
          </Pressable>
        </View>
      </View>
    );
  };

  return (
    <View style={{ flex: 1, padding: 12 }}>
      {/* 搜尋列 + 新增 */}
      <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 12 }}>
        <TextInput
          value={q}
          onChangeText={setQ}
          placeholder="搜尋類型/場地/球員（可多關鍵字）"
          placeholderTextColor="#888" 
          style={{ flex: 1, height: 40, borderWidth: 1, borderColor: '#ccc', borderRadius: 8, paddingHorizontal: 10, marginRight: 8 }}
          returnKeyType="search"
        />
        <Pressable
          onPress={openTypePicker}
          style={{ paddingVertical: 8, paddingHorizontal: 12, borderWidth: 1, borderColor: '#ccc', borderRadius: 8, marginRight: 8 }}
        >
          <Text>類型：{type}</Text>
        </Pressable>
        <TextInput
          value={court}
          onChangeText={setCourt}
          placeholderTextColor="#888" 
          placeholder="場地號 時間(可空)"
          style={{ width: 110, height: 40, borderWidth: 1, borderColor: '#ccc', borderRadius: 8, paddingHorizontal: 10, marginRight: 8 }}
          returnKeyType="done"
        />
        <Pressable onPress={add} style={{ backgroundColor: '#1976d2', paddingHorizontal: 14, height: 40, borderRadius: 8, justifyContent: 'center' }}>
          <Text style={{ color: '#fff' }}>新增</Text>
        </Pressable>
      </View>

      <FlatList data={filtered} keyExtractor={(i) => i.id} renderItem={renderItem} />

      <MatchRulesSheet
        visible={sheetOpen}
        initial={editInitial}
        onClose={() => { setSheetOpen(false); setEditingMatchId(null); }}
        onSave={saveRules}
      />
    </View>
  );
}ezbmt-tracked/src/screens/AuthScreen.tsx
 
 import React from 'react'; 
 import { View, Text, TextInput, Pressable, Alert, Image, SafeAreaView, KeyboardAvoidingView, Platform, ScrollView, ActivityIndicator, StatusBar, } from 'react-native'; 
 import { supa, getCurrentUser } from '../lib/supabase';
const ACTION_IMG = require('../images/action.png'); // 確認路徑

export default function AuthScreen({ navigation }: any) {
const [email, setEmail] = React.useState('');
const [password, setPassword] = React.useState('');
const [busy, setBusy] = React.useState(false);
const [mode, setMode] = React.useState<'signin' | 'signup'>('signin');

React.useEffect(() => {
(async () => {
const u = await getCurrentUser();
if (u) navigation.replace('Events');
})();
}, [navigation]);

const submit = async () => {
const addr = (email ?? '').trim();
const pwd = password;
if (!addr || !pwd) return;
setBusy(true);
try {
// 和 Supabase 後台 Additional Redirect URLs 對應的 Deep Link
const redirectTo = Platform.select({
ios: 'ezbmt://auth-callback',
android: 'ezbmt://auth-callback',
default: 'ezbmt://auth-callback',
}) as string;

  if (mode === 'signin') {
    const { error } = await supa.auth.signInWithPassword({ email: addr, password: pwd });
    if (error) throw error;
  } else {
    const { error } = await supa.auth.signUp({
      email: addr,
      password: pwd,
      options: { emailRedirectTo: redirectTo },
    });
    if (error) throw error;
    Alert.alert('已送出確認信', '請到信箱點擊驗證連結完成註冊');
  }
  navigation.replace('Events');
} catch (e: any) {
  Alert.alert('失敗', String(e?.message || e));
} finally {
  setBusy(false);
}
};

return (
<SafeAreaView style={{ flex: 1, backgroundColor: '#f2f5f6' }}>
<StatusBar barStyle={Platform.OS === 'ios' ? 'dark-content' : 'default'} />
<KeyboardAvoidingView
style={{ flex: 1 }}
behavior={Platform.OS === 'ios' ? 'padding' : undefined}
keyboardVerticalOffset={Platform.OS === 'ios' ? 16 : 0}
>
<ScrollView
contentContainerStyle={{ flexGrow: 1, padding: 16, justifyContent: 'center' }}
keyboardShouldPersistTaps="handled"
>
<View
style={{
backgroundColor: '#fff',
borderRadius: 18,
paddingTop: 20,
paddingBottom: 24,
paddingHorizontal: 16,
shadowColor: '#000',
shadowOpacity: 0.08,
shadowOffset: { width: 0, height: 4 },
shadowRadius: 12,
elevation: 2,
}}
>
<Text
style={{
fontSize: 20,
fontWeight: '800',
color: '#1B5E20',
textAlign: 'center',
marginBottom: 10,
}}
>
LBF能力有限 羽球分析平台
</Text>

        <Image
          source={ACTION_IMG}
          resizeMode="contain"
          style={{ width: '100%', height: 90, marginBottom: 14 }}
        />

        <View style={{ height: 1, backgroundColor: '#E9ECEF', marginBottom: 16 }} />

        <Text style={{ marginBottom: 6, color: '#333', fontSize: 16 }}>帳號：</Text>
        <TextInput
          placeholder="Email"
          autoCapitalize="none"
          keyboardType="email-address"
          value={email}
          onChangeText={setEmail}
          returnKeyType="next"
          style={{
            backgroundColor: '#f6f7f8',
            borderWidth: 1,
            borderColor: '#E0E0E0',
            borderRadius: 14,
            paddingHorizontal: 14,
            paddingVertical: 12,
            marginBottom: 16,
          }}
        />

        <Text style={{ marginBottom: 6, color: '#333', fontSize: 16 }}>密碼：</Text>
        <TextInput
          placeholder="請輸入密碼"
          secureTextEntry
          value={password}
          onChangeText={setPassword}
          returnKeyType="done"
          onSubmitEditing={!busy ? submit : undefined}
          style={{
            backgroundColor: '#f6f7f8',
            borderWidth: 1,
            borderColor: '#E0E0E0',
            borderRadius: 14,
            paddingHorizontal: 14,
            paddingVertical: 12,
            marginBottom: 24,
          }}
        />

        <Pressable
          disabled={busy}
          onPress={submit}
          style={{
            alignSelf: 'center',
            width: '86%',
            backgroundColor: '#0E8F64',
            borderRadius: 22,
            paddingVertical: 14,
            alignItems: 'center',
            opacity: busy ? 0.7 : 1,
          }}
        >
          {busy ? (
            <ActivityIndicator color="#fff" />
          ) : (
            <Text style={{ color: '#fff', fontWeight: '800', letterSpacing: 1 }}>
              {mode === 'signin' ? '登入' : '註冊'}
            </Text>
          )}
        </Pressable>

        <Pressable
          onPress={() => setMode((m) => (m === 'signin' ? 'signup' : 'signin'))}
          style={{ marginTop: 14, alignSelf: 'center' }}
        >
          <Text style={{ color: '#1976d2' }}>
            {mode === 'signin' ? '沒有帳號？前往註冊' : '已有帳號？前往登入'}
          </Text>
        </Pressable>
      </View>
    </ScrollView>
  </KeyboardAvoidingView>
</SafeAreaView>
);
}ezbmt-tracked/src/screens/EventsScreen.tsx
 
import React from 'react';
import {
View,
Text,
FlatList,
TextInput,
Pressable,
Alert,
KeyboardAvoidingView,
Platform,
} from 'react-native';
import { useNavigation, useFocusEffect } from '@react-navigation/native';
import { BACKEND } from '../lib/backend';
import {
listEvents,
insertEvent,
listMyEvents,
createEventRPC,
hasEventMatches,
deleteEvent,
} from '../db';
import { getCurrentUser, supa } from '../lib/supabase';
import { useHeaderHeight } from '@react-navigation/elements';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

export default function EventsScreen() {
const nav = useNavigation<any>();
const [items, setItems] = React.useState<Array<{ id: string; name: string }>>([]);
const [name, setName] = React.useState('');
const [myName, setMyName] = React.useState<string>('');
const [q, setQ] = React.useState(''); // 搜尋關鍵字

// eventId => 是否有場次（true=有，因此不顯示刪除鈕）
const [hasMap, setHasMap] = React.useState<Record<string, boolean>>({});

const headerHeight = useHeaderHeight();
const insets = useSafeAreaInsets();
const INPUT_BAR_H = 44;

const load = React.useCallback(async () => {
try {
if (BACKEND === 'supabase') {
const rows = await listMyEvents();
setItems(rows);
} else {
setItems(await listEvents());
}
} catch (e: any) {
Alert.alert('載入失敗', String(e?.message || e));
}
}, []);

useFocusEffect(
React.useCallback(() => {
let active = true;
(async () => {
if (BACKEND === 'supabase') {
const u = await getCurrentUser();
if (!u && active) {
// @ts-ignore
nav.navigate('Auth');
return;
}
try {
if (u && active) {
const { data } = await supa.from('profiles').select('name').eq('id', u.id).single();
if (active) setMyName((data?.name || '').trim());
}
} catch {
if (active) setMyName('');
}
}
if (active) load();
})();
return () => {
active = false;
};
}, [load, nav]),
);

// 依 items 批次查是否有場次（有場次者隱藏刪除鈕）
React.useEffect(() => {
let cancelled = false;
(async () => {
if (!items.length) {
if (!cancelled) setHasMap({});
return;
}
const entries: Array<[string, boolean]> = [];
for (const it of items) {
try {
const has = await hasEventMatches(it.id);
entries.push([it.id, !!has]);
} catch {
// 若 RLS/網路錯誤，保守起見視為「有場次」，隱藏刪除鈕
entries.push([it.id, true]);
}
}
if (!cancelled) setHasMap(Object.fromEntries(entries));
})();
return () => {
cancelled = true;
};
}, [items]);

const add = async () => {
const nm = name.trim();
if (!nm) return;
try {
if (BACKEND === 'supabase') {
await createEventRPC({ name: nm });
} else {
const id = Math.random().toString(36).slice(2);
await insertEvent({ id, name: nm } as any);
}
setName('');
load();
} catch (e: any) {
Alert.alert('新增失敗', String(e?.message || e));
}
};

const onDeleteEvent = async (eventId: string) => {
try {
// 再保險一次（就算 hasMap 有值，也以實際狀態為準）
const has = await hasEventMatches(eventId);
if (has) {
Alert.alert('無法刪除', '此賽事已有場次資料，不可刪除');
return;
}
Alert.alert('刪除賽事', '確定要刪除此賽事？', [
{ text: '取消', style: 'cancel' },
{
text: '刪除',
style: 'destructive',
onPress: async () => {
try {
await deleteEvent(eventId);
await load();
} catch (e: any) {
Alert.alert('刪除失敗', String(e?.message || e));
}
},
},
]);
} catch (e: any) {
Alert.alert('刪除失敗', String(e?.message || e));
}
};

// 標準化 + 多關鍵字搜尋
const norm = (s: any) => String(s ?? '').toLowerCase().trim();
const filtered = React.useMemo(() => {
const kw = norm(q);
if (!kw) return items;
const tokens = kw.split(/\s+/).filter(Boolean);
return items.filter((it) => {
const hay = norm(it.name);
return tokens.every((t) => hay.includes(t));
});
}, [items, q]);

const renderItem = ({ item }: { item: { id: string; name: string } }) => {
const has = !!hasMap[item.id]; // true=有場次，不顯示刪除
return (
<View
style={{
padding: 12,
borderWidth: 1,
borderColor: '#eee',
borderRadius: 8,
marginBottom: 8,
}}
>
<Pressable onPress={() => nav.navigate('Matches', { eventId: item.id })}>
<Text style={{ fontSize: 16 }}>{item.name}</Text>
<Text style={{ color: '#666', marginTop: 4 }}>點擊進入場次管理</Text>
</Pressable>
<View style={{ flexDirection: 'row', marginTop: 8 }}>
<Pressable
onPress={() => nav.navigate('EventMembers', { eventId: item.id })}
style={{
paddingVertical: 6,
paddingHorizontal: 10,
backgroundColor: '#7b1fa2',
borderRadius: 8,
marginRight: 8,
}}
>
<Text style={{ color: '#fff' }}>成員</Text>
</Pressable>

      {/* 沒有場次時才顯示刪除 */}
      {!has && (
        <Pressable
          onPress={() => onDeleteEvent(item.id)}
          style={{
            paddingVertical: 6,
            paddingHorizontal: 10,
            backgroundColor: '#d32f2f',
            borderRadius: 8,
          }}
        >
          <Text style={{ color: '#fff' }}>刪除</Text>
        </Pressable>
      )}
    </View>
  </View>
);
};

return (
<KeyboardAvoidingView
style={{ flex: 1 }}
behavior={Platform.OS === 'ios' ? 'padding' : undefined}
keyboardVerticalOffset={headerHeight}
>
<View
style={{
flex: 1,
padding: 12,
paddingBottom: (insets.bottom || 12) + INPUT_BAR_H + 12,
}}
>
{/* 搜尋 + 個人/設定 */}
<View
style={{
flexDirection: 'row',
justifyContent: 'space-between',
alignItems: 'center',
marginBottom: 8,
}}
>
<View style={{ flex: 1, marginRight: 8 }}>
<TextInput
value={q}
onChangeText={setQ}
placeholderTextColor="#888" 
placeholder="搜尋賽事名稱（可輸入多關鍵字）"
style={{
height: 36,
borderWidth: 1,
borderColor: '#ccc',
borderRadius: 8,
paddingHorizontal: 10,
backgroundColor: '#fff',
}}
returnKeyType="search"
/>
</View>
<Pressable
onPress={() => nav.navigate('Profile')}
style={{
paddingVertical: 6,
paddingHorizontal: 10,
backgroundColor: '#607d8b',
borderRadius: 8,
marginRight: 6,
}}
>
<Text style={{ color: '#fff' }}>
{myName ? `個人：${myName}` : '個人'}
</Text>
</Pressable>
<Pressable
onPress={() => nav.navigate('Settings')}
style={{
paddingVertical: 6,
paddingHorizontal: 10,
backgroundColor: '#455a64',
borderRadius: 8,
}}
>
<Text style={{ color: '#fff' }}>設定</Text>
</Pressable>
</View>

    <Text style={{ fontSize: 16, fontWeight: '600', marginBottom: 8 }}>
      賽事清單
    </Text>
    <FlatList data={filtered} keyExtractor={(i) => i.id} renderItem={renderItem} />
  </View>

  {/* 底部新增賽事 */}
  <View
    style={{
      position: 'absolute',
      left: 12,
      right: 12,
      bottom: (insets.bottom || 0) + 12,
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
      height: INPUT_BAR_H,
    }}
  >
    <TextInput
      value={name}
      onChangeText={setName}
      placeholder="新增賽事名稱"
      placeholderTextColor="#888"
      style={{
        flex: 1,
        height: INPUT_BAR_H,
        borderWidth: 1,
        borderColor: '#ccc',
        borderRadius: 8,
        paddingHorizontal: 10,
        backgroundColor: '#fff',
      }}
      returnKeyType="done"
    />
    <Pressable
      onPress={add}
      style={{
        backgroundColor: '#1976d2',
        paddingHorizontal: 16,
        height: INPUT_BAR_H,
        borderRadius: 8,
        justifyContent: 'center',
      }}
    >
      <Text style={{ color: '#fff' }}>新增</Text>
    </Pressable>
  </View>
</KeyboardAvoidingView>
);
}ezbmt-tracked/src/screens/ReplayScreen.tsx
 
import React from 'react';
import { View, Text, Alert, Pressable } from 'react-native';
import { useRoute } from '@react-navigation/native';
import { getRalliesByIds } from '../db';
import RoutePlayer from '../components/RoutePlayer';

type RouteParam = { matchId: string; ids: string[] };

export default function ReplayScreen() {
const route = useRoute<any>();
const { matchId, ids } = (route.params || {}) as RouteParam;

const [routes, setRoutes] = React.useState<Array<{ sx:number; sy:number; ex:number; ey:number; kind:'win'|'loss'; meta?: any }>>([]);
const [filter, setFilter] = React.useState<'all'|'win'|'loss'|'random'>('all');
const [nowIndex, setNowIndex] = React.useState(0);

React.useEffect(() => {
(async () => {
try {
if (!ids || !ids.length) return;
const rows = await getRalliesByIds(ids);
const items = rows
.map((r: any) => {
const sx = r.route_start_rx != null ? Number(r.route_start_rx) : null;
const sy = r.route_start_ry != null ? Number(r.route_start_ry) : null;
const ex = r.route_end_rx != null ? Number(r.route_end_rx) : null;
const ey = r.route_end_ry != null ? Number(r.route_end_ry) : null;
if (sx == null || sy == null || ex == null || ey == null) return null;
const kind = r.winner_side === 'home' ? 'win' : 'loss';
const meta = safeMeta(r.meta_json);
return { sx, sy, ex, ey, kind, meta };
})
.filter(Boolean) as Array<{ sx:number; sy:number; ex:number; ey:number; kind:'win'|'loss'; meta?: any }>;
setRoutes(items);
} catch (e: any) {
Alert.alert('載入失敗', String(e?.message || e));
}
})();
}, [matchId, ids]);

const curMeta = routes[nowIndex]?.meta;

return (
<View style={{ flex: 1, padding: 12 }}>
<Text style={{ fontSize: 16, fontWeight: '600', marginBottom: 8 }}>路徑回放</Text>

  <View style={{ flexDirection:'row', marginBottom: 8, flexWrap: 'wrap' }}>
    {(['all','win','loss','random'] as const).map(f=>(
      <Pressable
        key={f}
        onPress={()=>setFilter(f)}
        style={{
          paddingVertical:6, paddingHorizontal:10, borderRadius:14,
          borderWidth:1, borderColor: filter===f?'#1976d2':'#ccc',
          backgroundColor: filter===f?'rgba(25,118,210,0.1)':'#fff',
          marginRight:8, marginBottom:8
        }}
      >
        <Text>{f==='all'?'全部':f==='win'?'只播得分':f==='loss'?'只播失分':'隨機'}</Text>
      </Pressable>
    ))}
  </View>

  {/* 讓播放器吃掉剩餘空間，內部會等比縮放到不超出容器 */}
  <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
    <FitPlayer routes={routes} filter={filter} onIndexChange={setNowIndex} />
  </View>

  {curMeta ? (
    <View style={{ marginTop: 10, flexDirection:'row', flexWrap:'wrap' }}>
      {curMeta.shotType && <Badge text={curMeta.shotType} />}
      {curMeta.forceType && <Badge text={curMeta.forceType} />}
      {curMeta.errorReason && <Badge text={curMeta.errorReason} />}
    </View>
  ) : null}
  {routes.length === 0 && <Text style={{ marginTop: 8, color: '#666' }}>目前沒有可播放的路徑</Text>}
</View>
);
}

/**

在可用空間內「等比縮放」RoutePlayer（6.1:13.4，直式）
取得容器寬高，算出不超出容器的寬高，置中顯示 */ function FitPlayer({ routes, filter, onIndexChange, }: { routes: any[]; filter: 'all'|'win'|'loss'|'random'; onIndexChange: (i:number)=>void }) { const [box, setBox] = React.useState({ w: 0, h: 0 });
const onLayout = (e: any) => {
const { width, height } = e.nativeEvent.layout;
if (width && height) setBox({ w: Math.floor(width), h: Math.floor(height) });
};

// 直式球場比例（width/height）
const ar = 6.1 / 13.4;

// 依容器等比縮放（取不超出容器的最大尺寸）
let w = 0, h = 0;
if (box.w > 0 && box.h > 0) {
const wByH = box.h * ar;            // 用高度推算的最大寬
if (wByH <= box.w) {
// 以高度為限制
w = Math.floor(wByH);
h = Math.floor(box.h);
} else {
// 以寬度為限制
w = Math.floor(box.w);
h = Math.floor(box.w / ar);
}
}

return (
<View style={{ width: '100%', height: '100%' }} onLayout={onLayout}>
{w > 0 && h > 0 ? (
<View style={{ width: w, height: h, alignSelf: 'center' }}>
<RoutePlayer
         width={w}
         height={h}
         routes={routes}
         autoPlay
         initialSpeed={1}
         filter={filter}
         onIndexChange={onIndexChange}
       />
</View>
) : null}
</View>
);
}

function Badge({ text }: { text: string }) {
return (
<View style={{ paddingVertical:4, paddingHorizontal:8, borderRadius:12, backgroundColor:'#eee', marginRight:6, marginBottom:6 }}>
<Text>{text}</Text>
</View>
);
}
function safeMeta(json: string) { try { return JSON.parse(json || '{}'); } catch(_){ return {}; } }ezbmt-tracked/src/screens/LiveScreen.tsx
 
import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import { useRoute } from '@react-navigation/native';
import Svg, { Line, Path, Text as SvgText, G } from 'react-native-svg';
import { getMatch, getMatchPlayers, listRalliesOrdered } from '../db';
import { deserialize, getUiSnapshot } from '../logic/serve';
import { subscribeLive, LiveSnapshot } from '../lib/supabase';

type SeriesByGame = Array<{ game: number; rows: Array<{ win: boolean }> }>;

function TrendChart({ title, rows }: { title: string; rows: Array<{ win: boolean }> }) {
const [w, setW] = React.useState(0);
const H = 160;
const PAD = 28;

const series = React.useMemo(() => {
const home: number[] = [0];
const away: number[] = [0];
let h = 0, a = 0;
for (let i = 0; i < rows.length; i++) {
if (rows[i].win) h++; else a++;
home.push(h); away.push(a);
}
const maxY = Math.max(1, h, a);
return { home, away, maxY };
}, [rows]);

const ticks = React.useMemo(() => {
const arr: number[] = [];
for (let v = 0; v <= series.maxY; v += 5) arr.push(v);
if (arr[arr.length - 1] !== series.maxY) arr.push(series.maxY);
return arr;
}, [series.maxY]);

const yOf = (v: number) => {
const plotH = Math.max(1, H - PAD * 2);
return PAD + (plotH * (1 - v / series.maxY));
};

const buildPath = (vals: number[], W: number, H: number, maxY: number) => {
const plotW = Math.max(1, W - PAD * 2);
const plotH = Math.max(1, H - PAD * 2);
const n = vals.length; if (n <= 1) return '';
const stepX = plotW / (n - 1);
const yOf2 = (v: number) => PAD + (plotH * (1 - v / maxY));
let d = `M ${PAD} ${yOf2(vals[0])}`;
for (let i = 1; i < n; i++) {
const x = PAD + i * stepX;
const y = yOf2(vals[i]);
d +=  `L ${x} ${y}`;
}
return d;
};

return (
<View
onLayout={e => setW(Math.floor(e.nativeEvent.layout.width))}
style={{ marginTop: 10, padding: 10, borderWidth: 1, borderColor: '#333', borderRadius: 10, backgroundColor: '#222' }}
>
<Text style={{ color: '#fff', fontWeight: '600', marginBottom: 8 }}>{title}</Text>
{w <= 0 ? null : (
<Svg width={w} height={H}>
{/* 軸線 */}
<G>
<Line x1={PAD} y1={PAD} x2={PAD} y2={H - PAD} stroke="#444" strokeWidth={1} />
<Line x1={PAD} y1={H - PAD} x2={w - PAD} y2={H - PAD} stroke="#444" strokeWidth={1} />
</G>
{/* 每 5 分 + 最後分數，滿版水平線 + 數字 */}
<G>
{ticks.map(v => {
const y = yOf(v);
return (
<G key={'yt-'+v}>
<Line x1={PAD} y1={y} x2={w - PAD} y2={y} stroke="#3a3a3a" strokeWidth={1} opacity={v===0?0.55:0.28}/>
<SvgText x={PAD - 6} y={y + 4} fill="#888" fontSize={10} textAnchor="end">{v}</SvgText>
</G>
);
})}
</G>
{/* 折線 */}
<Path d={buildPath(series.home, w, H, series.maxY)} stroke="#1976d2" strokeWidth={2} fill="none" />
<Path d={buildPath(series.away, w, H, series.maxY)} stroke="#d32f2f" strokeWidth={2} fill="none" />
</Svg>
)}
</View>
);
}

export default function LiveScreen() {
const route = useRoute<any>();
const matchId = route.params?.matchId as string | undefined;

const [ui, setUi] = React.useState<LiveSnapshot | null>(null);
const [meta, setMeta] = React.useState<{ type?: string; court?: string | null; singles?: boolean }>({});
const [players, setPlayers] = React.useState<{ home: [string|null, string|null]; away: [string|null, string|null] }>({ home: [null, null], away: [null, null] });
const [series, setSeries] = React.useState<SeriesByGame>([]);

React.useEffect(() => {
if (!matchId) return;

let unsub: any = null;
// Realtime
try {
  const sub = subscribeLive(matchId, (snap: LiveSnapshot) => setUi(snap));
  unsub = sub;
} catch (_e) {}

// Poll fallback
let active = true;
const fetchState = async () => {
  try {
    if (ui) return;
    const m = await getMatch(matchId);
    if (!active) return;
    if (m && m.state_json) {
      const s = deserialize(m.state_json);
      setUi(getUiSnapshot(s) as unknown as LiveSnapshot);
    }
  } catch {}
};
fetchState();
const t = setInterval(fetchState, 1500);

// 基本資料（類型/場地/球員）
(async () => {
  try {
    const m = await getMatch(matchId);
    const type = String(m?.type || '');
    const singles = type.endsWith('S');
    setMeta({ type, court: (m?.court_no ?? null), singles });

    const rows = await getMatchPlayers(matchId);
    const home:[string|null,string|null] = [null,null];
    const away:[string|null,string|null] = [null,null];
    (rows||[]).forEach((r:any)=> {
      const nm = r?.name || null;
      if (r.side==='home') home[r.idx] = nm;
      else if (r.side==='away') away[r.idx] = nm;
    });
    setPlayers({ home, away });
  } catch {}
})();

// 折線圖資料（每 3 秒）－降冪排序，最近在上
const refreshSeries = async () => {
  try {
    const rows = await listRalliesOrdered(matchId);
    const byGame = new Map<number, Array<{win:boolean}>>();
    (rows||[]).forEach((r:any)=>{
      const g = Number(r.game_index||0);
      const win = r.winner_side === 'home';
      const arr = byGame.get(g) || [];
      arr.push({ win });
      byGame.set(g, arr);
    });
    const arr:SeriesByGame = Array.from(byGame.entries())
      .sort((a,b)=> b[0]-a[0]) // 降冪：最近一局在最上方
      .map(([g, rows])=>({ game: g, rows }));
    setSeries(arr);
  } catch {}
};
refreshSeries();
const ts = setInterval(refreshSeries, 3000);

return () => {
  active = false;
  clearInterval(t);
  clearInterval(ts);
  if (unsub && unsub.unsubscribe) unsub.unsubscribe();
};
}, [matchId]);

if (!matchId) {
return (
<View style={{ flex: 1, alignItems: 'center', justifyContent: 'center', padding: 16, backgroundColor:'#111' }}>
<Text style={{ color:'#fff' }}>尚未提供 matchId，請從場次頁進入。</Text>
</View>
);
}

const scoreA = typeof ui?.scoreA === 'number' ? ui!.scoreA! : 0;
const scoreB = typeof ui?.scoreB === 'number' ? ui!.scoreB! : 0;
const server = ui?.server;
const receiver = ui?.receiver;

// 類型/場地/選手（在選手後方標示「發/接」）
const singles = !!meta.singles;
const safe = (s: string|null|undefined, fallback: string) => (s && String(s).trim()) || fallback;
const h0 = safe(players.home[0], '主#1');
const h1 = safe(players.home[1], '主#2');
const a0 = safe(players.away[0], '客#1');
const a1 = safe(players.away[1], '客#2');

const label = (team:0|1, idx:0|1, base:string) => {
const tags:string[] = [];
if (server && server.team===team && server.index===idx) tags.push('發');
if (receiver && receiver.team===team && receiver.index===idx) tags.push('接');
return tags.length ? `${base}（${tags.join('、')}）` : base;
};

const homeLine = singles
? `主隊：${label(0,0,h0)}`
: `主隊：${label(0,0,h0)}、${label(0,1,h1)}`;

const awayLine = singles
? `客隊：${label(1,0,a0)}`
: `客隊：${label(1,0,a0)}、${label(1,1,a1)}`;

// 依折線圖資料推算各局比分（home/away 與勝方）
const gameBadges = React.useMemo(() => {
if (!series.length) return null;
const sums = series
.map(sec => {
const home = sec.rows.reduce((acc, r) => acc + (r.win ? 1 : 0), 0);
const away = sec.rows.length - home;
const winner = home > away ? 0 : away > home ? 1 : null;
return { g: sec.game, home, away, winner };
})
.sort((a, b) => a.g - b.g); // 標籤按局次升冪
return (
<View style={{ flexDirection:'row', flexWrap:'wrap', marginTop:8 }}>
{sums.map(x => (
<View
key={'badge-'+x.g}
style={{ paddingVertical:4, paddingHorizontal:8, borderRadius:12, borderWidth:1, borderColor:'#333', backgroundColor:'#222', marginRight:6, marginBottom:6 }}
>
<Text style={{ color:'#fff' }}>
G{x.g} {x.home}-{x.away}{x.winner==null ? '' : x.winner===0 ? '（主）' : '（客）'}
</Text>
</View>
))}
</View>
);
}, [series]);

return (
<ScrollView style={{ flex: 1, backgroundColor: '#111' }} contentContainerStyle={{ padding: 16 }}>
{/* 類型 / 場地 / 選手（含發/接標示 + 各局比分標籤） */}
<View style={{ backgroundColor:'#222', borderRadius:12, padding:12, marginBottom:12, borderWidth:1, borderColor:'#333' }}>
<Text style={{ color:'#fff', fontSize:16, fontWeight:'600' }}>
類型：{meta.type || '-'}　場地：{meta.court || '-'}
</Text>
<Text style={{ color:'#ddd', marginTop:6 }}>{homeLine}</Text>
<Text style={{ color:'#ddd', marginTop:4 }}>{awayLine}</Text>
{gameBadges}
</View>

  {/* 現在分數（維持樣式） */}
  <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', padding: 16, backgroundColor: '#222', borderRadius: 12 }}>
    <Text style={{ color: '#90caf9', fontSize: 48, fontWeight: '700' }}>{scoreA}</Text>
    <Text style={{ color: '#fff', fontSize: 32 }}>VS</Text>
    <Text style={{ color: '#ef9a9a', fontSize: 48, fontWeight: '700' }}>{scoreB}</Text>
  </View>

  {/* 每一局折線圖（降冪：最近在最上） */}
  <View style={{ marginTop: 16 }}>
    <Text style={{ color:'#fff', fontSize:16, fontWeight:'600', marginBottom:8 }}>每局趨勢</Text>
    {series.length === 0 ? (
      <Text style={{ color:'#999' }}>尚無記錄資料</Text>
    ) : (
      series.map(sec => (
        <TrendChart key={'g'+sec.game} title={`第 ${sec.game} 局趨勢`} rows={sec.rows} />
      ))
    )}
  </View>
</ScrollView>
);
}ezbmt-tracked/src/screens/JoinEventScreen.tsx
 
import React from 'react';
import { View, Text, TextInput, Pressable, Alert } from 'react-native';
import { joinEventByCode } from '../db';

export default function JoinEventScreen({ navigation }: any) {
const [code, setCode] = React.useState('');
const submit = async () => {
if (!code.trim()) return;
try {
await joinEventByCode(code.trim());
Alert.alert('成功', '已加入事件');
navigation.navigate('Events');
} catch (e: any) {
Alert.alert('失敗', String(e?.message || e));
}
};
return (
<View style={{ flex:1, padding:16 }}>
<Text style={{ fontSize:16, fontWeight:'600', marginBottom:8 }}>加入事件</Text>
<TextInput value={code} onChangeText={setCode} placeholder="輸入加入代碼" autoCapitalize="characters"
style={{ borderWidth:1, borderColor:'#ccc', borderRadius:8, paddingHorizontal:10, paddingVertical:8, marginBottom:10 }} />
<Pressable onPress={submit} style={{ backgroundColor:'#1976d2', paddingVertical:10, borderRadius:8, alignItems:'center' }}>
<Text style={{ color:'#fff' }}>加入</Text>
</Pressable>
</View>
);
}

ezbmt-tracked/src/screens/ChatScreen.tsx
 
import React from 'react';
import {
View,
Text,
FlatList,
TextInput,
Pressable,
KeyboardAvoidingView,
Platform,
ActivityIndicator,
NativeSyntheticEvent,
NativeScrollEvent,
} from 'react-native';
import { useRoute } from '@react-navigation/native';
import { useHeaderHeight } from '@react-navigation/elements';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { listChatMessages, insertChatMessage } from '../db';
import { supa, getCurrentUser } from '../lib/supabase';

type ChatItem = { id?: string; user?: string; text: string; created_at: string };

export default function ChatScreen() {
const route = useRoute<any>();
const matchId = route.params?.matchId as string;

const headerHeight = useHeaderHeight();
const insets = useSafeAreaInsets();

const INPUT_BAR_H = 52; // 輸入列高度（再加高）
const KAV_OFFSET = headerHeight + (insets.top || 0) + 8; // iOS: 再加一點保險

const [items, setItems] = React.useState<ChatItem[]>([]);
const [name, setName] = React.useState('');
const [text, setText] = React.useState('');
const [loading, setLoading] = React.useState(true);

// 自動帶入暱稱（profiles.name），若沒有就用 email 前綴
React.useEffect(() => {
let active = true;
(async () => {
try {
const u = await getCurrentUser();
if (!u || !active) return;
let preset = '';
try {
const { data } = await supa.from('profiles').select('name').eq('id', u.id).single();
if (data?.name && String(data.name).trim()) {
preset = String(data.name).trim();
} else if (u.email) {
preset = String(u.email).split('@')[0];
}
} catch {}
if (active && preset) setName(preset);
} catch {}
})();
return () => { active = false; };
}, []);

const load = React.useCallback(async () => {
try {
const rows = await listChatMessages(matchId, 200);
setItems(rows);
} finally {
setLoading(false);
}
}, [matchId]);

// Realtime 訂閱（Postgres Changes）+ 輪詢 fallback
React.useEffect(() => {
let channel: ReturnType<typeof supa.channel> | null = null;
try {
channel = supa
.channel('chat-' + matchId)
.on(
'postgres_changes',
{ event: 'INSERT', schema: 'public', table: 'chat_messages', filter: 'match_id=eq.' + matchId },
(payload: any) => {
const r = payload?.new || {};
const msg: ChatItem = {
id: r.id,
user: r.user_name || r.user || '匿名',
text: r.text || '',
created_at: r.created_at || new Date().toISOString(),
};
setItems((prev) => [msg, ...prev]);
}
)
.subscribe();
} catch {}

load();
const t = setInterval(load, 3000);

return () => {
  clearInterval(t);
  if (channel) channel.unsubscribe();
};
}, [load, matchId]);

const send = async () => {
const txt = text.trim();
const nm = name.trim();
if (!txt) return;

// 樂觀加入（先把訊息加到畫面）
const optimistic: ChatItem = {
  id: 'local-' + Date.now(),
  user: nm || '匿名',
  text: txt,
  created_at: new Date().toISOString(),
};
setItems((prev) => [optimistic, ...prev]);
setText('');

try {
  await insertChatMessage({ matchId, user: nm || '匿名', text: txt });
  // 後面 Realtime 會再補上正式那筆，或輪詢也會拉到
} catch {
  // 若失敗可選擇移除 optimistic；此處簡化不處理
}
};

// 讓點擊清單也能收鍵盤（體驗好一些）
const onScroll = (_e: NativeSyntheticEvent<NativeScrollEvent>) => {};

return (
<KeyboardAvoidingView
style={{ flex: 1, backgroundColor: '#111' }}
behavior={Platform.OS === 'ios' ? 'padding' : undefined}
keyboardVerticalOffset={Platform.OS === 'ios' ? KAV_OFFSET : 0}>

{/* 內容：預留底部輸入列高度 */}
<View style={{ flex: 1, padding: 12, paddingBottom: INPUT_BAR_H, backgroundColor: '#111' }}>
  {loading ? (
    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
      <ActivityIndicator color="#fff" />
    </View>
  ) : (
    <FlatList
      inverted
      data={items}
      keyExtractor={(i) => i.id || String(i.created_at)}
      keyboardShouldPersistTaps="handled"
      onScroll={onScroll}
      renderItem={({ item }) => (
        <View
          style={{
            padding: 10,
            borderRadius: 8,
            backgroundColor: '#222',
            marginBottom: 8,
          }}
        >
          <Text style={{ color: '#aaa', marginBottom: 4 }}>
            {item.user || '匿名'} · {new Date(item.created_at).toLocaleTimeString()}
          </Text>
          <Text style={{ color: '#fff' }}>{item.text}</Text>
        </View>
      )}
    />
  )}
</View>

{/* 底部輸入列（深色） */}
<View
  style={{
    position: 'absolute',
    left: 12,
    right: 12,
    top: 0,
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    height: INPUT_BAR_H,
    backgroundColor: '#222',
    borderRadius: 10,
    paddingHorizontal: 8,
    borderWidth: 1,
    borderColor: '#333',
  }}
>
  <TextInput
    placeholder="名稱（可空）"
    placeholderTextColor="#888"
    value={name}
    onChangeText={setName}
    style={{
      width: 140,
      height: INPUT_BAR_H - 10,
      borderWidth: 1,
      borderColor: '#444',
      borderRadius: 8,
      paddingHorizontal: 10,
      color: '#fff',
      backgroundColor: '#111',
    }}
    autoCapitalize="none"
    returnKeyType="next"
  />
  <TextInput
    placeholder="輸入訊息…"
    placeholderTextColor="#888"
    value={text}
    onChangeText={setText}
    onSubmitEditing={send}
    style={{
      flex: 1,
      height: INPUT_BAR_H - 10,
      borderWidth: 1,
      borderColor: '#444',
      borderRadius: 8,
      paddingHorizontal: 10,
      color: '#fff',
      backgroundColor: '#111',
    }}
    returnKeyType="send"
    blurOnSubmit={false}
  />
  <Pressable
    onPress={send}
    disabled={!text.trim()}
    style={{
      backgroundColor: text.trim() ? '#1976d2' : '#555',
      paddingHorizontal: 16,
      height: INPUT_BAR_H - 10,
      borderRadius: 8,
      justifyContent: 'center',
    }}
  >
    <Text style={{ color: '#fff' }}>送出</Text>
  </Pressable>
</View>
</KeyboardAvoidingView> );
}
ezbmt-tracked/src/screens/MediaScreen.tsx
 
import React from 'react';
import { View, Text, FlatList, TextInput, Pressable, Alert, Linking, Image, KeyboardAvoidingView, Platform } from 'react-native';
import { useRoute } from '@react-navigation/native';
import { useHeaderHeight } from '@react-navigation/elements';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { launchImageLibrary, Asset } from 'react-native-image-picker';
import { listMedia, insertMedia, deleteMedia } from '../db';
import { uploadImageFromUri, getPublicUrl, removeFile, publicUrlToPath } from '../lib/storage';
import YoutubePlayer from 'react-native-youtube-iframe';

type MediaItem = { id: string; kind: 'youtube'|'photo'|string; url: string; description?: string };

const C = { bg:'#111', card:'#222', border:'#333', field:'#111', fieldBorder:'#444', text:'#fff', sub:'#ddd', hint:'#888' };

function getYouTubeId(url: string): string | null {
try {
const u = new URL(url);
if (u.hostname.includes('youtu.be')) return u.pathname.replace('/','') || null;
if (u.hostname.includes('youtube.com')) {
const v = u.searchParams.get('v'); if (v) return v;
const m = u.pathname.match(`//(embed|shorts)/([A-Za-z0-9_-]{6,})/`); if (m && m[2]) return m[2];
}
} catch {}
return null;
}

export default function MediaScreen() {
const route = useRoute<any>(); const matchId = route.params?.matchId as string;
const headerHeight = useHeaderHeight(); const insets = useSafeAreaInsets();

const [items, setItems] = React.useState<MediaItem[]>([]);
const [yt, setYt] = React.useState(''); const [desc, setDesc] = React.useState('');
const [uploading, setUploading] = React.useState(false);
const [playId, setPlayId] = React.useState<string|null>(null);

const load = React.useCallback(async () => {
const rows = await listMedia('match', matchId);
setItems(rows as MediaItem[]);
}, [matchId]);
React.useEffect(() => { load(); }, [load]);

const addYoutube = async () => {
const url = yt.trim(); if (!url) return;
if (!/^(https?:\/\/)?(www.)?(youtube.com|youtu.be)\//i.test(url)) { Alert.alert('URL 格式錯誤','請輸入有效的 YouTube 連結'); return; }
await insertMedia({ owner_type:'match', owner_id:matchId, kind:'youtube', url, description: desc.trim()||undefined });
setYt(''); setDesc(''); load();
};

const pickAndUploadPhoto = async () => {
try {
const res = await launchImageLibrary({ mediaType:'photo', selectionLimit:1, quality:0.9 });
if (res.didCancel) return;
const asset: Asset|undefined = res.assets?.[0]; if (!asset?.uri) return;
setUploading(true);
const mime = asset.type || 'image/jpeg';
const extFromName = (asset.fileName||'').split('.').pop()?.toLowerCase();
const extFromMime = mime.split('/').pop()?.toLowerCase();
const ext = extFromName && extFromName.length<=5 ? extFromName : (extFromMime || 'jpg');
const path = `match/${matchId}/${Date.now()}-${Math.floor(Math.random()*1e7)}.${ext}`;
const storagePath = await uploadImageFromUri(asset.uri, path, mime);
const publicUrl = getPublicUrl(storagePath);
await insertMedia({ owner_type:'match', owner_id:matchId, kind:'photo', url:publicUrl, description: desc.trim()||undefined });
setDesc(''); await load(); Alert.alert('成功','照片已上傳');
} catch (e:any) { Alert.alert('上傳失敗', String(e?.message||e)); } finally { setUploading(false); }
};

const removeItem = async (item: MediaItem) => {
try {
if (item.kind === 'photo') { const p = publicUrlToPath(item.url); if (p) { try { await removeFile(p); } catch {} } }
await deleteMedia(item.id);
const id = getYouTubeId(item.url); if (id && id === playId) setPlayId(null);
await load();
} catch (e:any) { Alert.alert('刪除失敗', String(e?.message||e)); }
};

const renderYouTube = (url: string) => {
const id = getYouTubeId(url);
if (!id) {
return <Pressable onPress={()=>Linking.openURL(url)}><Text style={{ color:'#90caf9' }} numberOfLines={1}>{url}</Text></Pressable>;
}
if (playId === id) {
return (
<View style={{ marginTop:6, borderRadius:8, overflow:'hidden', backgroundColor:'#000' }}>
<YoutubePlayer
height={220}
play={true}
videoId={id}
onChangeState={(s: string) => { if (s === 'ended') setPlayId(null); }}
webViewStyle={{ backgroundColor:'#000' }}
forceAndroidAutoplay={false}
webViewProps={{ allowsFullscreenVideo:true, allowsInlineMediaPlayback:true, mediaPlaybackRequiresUserAction:false }}
/>
</View>
);
}
return (
<Pressable onPress={()=>setPlayId(id)} style={{ borderRadius:8, overflow:'hidden', backgroundColor:'#000', marginTop:6 }}>
<Image source={{ uri:`https://img.youtube.com/vi/${id}/hqdefault.jpg` }} style={{ width:'100%', height:180, backgroundColor:'#333' }} resizeMode="cover" />
<View style={{ position:'absolute', left:0,right:0,top:0,bottom:0, justifyContent:'center', alignItems:'center' }}>
<View style={{ width:58, height:58, borderRadius:29, backgroundColor:'rgba(0,0,0,0.6)', justifyContent:'center', alignItems:'center' }}>
<View style={{ marginLeft:4, width:0, height:0, borderLeftWidth:14, borderLeftColor:'#fff', borderTopWidth:10, borderTopColor:'transparent', borderBottomWidth:10, borderBottomColor:'transparent' }} />
</View>
</View>
</Pressable>
);
};

const renderRow = ({ item }: { item: MediaItem }) => (
<View style={{ padding:10, borderWidth:1, borderColor:C.border, backgroundColor:C.card, borderRadius:8, marginBottom:8 }}>
<Text style={{ color:C.text, fontWeight:'600' }}>{item.kind==='youtube'?'YouTube':'照片'}</Text>
{item.kind === 'photo'
? <Image source={{ uri:item.url }} style={{ width:'100%', height:180, borderRadius:8, backgroundColor:'#333', marginTop:6 }} resizeMode="cover" />
: renderYouTube(item.url)
}
{!!item.description && <Text style={{ color:C.sub, marginTop:6 }}>{item.description}</Text>}
<View style={{ flexDirection:'row', marginTop:8 }}>
<Pressable onPress={()=>removeItem(item)} style={{ paddingVertical:6, paddingHorizontal:10, backgroundColor:'#d32f2f', borderRadius:8 }}>
<Text style={{ color:'#fff' }}>刪除</Text>
</Pressable>
</View>
</View>
);

return (
<KeyboardAvoidingView style={{ flex:1, backgroundColor:C.bg }} behavior={Platform.OS==='ios' ? 'padding' : undefined} keyboardVerticalOffset={headerHeight}>
<FlatList
data={items}
keyExtractor={(i)=>i.id}
renderItem={renderRow}
keyboardShouldPersistTaps="handled"
keyboardDismissMode={Platform.OS==='ios' ? 'interactive' : 'on-drag'}
contentContainerStyle={{ padding:12, paddingBottom:(insets.bottom||16)+160 }}
ListHeaderComponent={<Text style={{ color:C.text, fontSize:16, fontWeight:'600', marginBottom:8 }}>媒體清單</Text>}
ListFooterComponent={
<View style={{ borderTopWidth:1, borderColor:C.border, paddingTop:10, marginTop:10 }}>
<Text style={{ color:C.text, fontWeight:'600', marginBottom:6 }}>新增 YouTube 連結</Text>
<TextInput
placeholder="https://youtu.be/..."
placeholderTextColor={C.hint}
value={yt}
onChangeText={setYt}
autoCapitalize="none"
style={{ borderWidth:1, borderColor:C.fieldBorder, borderRadius:8, paddingHorizontal:10, paddingVertical:8, marginBottom:6, color:C.text, backgroundColor:C.field }}
returnKeyType="next"
/>
<TextInput
placeholder="描述（可空）"
placeholderTextColor={C.hint}
value={desc}
onChangeText={setDesc}
style={{ borderWidth:1, borderColor:C.fieldBorder, borderRadius:8, paddingHorizontal:10, paddingVertical:8, marginBottom:8, color:C.text, backgroundColor:C.field }}
returnKeyType="done"
onSubmitEditing={addYoutube}
/>
<Pressable onPress={addYoutube} style={{ backgroundColor:'#1976d2', paddingVertical:10, borderRadius:8, alignItems:'center', marginBottom:12 }}>
<Text style={{ color:'#fff' }}>新增</Text>
</Pressable>

        <Text style={{ color:C.text, fontWeight:'600', marginBottom:6 }}>或上傳照片（會公開可見）</Text>
        <Pressable disabled={uploading} onPress={pickAndUploadPhoto} style={{ backgroundColor: uploading ? '#999' : '#f57c00', paddingVertical:10, borderRadius:8, alignItems:'center' }}>
          <Text style={{ color:'#fff' }}>{uploading ? '上傳中…' : '選擇照片上傳'}</Text>
        </Pressable>
      </View>
    }
  />
</KeyboardAvoidingView>
);
}ezbmt-tracked/src/screens/ProfileScreen.tsx
 
import React from 'react';
import { View, Text, TextInput, Pressable, Alert, Image, ScrollView } from 'react-native';
import { useFocusEffect } from '@react-navigation/native';
import { supa, getCurrentUser } from '../lib/supabase';
import { useBgStore } from '../store/bg';
import { launchImageLibrary, type ImageLibraryOptions } from 'react-native-image-picker';

export default function ProfileScreen({ navigation }: any) {
const [name, setName] = React.useState('');
const [busy, setBusy] = React.useState(false);

// 修改密碼
const [pwd1, setPwd1] = React.useState('');
const [pwd2, setPwd2] = React.useState('');
const [pwdBusy, setPwdBusy] = React.useState(false);

// 背景（本機）
const bgUri = useBgStore(s => s.uri);
const opacity = useBgStore(s => s.opacity);
const setOpacity = useBgStore(s => s.setOpacity);
const setFromBase64 = useBgStore(s => s.setFromBase64);
const clearBg = useBgStore(s => s.clear);

// 只從 profiles.name 載入
const preloadName = React.useCallback(async () => {
try {
const u = await getCurrentUser();
if (!u) return;
const { data, error } = await supa
.from('profiles')
.select('name')
.eq('id', u.id)
.maybeSingle();
if (!error && data?.name != null) setName(String(data.name));
else setName(''); // 無資料就空白
} catch {
setName('');
}
}, []);

useFocusEffect(React.useCallback(() => { preloadName(); }, [preloadName]));

// 只寫 profiles.name
const save = async () => {
const nm = (name ?? '').trim();
setBusy(true);
try {
const u = await getCurrentUser();
if (!u) throw new Error('未登入');
const { error } = await supa.from('profiles').upsert({ id: u.id, name: nm });
if (error) throw error;
Alert.alert('成功', '已更新暱稱');
await preloadName();
} catch (e: any) {
Alert.alert('失敗', String(e?.message || e));
} finally {
setBusy(false);
}
};

async function handleChangePassword() {
if (!pwd1 || pwd1.length < 6) { Alert.alert('提示', '請輸入至少 6 碼的新密碼'); return; }
if (pwd1 !== pwd2) { Alert.alert('提示', '兩次輸入的密碼不一致'); return; }
setPwdBusy(true);
try {
const { error } = await supa.auth.updateUser({ password: pwd1 });
if (error) throw error;
setPwd1(''); setPwd2('');
Alert.alert('成功', '已更新密碼');
} catch (e:any) {
Alert.alert('失敗', String(e?.message || e));
} finally {
setPwdBusy(false);
}
}

async function handleSignOut() {
try {
await supa.auth.signOut();
navigation.replace('Auth');
} catch (e:any) {
Alert.alert('登出失敗', String(e?.message || e));
}
}

async function pickBackground() {
try {
const opts: ImageLibraryOptions = { mediaType: 'photo', quality: 0.9, includeBase64: true, selectionLimit: 1 };
const res = await launchImageLibrary(opts);
if (res.didCancel) return;
const a = res.assets && res.assets[0];
if (!a?.base64) { Alert.alert('失敗', '此圖片無法取得內容，請再試一次'); return; }
const ext = (a.fileName?.split('.').pop() || (a.type?.split('/')?.pop() || 'jpg')).toLowerCase();
await setFromBase64(a.base64, ext);
Alert.alert('成功', '已設定背景圖');
} catch (e: any) {
Alert.alert('失敗', String(e?.message || e));
}
}

return (
<ScrollView contentContainerStyle={{ padding:16 }}>
<Text style={{ fontSize:16, fontWeight:'600', marginBottom:8 }}>個人資料</Text>

  {/* 暱稱（只帶 profiles.name） */}
  <TextInput
    value={name}
    onChangeText={setName}
    placeholder="暱稱"
    style={{ borderWidth:1, borderColor:'#ccc', borderRadius:8, paddingHorizontal:10, paddingVertical:8, marginBottom:10 }}
  />
  <Pressable onPress={save} disabled={busy} style={{ backgroundColor:'#1976d2', paddingVertical:10, borderRadius:8, alignItems:'center', marginBottom:16 }}>
    <Text style={{ color:'#fff' }}>儲存</Text>
  </Pressable>

  {/* 修改密碼 */}
  <Text style={{ fontSize:16, fontWeight:'600', marginBottom:8 }}>修改密碼</Text>
  <TextInput
    value={pwd1}
    onChangeText={setPwd1}
    placeholder="新密碼（至少 6 碼）"
    secureTextEntry
    style={{ borderWidth:1, borderColor:'#ccc', borderRadius:8, paddingHorizontal:10, paddingVertical:8, marginBottom:8 }}
  />
  <TextInput
    value={pwd2}
    onChangeText={setPwd2}
    placeholder="再次輸入新密碼"
    secureTextEntry
    style={{ borderWidth:1, borderColor:'#ccc', borderRadius:8, paddingHorizontal:10, paddingVertical:8, marginBottom:10 }}
  />
  <Pressable onPress={handleChangePassword} disabled={pwdBusy} style={{ backgroundColor:'#00695c', paddingVertical:10, borderRadius:8, alignItems:'center', marginBottom:24 }}>
    <Text style={{ color:'#fff' }}>更新密碼</Text>
  </Pressable>

  {/* 背景設定（本機） */}
  <Text style={{ fontSize:16, fontWeight:'600', marginBottom:8 }}>背景圖片（本機）</Text>
  {bgUri ? (
    <View style={{ marginBottom: 10 }}>
      <Image source={{ uri: bgUri }} resizeMode="cover" style={{ width: '100%', height: 160, borderRadius: 8, backgroundColor:'#eee' }} />
      <Text style={{ color:'#555', marginTop:6 }}>目前透明度：{Math.round(opacity*100)}%</Text>
    </View>
  ) : (
    <Text style={{ color:'#666', marginBottom: 8 }}>尚未設定背景圖</Text>
  )}

  <View style={{ flexDirection:'row', flexWrap:'wrap', marginBottom:10 }}>
    <Pressable onPress={pickBackground} style={{ paddingVertical:8, paddingHorizontal:12, backgroundColor:'#1976d2', borderRadius:8, marginRight:8, marginBottom:8 }}>
      <Text style={{ color:'#fff' }}>選擇圖片</Text>
    </Pressable>
    {!!bgUri && (
      <Pressable onPress={clearBg} style={{ paddingVertical:8, paddingHorizontal:12, backgroundColor:'#9e9e9e', borderRadius:8, marginRight:8, marginBottom:8 }}>
        <Text style={{ color:'#fff' }}>清除背景</Text>
      </Pressable>
    )}
  </View>

  {!!bgUri && (
    <>
      <Text style={{ marginBottom:6 }}>透明度</Text>
      <View style={{ flexDirection:'row', flexWrap:'wrap' }}>
        {[0.15, 0.25, 0.4].map(v => (
          <Pressable key={String(v)} onPress={() => setOpacity(v)} style={{
            paddingVertical:6, paddingHorizontal:10, borderRadius:14,
            borderWidth:1, borderColor: opacity===v?'#1976d2':'#ccc',
            backgroundColor: opacity===v?'rgba(25,118,210,0.1)':'#fff',
            marginRight:8, marginBottom:8
          }}>
            <Text>{Math.round(v*100)}%</Text>
          </Pressable>
        ))}
      </View>
    </>
  )}

  {/* 取消與登出（取消放在登出上面） */}
  <Pressable onPress={()=>navigation.goBack()} style={{ backgroundColor:'#9e9e9e', paddingVertical:10, borderRadius:8, alignItems:'center', marginTop:24 }}>
    <Text style={{ color:'#fff' }}>取消</Text>
  </Pressable>
  <Pressable onPress={async()=>{ await supa.auth.signOut(); navigation.replace('Auth'); }} style={{ backgroundColor:'#d32f2f', paddingVertical:10, borderRadius:8, alignItems:'center', marginTop:12 }}>
    <Text style={{ color:'#fff' }}>登出</Text>
  </Pressable>
</ScrollView>
);
}ezbmt-tracked/src/screens/PlayerSetupScreen.tsx
 
import React from 'react';
import {
View,
Text,
TextInput,
Pressable,
Alert,
ScrollView,
KeyboardAvoidingView,
Platform,
LayoutChangeEvent,
NativeSyntheticEvent,
NativeScrollEvent,
} from 'react-native';
import { useRoute, useNavigation } from '@react-navigation/native';
import { useHeaderHeight } from '@react-navigation/elements';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { getMatch, getMatchPlayers, upsertMatchPlayers, updateStartConfigs } from '../db';

const C = {
bg: '#111',
card: '#222',
border: '#333',
field: '#111',
fieldBorder: '#444',
text: '#fff',
sub: '#ddd',
hint: '#888',
chipOn: '#90caf9',
chipOff: '#555',
};

type PlayerForm = { name: string; gender: 'M' | 'F' | 'U'; handedness: 'L' | 'R' | 'U' };

export default function PlayerSetupScreen() {
const route = useRoute<any>();
const navigation = useNavigation<any>();
const matchId = route.params.matchId as string;

const headerHeight = useHeaderHeight();
const insets = useSafeAreaInsets();

const [home, setHome] = React.useState<[PlayerForm, PlayerForm]>([
{ name: '', gender: 'U', handedness: 'R' },
{ name: '', gender: 'U', handedness: 'R' },
]);
const [away, setAway] = React.useState<[PlayerForm, PlayerForm]>([
{ name: '', gender: 'U', handedness: 'R' },
{ name: '', gender: 'U', handedness: 'R' },
]);
const [homeRight, setHomeRight] = React.useState<0 | 1>(0);
const [awayRight, setAwayRight] = React.useState<0 | 1>(0);
const [startingTeam, setStartingTeam] = React.useState<0 | 1>(0);
const [startingIndex, setStartingIndex] = React.useState<0 | 1>(0);

React.useEffect(() => {
(async () => {
const m = await getMatch(matchId);
if (m) {
if (typeof m.home_right_when_even_index === 'number') setHomeRight(m.home_right_when_even_index as 0 | 1);
if (typeof m.away_right_when_even_index === 'number') setAwayRight(m.away_right_when_even_index as 0 | 1);
if (typeof m.starting_server_team === 'number') setStartingTeam(m.starting_server_team as 0 | 1);
if (typeof m.starting_server_index === 'number') setStartingIndex(m.starting_server_index as 0 | 1);
}
const ps = await getMatchPlayers(matchId);
if (ps && ps.length) {
const h: [PlayerForm, PlayerForm] = [
{ name: '', gender: 'U', handedness: 'R' },
{ name: '', gender: 'U', handedness: 'R' },
];
const a: [PlayerForm, PlayerForm] = [
{ name: '', gender: 'U', handedness: 'R' },
{ name: '', gender: 'U', handedness: 'R' },
];
for (const p of ps) {
const form: PlayerForm = {
name: p.name || '',
gender: (p.gender as any) || 'U',
handedness: (p.handedness as any) || 'R',
};
if (p.side === 'home') h[p.idx] = form;
else a[p.idx] = form;
}
setHome(h);
setAway(a);
}
})();
}, [matchId]);

const save = async () => {
try {
await upsertMatchPlayers({
matchId,
home: [
{ idx: 0, name: home[0].name, gender: home[0].gender, handedness: home[0].handedness },
{ idx: 1, name: home[1].name, gender: home[1].gender, handedness: home[1].handedness },
],
away: [
{ idx: 0, name: away[0].name, gender: away[0].gender, handedness: away[0].handedness },
{ idx: 1, name: away[1].name, gender: away[1].gender, handedness: away[1].handedness },
],
});
await updateStartConfigs({
matchId,
startingServerTeam: startingTeam,
startingServerIndex: startingIndex,
homeRightWhenEven: homeRight,
awayRightWhenEven: awayRight,
});
Alert.alert('已儲存', '球員與起始設定已更新');
navigation.goBack();
} catch (e: any) {
Alert.alert('儲存失敗', String(e?.message || e));
}
};

// ---- 避免鍵盤遮住輸入：只在需要時捲動 ----
const scrollRef = React.useRef<ScrollView | null>(null);
const inputRectsRef = React.useRef<Record<string, { y: number; h: number }>>({});
const viewportHRef = React.useRef(0);
const scrollYRef = React.useRef(0);

const onScroll = (e: NativeSyntheticEvent<NativeScrollEvent>) => {
scrollYRef.current = e.nativeEvent.contentOffset.y;
};
const onScrollViewLayout = (e: LayoutChangeEvent) => {
viewportHRef.current = e.nativeEvent.layout.height;
};

const onInputLayout = (key: string) => (e: LayoutChangeEvent) => {
const { y, height } = e.nativeEvent.layout;
inputRectsRef.current[key] = { y, h: height };
};

const onInputFocus = (key: string) => () => {
const rect = inputRectsRef.current[key];
if (!rect) return;
const margin = 80; // 讓欄位上方留一些空白
const top = rect.y;
const bottom = rect.y + rect.h;

const visibleTop = scrollYRef.current;
const visibleBottom = scrollYRef.current + viewportHRef.current;

// 如果已經完全可見，就不捲動
if (top >= visibleTop + 8 && bottom <= visibleBottom - 8) return;

// 如果在上方超出，就往上捲
if (top < visibleTop + margin) {
  const to = Math.max(0, top - margin);
  scrollRef.current?.scrollTo({ y: to, animated: true });
  return;
}
// 如果在下方超出，就往下捲
if (bottom > visibleBottom - margin) {
  const to = Math.max(0, bottom - viewportHRef.current + margin);
  scrollRef.current?.scrollTo({ y: to, animated: true });
}
};
// ------------------------------------------------

return (
<KeyboardAvoidingView
style={{ flex: 1 }}
behavior={Platform.OS === 'ios' ? 'padding' : undefined}
keyboardVerticalOffset={headerHeight}
>
<ScrollView
ref={scrollRef}
onLayout={onScrollViewLayout}
onScroll={onScroll}
scrollEventThrottle={16}
contentContainerStyle={{ padding: 16, paddingBottom: (insets.bottom || 16) + 320 }}
keyboardShouldPersistTaps="handled"
style={{ flex: 1, backgroundColor: C.bg }}
>
<Text style={{ fontSize: 18, fontWeight: '600', marginBottom: 12 }}>球員設定</Text>

    <TeamBox
      title="主隊（Home）"
      players={home}
      onChange={(p) => setHome(p)}
      rightWhenEven={homeRight}
      setRightWhenEven={setHomeRight}
      nameKeys={['home-0', 'home-1']}
      onNameLayout={onInputLayout}
      onNameFocus={onInputFocus}
    />
    <TeamBox
      title="客隊（Away）"
      players={away}
      onChange={(p) => setAway(p)}
      rightWhenEven={awayRight}
      setRightWhenEven={setAwayRight}
      nameKeys={['away-0', 'away-1']}
      onNameLayout={onInputLayout}
      onNameFocus={onInputFocus}
    />

    <Text style={{ fontSize: 16, fontWeight: '600', marginTop: 16, marginBottom: 8 }}>開場發球</Text>
    <Row>
      <Badge onPress={() => setStartingTeam(0)} active={startingTeam === 0} text="主隊" />
      <Badge onPress={() => setStartingTeam(1)} active={startingTeam === 1} text="客隊" />
    </Row>
    <Row>
      <Badge onPress={() => setStartingIndex(0)} active={startingIndex === 0} text="#1" />
      <Badge onPress={() => setStartingIndex(1)} active={startingIndex === 1} text="#2" />
    </Row>

    <Pressable onPress={save} style={{ marginTop: 20, backgroundColor: '#1976d2', paddingVertical: 12, borderRadius: 8, alignItems: 'center' }}>
      <Text style={{ color: '#fff', fontSize: 16 }}>儲存</Text>
    </Pressable>
  </ScrollView>
</KeyboardAvoidingView>
);
}

function TeamBox({
title, players, onChange, rightWhenEven, setRightWhenEven,
nameKeys, onNameLayout, onNameFocus,
}: {
title: string;
players: [PlayerForm, PlayerForm];
onChange: (v: [PlayerForm, PlayerForm]) => void;
rightWhenEven: 0 | 1;
setRightWhenEven: (v: 0 | 1) => void;
nameKeys: [string, string];
onNameLayout: (key: string) => (e: LayoutChangeEvent) => void;
onNameFocus: (key: string) => () => void;
}) {
const setP = (i: 0 | 1, patch: Partial<PlayerForm>) => {
const next: [PlayerForm, PlayerForm] = [...players] as any;
next[i] = { ...next[i], ...patch };
onChange(next);
};

return (
<View style={{ borderWidth: 1, borderColor: C.border, backgroundColor: C.card, borderRadius: 12, padding: 12, marginBottom: 12 }}>
<Text style={{ fontWeight: '600', marginBottom: 8, color: C.text }}>{title}</Text>
{[0, 1].map((i) => (
<View key={i} style={{ marginBottom: 10 }}>
<Text style={{ marginBottom: 6, color: C.sub }}>球員 #{i + 1}</Text>
<TextInput
placeholder="姓名"
placeholderTextColor={C.hint}
value={players[i].name}
onChangeText={(t) => setP(i as 0 | 1, { name: t })}
onLayout={onNameLayout(nameKeys[i as 0 | 1])}
onFocus={onNameFocus(nameKeys[i as 0 | 1])}
style={{
borderWidth: 1,
borderColor: C.fieldBorder,
borderRadius: 8,
paddingHorizontal: 10,
paddingVertical: 10,
marginBottom: 6,
backgroundColor: C.field,
color: C.text,
}}
returnKeyType="done"
/>
<Row>
<Badge onPress={() => setP(i as 0 | 1, { gender: 'M' })} active={players[i].gender === 'M'} text="男" />
<Badge onPress={() => setP(i as 0 | 1, { gender: 'F' })} active={players[i].gender === 'F'} text="女" />
<Badge onPress={() => setP(i as 0 | 1, { gender: 'U' })} active={players[i].gender === 'U'} text="未註明" />
</Row>
<Row>
<Badge onPress={() => setP(i as 0 | 1, { handedness: 'R' })} active={players[i].handedness === 'R'} text="右手" />
<Badge onPress={() => setP(i as 0 | 1, { handedness: 'L' })} active={players[i].handedness === 'L'} text="左手" />
<Badge onPress={() => setP(i as 0 | 1, { handedness: 'U' })} active={players[i].handedness === 'U'} text="未註明" />
</Row>
</View>
))}

<Text style={{ marginTop: 4, marginBottom: 6, color: C.sub }}>偶數分站右（Right when Even）：</Text>
<Row>
<Badge onPress={() => setRightWhenEven(0)} active={rightWhenEven === 0} text="#1 在右" />
<Badge onPress={() => setRightWhenEven(1)} active={rightWhenEven === 1} text="#2 在右" />
</Row>

</View>
);
}

function Row({ children }: any) {
return <View style={{ flexDirection: 'row', alignItems: 'center', flexWrap: 'wrap', gap: 8, marginBottom: 8 }}>{children}</View>;
}
function Badge({ text, active, onPress }: { text: string; active?: boolean; onPress?: () => void }) {
return (
<Pressable
onPress={onPress}
style={{
paddingVertical: 8,
paddingHorizontal: 12,
borderRadius: 16,
borderWidth: 1,
borderColor: active ? C.chipOn : C.chipOff,
backgroundColor: active ? 'rgba(144,202,249,0.15)' : C.card,
marginRight: 8,
marginBottom: 8,
}}>

<Text style={{ color: C.text }}>{text}</Text>
</Pressable>
);
}ezbmt-tracked/src/screens/RecordScreen.tsx
 
import React from 'react';
import {
  View,
  Text,
  Modal,
  Pressable,
  FlatList,
  Alert,
  Dimensions,
  ActivityIndicator,
  ScrollView,
} from 'react-native';
import Svg, { Line, Path, Text as SvgText, G } from 'react-native-svg';
import Court from '../components/Court';
import MarkerSheet from '../components/MarkerSheet';
import type { Orientation, Side, Zone, TapEvent, Point } from '../types';
import { useRecordsStore } from '../store/records';
import {
  getMatch,
  getMatchPlayers,
  saveMatchState,
  upsertGameSummary,
  listRecentRallies,
  listRalliesOrdered,
  getLastRally,
  deleteRally,
  listDictionary,
  openDB,
} from '../db';
import {
  createMatch as createServeMatch,
  deserialize,
  serialize,
  getUiSnapshot,
  nextRally,
  MatchState,
  RuleConfig,
} from '../logic/serve';
import { publishLiveState } from '../lib/supabase';
import { BACKEND } from '../lib/backend';
import { supa } from '../lib/supabase';

type Marker = {
  id: string;
  rx: number;
  ry: number;
  kind: 'win' | 'loss';
  meta: any;
  game?: number;
};

type GameSum = { i: number; home: number; away: number; winner: 0 | 1 | null };

export default function RecordScreen({ navigation }: any) {
  const orientation: Orientation = 'portrait';

  const currentMatchId = useRecordsStore(s => s.currentMatchId);
  const loadRecent = useRecordsStore(s => s.loadRecent);
  const addRecord = useRecordsStore(s => s.addRecord);
  const records = useRecordsStore(s => s.records);

  const [panel, setPanel] = React.useState<null | {
    isWin: boolean;
    zone: Zone;
    tapPoint?: Point;
    norm?: { x: number; y: number };
    meta: any;
    route?: { start: Point; end: Point };
  }>(null);

  const [routeStart, setRouteStart] = React.useState<Point | null>(null);
  const [routeStartNorm, setRouteStartNorm] = React.useState<{ x: number; y: number } | null>(null);
  const [routeHover, setRouteHover] = React.useState<Point | null>(null);

  const [serveState, setServeState] = React.useState<MatchState | null>(null);
  const [ui, setUi] = React.useState<any>(null);

  const [loading, setLoading] = React.useState(true);
  const [mode, setMode] = React.useState<'tap' | 'route'>('tap');
  const [isSingles, setIsSingles] = React.useState<boolean>(false);

  const [shotTypes, setShotTypes] = React.useState<string[]>([]);
  const [errorReasons, setErrorReasons] = React.useState<string[]>([]);

  const [markers, setMarkers] = React.useState<Marker[]>([]);
  const [markerSheet, setMarkerSheet] = React.useState<{
    visible: boolean;
    data: { id: string; kind: 'win' | 'loss'; meta: any } | null;
  }>({ visible: false, data: null });

  const [endModal, setEndModal] = React.useState<{
    type: 'game' | 'match';
    gameIndex: number;
    score: [number, number];
  } | null>(null);
  const [deciderSwitchShownForGame, setDeciderSwitchShownForGame] = React.useState<number | null>(null);
  const [intervalShownForGame, setIntervalShownForGame] = React.useState<number | null>(null);

  // 黑點與上移
  const [focus, setFocus] = React.useState<Point | null>(null);
  const courtWrapRef = React.useRef<View>(null);
  const baseTopRef = React.useRef<number | null>(null);
  const baseHRef = React.useRef<number>(0);
  const [panelH, setPanelH] = React.useState(0);
  const [shiftY, setShiftY] = React.useState(0);

  const winH = Dimensions.get('window').height;

  // 場上落點篩選（全部/本局）
  const [courtFilter, setCourtFilter] = React.useState<'all' | 'current'>('all');

  // 記錄 Sheet
  const [recSheetOpen, setRecSheetOpen] = React.useState(false);
  const [recSheetLoading, setRecSheetLoading] = React.useState(false);
  const [recSheetRows, setRecSheetRows] = React.useState<
    Array<{ id: string; game: number; no: number; win: boolean; zone: string; meta: any; createdAt: string }>
  >([]);
  const [gameSums, setGameSums] = React.useState<GameSum[]>([]);
  const [recFilter, setRecFilter] = React.useState<'all' | 'current'>('all');

  // 標題列「各局比分＋勝方」
  const [headerSums, setHeaderSums] = React.useState<GameSum[]>([]);
  const headerSumsText = React.useMemo(() => {
    if (!headerSums?.length) return '';
    return headerSums
      .map(g => `第${g.i}局 ${g.home}:${g.away}${g.winner == null ? '' : g.winner === 0 ? '（主）' : '（客）'}`)
      .join('  ');
  }, [headerSums]);

  React.useEffect(() => {
    init();
  }, [currentMatchId, loadRecent]);

  const measureCourtBase = React.useCallback(() => {
    requestAnimationFrame(() => {
      courtWrapRef.current?.measureInWindow((x, y, w, h) => {
        if (!panel && shiftY === 0) {
          baseTopRef.current = y;
          baseHRef.current = h;
        }
      });
    });
  }, [panel, shiftY]);
  React.useEffect(() => {
    measureCourtBase();
  }, [measureCourtBase]);

  React.useEffect(() => {
    if (!panel) {
      if (shiftY !== 0) setShiftY(0);
      return;
    }
    if (!focus || panelH <= 0 || baseTopRef.current == null) return;

    const margin = 16;
    const panelTop = winH - panelH;
    const dotAbsY = baseTopRef.current + focus.y;
    const needed = Math.max(0, dotAbsY - (panelTop - margin));
    if (Math.abs(needed - shiftY) > 0.5) setShiftY(needed);
  }, [panel, panelH, focus, winH, shiftY]);

  async function init() {
    if (!currentMatchId) {
      setLoading(false);
      return;
    }
    setLoading(true);
    try {
      const m = await getMatch(currentMatchId);
      setMode(m?.record_mode === 'route' ? 'route' : 'tap');
      setIsSingles(m?.type === 'MS' || m?.type === 'WS');

      try {
        const st = await listDictionary('shot_type');
        const er = await listDictionary('error_reason');
        setShotTypes(st.map(x => x.label));
        setErrorReasons(er.map(x => x.label));
      } catch {
        setShotTypes(['切球', '網前', '封網', '殺球', '高遠球', '挑球及推後場', '過渡', '平抽', '發球']);
        setErrorReasons(['出界', '掛網', '質量不好', '發球失誤']);
      }

      const players = await getMatchPlayers(currentMatchId);
      let s: MatchState | null = null;
      if (m?.state_json) {
        try {
          s = deserialize(m.state_json);
        } catch {}
      }

      const homePlayers: [any, any] = [
        { id: 'A0', name: players.find(p => p.side === 'home' && p.idx === 0)?.name || '主#1' },
        { id: 'A1', name: players.find(p => p.side === 'home' && p.idx === 1)?.name || '主#2' },
      ];
      const awayPlayers: [any, any] = [
        { id: 'B0', name: players.find(p => p.side === 'away' && p.idx === 0)?.name || '客#1' },
        { id: 'B1', name: players.find(p => p.side === 'away' && p.idx === 1)?.name || '客#2' },
      ];

      const dbHomeRight =
        typeof m?.home_right_when_even_index === 'number' ? (m.home_right_when_even_index as 0 | 1) : 0;
      const dbAwayRight =
        typeof m?.away_right_when_even_index === 'number' ? (m.away_right_when_even_index as 0 | 1) : 0;

      if (!s) {
        const rules = normalizeRules(m?.rules_json);
        s = createServeMatch({
          teams: [
            { players: homePlayers as any, startRightIndex: dbHomeRight },
            { players: awayPlayers as any, startRightIndex: dbAwayRight },
          ],
          startingServerTeam:
            typeof m?.starting_server_team === 'number' ? (m.starting_server_team as 0 | 1) : 0,
          startingServerPlayerIndex:
            typeof m?.starting_server_index === 'number' ? (m.starting_server_index as 0 | 1) : undefined,
          rules,
          metadata: { category: (m?.type as any) || 'MD' },
        });
        await saveMatchState(currentMatchId, serialize(s));
      } else {
        s.teams[0].players = homePlayers as any;
        s.teams[1].players = awayPlayers as any;
        s.teams[0].startRightIndex = dbHomeRight;
        s.teams[1].startRightIndex = dbAwayRight;
        await saveMatchState(currentMatchId, serialize(s));
      }

      setServeState(s);
      setUi(getUiSnapshot(s));
      await loadRecent();

      // 標題列：各局比分
      const sumsForHeader = await fetchGameSums(currentMatchId);
      setHeaderSums(sumsForHeader);

      await reloadMarkers(); // 初始載入場上落點
    } catch (e: any) {
      Alert.alert('載入失敗', String(e?.message || e));
    } finally {
      setLoading(false);
      measureCourtBase();
    }
  }

  async function reloadMarkers() {
    if (!currentMatchId) return;
    const rows: any[] = await listRecentRallies(currentMatchId, 200);
    const ms: Marker[] = rows
      .map(r => {
        const rx = r.route_end_rx ?? r.route_start_rx;
        const ry = r.route_end_ry ?? r.route_start_ry;
        if (rx == null || ry == null) return null;
        const kind: 'win' | 'loss' = r.winner_side === 'home' ? 'win' : 'loss';
        return { id: r.id, rx, ry, kind, meta: JSON.parse(r.meta_json || '{}'), game: Number(r.game_index || 0) };
      })
      .filter(Boolean) as Marker[];
    setMarkers(ms);
  }

  function normalizeRules(json: string | null | undefined): RuleConfig {
    try {
      const r = json ? JSON.parse(json) : {};
      const pointsToWin = r.pointsToWin ?? r.pointsPerGame ?? 21;
      const winBy = r.deuce === false ? 1 : r.winBy ?? 2;
      const cap = r.cap ?? 30;
      const bestOf = r.bestOf ?? 3;
      return { pointsToWin, winBy, cap, bestOf };
    } catch {
      return { pointsToWin: 21, winBy: 2, cap: 30, bestOf: 3 };
    }
  }

  if (!currentMatchId) {
    return (
      <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center', padding: 20 }}>
        <Text style={{ fontSize: 16, marginBottom: 8 }}>尚未選擇場次</Text>
        <Text style={{ color: '#666', textAlign: 'center' }}>
          請先在賽事/場次頁面建立並選取一個場次，再回到此頁記錄。
        </Text>
      </View>
    );
  }

  function decideWinInTap(e: TapEvent): boolean {
    return e.side === 'away';
  }

  const openPanel = (
    isWin: boolean,
    zone: Zone,
    tap: TapEvent,
    defaults: Partial<any>,
    route?: { start: Point; end: Point },
  ) => {
    if (tap?.point) setFocus({ x: tap.point.x, y: tap.point.y });
    setPanel({ isWin, zone, tapPoint: tap.point, norm: tap.norm, meta: { ...defaults }, route });
  };

  const onTap = (e: TapEvent) => {
    if (mode === 'tap') {
      const isWin = decideWinInTap(e);
      const pointRoute = { start: e.point, end: e.point };
      if (e.zone === 'out')
        openPanel(
          isWin,
          'out',
          e,
          isWin ? { forceType: '主動得分', errorReason: undefined } : { forceType: '主動失誤', errorReason: '出界' },
          pointRoute,
        );
      else openPanel(isWin, e.zone, e, isWin ? { forceType: '主動得分' } : { forceType: '主動失誤' }, pointRoute);
    } else {
      if (!routeStart) {
        setRouteStart(e.point);
        setRouteStartNorm(e.norm ?? null);
        setRouteHover(null);
      } else {
        const start = routeStart, end = e.point;
        const startNorm = routeStartNorm;
        let isWin = false;
        if (startNorm && e.norm) {
          const startUpper = startNorm.y < 0.5;
          const endLower = e.norm.y > 0.5;
          isWin = startUpper && endLower && e.inBounds;
        }
        const defaults = isWin
          ? { forceType: '主動得分' }
          : { forceType: '主動失誤', errorReason: e.inBounds ? undefined : '出界' };
        openPanel(isWin, e.inBounds ? (e.zone as Zone) : 'out', e, defaults, { start, end });
        setRouteStart(null);
        setRouteStartNorm(null);
        setRouteHover(null);
      }
    }
  };

  const onPressMarker = (id: string) => {
    const m = markers.find(x => x.id === id);
    if (!m) return;
    setMarkerSheet({ visible: true, data: { id: m.id, kind: m.kind, meta: m.meta } });
  };

  async function rebuildServeFromDB() {
    const m = await getMatch(currentMatchId!);
    const players = await getMatchPlayers(currentMatchId!);
    const homePlayers: [any, any] = [
      { id: 'A0', name: players.find(p => p.side === 'home' && p.idx === 0)?.name || '主#1' },
      { id: 'A1', name: players.find(p => p.side === 'home' && p.idx === 1)?.name || '主#2' },
    ];
    const awayPlayers: [any, any] = [
      { id: 'B0', name: players.find(p => p.side === 'away' && p.idx === 0)?.name || '客#1' },
      { id: 'B1', name: players.find(p => p.side === 'away' && p.idx === 1)?.name || '客#2' },
    ];
    const dbHomeRight =
      typeof m?.home_right_when_even_index === 'number' ? (m.home_right_when_even_index as 0 | 1) : 0;
    const dbAwayRight =
      typeof m?.away_right_when_even_index === 'number' ? (m.away_right_when_even_index as 0 | 1) : 0;
    const rules = normalizeRules(m?.rules_json);

    let s = createServeMatch({
      teams: [
        { players: homePlayers as any, startRightIndex: dbHomeRight },
        { players: awayPlayers as any, startRightIndex: dbAwayRight },
      ],
      startingServerTeam:
        typeof m?.starting_server_team === 'number' ? (m.starting_server_team as 0 | 1) : 0,
      startingServerPlayerIndex:
        typeof m?.starting_server_index === 'number' ? (m.starting_server_index as 0 | 1) : undefined,
      rules,
      metadata: { category: (m?.type as any) || 'MD' },
    });

    const all = await listRalliesOrdered(currentMatchId!);
    for (const r of all) {
      const winTeam = r.winner_side === 'home' ? 0 : 1;
      s = nextRally(s, winTeam);
    }
    await saveMatchState(currentMatchId!, serialize(s));
    setServeState(s);
    setUi(getUiSnapshot(s));
    try {
      publishLiveState(currentMatchId!, getUiSnapshot(s));
    } catch {}
  }

  async function handleDeleteRally(id: string) {
    try {
      await deleteRally(id);
      setMarkerSheet({ visible: false, data: null });
      await reloadMarkers();
      await loadRecent();
      await rebuildServeFromDB();
    } catch (e: any) {
      Alert.alert('刪除失敗', String(e?.message || e));
    }
  }

  async function undoLast() {
    const last = await getLastRally(currentMatchId!);
    if (!last) return Alert.alert('提示', '沒有可撤銷的記錄');
    await handleDeleteRally(last.id);
  }

  const fetchGameSums = React.useCallback(async (mid: string): Promise<GameSum[]> => {
    try {
      if (BACKEND === 'supabase') {
        const { data, error } = await supa
          .from('games')
          .select('index_no,home_score,away_score,winner_team')
          .eq('match_id', mid)
          .order('index_no', { ascending: true });
        if (error) throw error;
        return (data || []).map(r => ({
          i: Number(r.index_no || 0),
          home: Number(r.home_score || 0),
          away: Number(r.away_score || 0),
          winner: (r.winner_team == null ? null : Number(r.winner_team)) as 0 | 1 | null,
        }));
      }
      const db = await openDB();
      const [res] = await db.executeSql(
        'SELECT index_no,home_score,away_score,winner_team FROM games WHERE match_id=? ORDER BY index_no ASC',
        [mid],
      );
      const out: GameSum[] = [];
      for (let i = 0; i < res.rows.length; i++) {
        const r = res.rows.item(i);
        out.push({
          i: Number(r.index_no || 0),
          home: Number(r.home_score || 0),
          away: Number(r.away_score || 0),
          winner: (r.winner_team == null ? null : Number(r.winner_team)) as 0 | 1 | null,
        });
      }
      return out;
    } catch {
      return [];
    }
  }, []);

  const savePanel = async () => {
    if (!panel || !serveState) return;
    try {
      const winnerSide: Side = panel.isWin ? 'home' : 'away';

      await addRecord({
        gameIndex: serveState.currentGameIndex + 1,
        rallyNo: records.filter(r => r.gameIndex === serveState.currentGameIndex + 1).length + 1,
        winnerSide,
        endZone: panel.zone,
        route: panel.route ?? (panel.tapPoint ? { start: panel.tapPoint, end: panel.tapPoint } : undefined),
        routeNorm: panel.norm ? { start: panel.norm, end: panel.norm } : undefined,
        meta: panel.meta,
      });

      const beforeIdx = serveState.currentGameIndex;
      const next = nextRally({ ...serveState }, winnerSide === 'home' ? 0 : 1);
      setServeState(next);
      setUi(getUiSnapshot(next));
      try {
        publishLiveState(currentMatchId!, getUiSnapshot(next));
      } catch {}

      // 先算出是否結束一局
if (next.currentGameIndex > beforeIdx) {
// 局剛結束：用「上一局」的分數 upsert
const ended = next.games[beforeIdx];
const endedScore = ended.points as [number, number];

// 可保留你的提示彈窗...
setEndModal({
type: (() => {
const wonA = next.games.filter(x => x.winner === 0).length;
const wonB = next.games.filter(x => x.winner === 1).length;
const need = Math.floor((next.rules.bestOf || 3) / 2) + 1;
return (wonA >= need || wonB >= need) ? 'match' : 'game';
})(),
gameIndex: beforeIdx + 1,
score: endedScore,
});
setIntervalShownForGame(null);
setDeciderSwitchShownForGame(null);

// 這裡「正確把上一局」寫進 games
await upsertGameSummary({
matchId: currentMatchId!,
gameIndex: beforeIdx + 1,
home: endedScore[0],
away: endedScore[1],
winnerTeam: ended.winner ?? null,
intervalTaken: !!ended.intervalTaken,
deciderSwitched: !!ended.deciderSidesSwitched,
});

} else {
// 局尚未結束：更新「當前局」分數
const idx = next.currentGameIndex;
const cur = next.games[idx];
const curScore = cur.points as [number, number];

// 可保留你的技術暫停/換邊提示...
if (cur.intervalTaken && intervalShownForGame !== idx) {
Alert.alert('技術暫停', '已達技術暫停分數，請暫停與休息。');
setIntervalShownForGame(idx);
}
if (cur.deciderSidesSwitched && deciderSwitchShownForGame !== idx) {
Alert.alert('換邊提示', '決勝局中場換邊，請注意場地交換。');
setDeciderSwitchShownForGame(idx);
}

await upsertGameSummary({
matchId: currentMatchId!,
gameIndex: idx + 1,
home: curScore[0],
away: curScore[1],
winnerTeam: cur.winner ?? null,
intervalTaken: !!cur.intervalTaken,
deciderSwitched: !!cur.deciderSidesSwitched,
});
}



// 之後再做 saveMatchState 與畫面刷新
await saveMatchState(currentMatchId!, serialize(next));

// 更新標題列各局分數 + 重新載入場上落點 + 若有開啟記錄面板也刷新
const sumsForHeader = await fetchGameSums(currentMatchId!);
setHeaderSums(sumsForHeader);
await reloadMarkers();
if (recSheetOpen) await refreshRecordsSheetData();

      // 重新載入場上落點（即時刷新）
      await reloadMarkers();

      // 若記錄 Sheet 正開著也刷新
      if (recSheetOpen) {
        await refreshRecordsSheetData();
      }

      setPanel(null);
      setShiftY(0);
      setFocus(null);
    } catch (e: any) {
      Alert.alert('儲存失敗', String(e?.message || e));
    }
  };

  const servingTeam = ui?.servingTeam ?? 0;
  const serverTeam = ui?.server?.team ?? 0;
  const serverIdx0 = ui?.server?.index ?? 0;
  const serverCourt = ui?.server?.court === 'R' ? '右' : '左';
  const receiverTeam = ui?.receiver?.team ?? 1;
  const receiverIdx0 = ui?.receiver?.index ?? 0;
  const scoreA = ui?.scoreA ?? 0;
  const scoreB = ui?.scoreB ?? 0;

  const posA = ui?.positions?.teamA, posB = ui?.positions?.teamB;
  const A_right = typeof posA?.right === 'number' ? serveState?.teams?.[0]?.players?.[posA.right]?.name : '';
  const A_left  = typeof posA?.left  === 'number' ? serveState?.teams?.[0]?.players?.[posA.left]?.name : '';
  const B_right = typeof posB?.right === 'number' ? serveState?.teams?.[1]?.players?.[posB.right]?.name : '';
  const B_left  = typeof posB?.left  === 'number' ? serveState?.teams?.[1]?.players?.[posB.left]?.name : '';

  const overlayProps = {
    awayRight: A_right || '',
    awayLeft:  A_left  || '',
    homeRight: B_right || '',
    homeLeft:  B_left  || '',
    server: ui?.server ? { team: (ui.server.team === 0 ? 1 : 0) as 0|1, index: ui.server.index as 0|1 } : undefined,
    receiver: ui?.receiver ? { team: (ui.receiver.team === 0 ? 1 : 0) as 0|1, index: ui.receiver.index as 0|1 } : undefined,
    positions: {
      A: { right: (posB?.right ?? 0) as 0|1, left: (posB?.left ?? 1) as 0|1 },
      B: { right: (posA?.right ?? 0) as 0|1, left: (posA?.left ?? 1) as 0|1 },
    },
    opacity: 0.85,
  } as const;

  // 打開「記錄」Sheet
  const openRecordsSheet = async () => {
    if (!currentMatchId) return;
    setRecSheetOpen(true);
    setRecSheetLoading(true);
    await refreshRecordsSheetData();
    setRecSheetLoading(false);
  };

  // 刷新記錄 Sheet 的資料（供開啟與保存後更新）
  const refreshRecordsSheetData = async () => {
    if (!currentMatchId) return;
    const [rows, sums] = await Promise.all([listRalliesOrdered(currentMatchId), fetchGameSums(currentMatchId)]);
    const list = rows.map((r: any) => {
      let meta: any = {};
      try { meta = JSON.parse(r.meta_json || '{}'); } catch {}
      return {
        id: r.id as string,
        game: Number(r.game_index || 0),
        no: Number(r.rally_no || 0),
        win: r.winner_side === 'home',
        zone: String(r.end_zone || ''),
        meta,
        createdAt: String(r.created_at || ''),
      };
    });
    setRecSheetRows(list);
    setGameSums(sums);
    setHeaderSums(sums);
  };

  // 目前局（1-based）
  const currentGameNo = (serveState?.currentGameIndex ?? 0) + 1;

  // 場上落點：依 courtFilter 篩選
  const shownCourtMarkers = React.useMemo(() => {
    if (courtFilter === 'current') return markers.filter(m => m.game === currentGameNo);
    return markers;
  }, [markers, courtFilter, currentGameNo]);

  // Sheet：決定要畫哪些局（全部/本局）
  const gamesToRender = React.useMemo(() => {
    if (recFilter === 'current') return gameSums.filter(g => g.i === currentGameNo);
    return gameSums;
  }, [gameSums, recFilter, currentGameNo]);

  return (
    <View style={{ flex: 1 }}>
      {/* 可位移內容（頂部 + 球場） */}
      <View style={{ flex: 1, transform: [{ translateY: -shiftY }] }}>
        <View
          style={{
            paddingHorizontal: 12,
            paddingTop: 8,
            paddingBottom: 6,
            backgroundColor: '#fafafa',
            borderBottomWidth: 1,
            borderColor: '#eee',
          }}
        >
          <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' }}>
            <Text style={{ fontSize: 16, fontWeight: '600' }}>記錄模式（{isSingles ? '單打' : '雙打'}）</Text>
            <View style={{ flexDirection: 'row', flexWrap: 'wrap' }}>
              <Pressable
                onPress={undoLast}
                style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#455a64', borderRadius: 8, marginRight: 8 }}
              >
                <Text style={{ color: '#fff' }}>撤銷上一筆</Text>
              </Pressable>
              <Pressable
                onPress={() => navigation.navigate('Analysis', { matchId: currentMatchId })}
                style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#1976d2', borderRadius: 8, marginRight: 8 }}
              >
                <Text style={{ color: '#fff' }}>分析</Text>
              </Pressable>
              <Pressable
                onPress={openRecordsSheet}
                style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#009688', borderRadius: 8, marginRight: 8 }}
              >
                <Text style={{ color: '#fff' }}>記錄</Text>
              </Pressable>
              {/* 場上落點篩選（全部 / 本局） */}
              <Pressable
                onPress={() => setCourtFilter(f => (f === 'all' ? 'current' : 'all'))}
                style={{ paddingVertical: 6, paddingHorizontal: 10, borderRadius: 8, borderWidth: 1, borderColor: '#1976d2', marginLeft: 8 }}
              >
                <Text style={{ color: '#1976d2' }}>{courtFilter === 'all' ? '全部落點' : `本局落點(第${currentGameNo}局)`}</Text>
              </Pressable>
            </View>
          </View>

          {/* 標題列顯示：各局比分＋勝方；若沒資料則 fallback 成當局比分 */}
          <Text style={{ color: '#555', marginTop: 6 }}>
            發球方：{(ui?.servingTeam ?? 0) === 0 ? '主隊' : '客隊'}，發：
            {serveState?.teams?.[ui?.server?.team ?? 0]?.players?.[ui?.server?.index ?? 0]?.name || ''}（
            {ui?.server?.court === 'R' ? '右' : '左'}），接：
            {serveState?.teams?.[ui?.receiver?.team ?? 1]?.players?.[ui?.receiver?.index ?? 0]?.name || ''}，
            {headerSumsText || `第${currentGameNo}局 ${ui?.scoreA ?? 0}:${ui?.scoreB ?? 0}`}
          </Text>
        </View>

        <View ref={courtWrapRef} onLayout={measureCourtBase} style={{ flex: 1 }}>
          <Court
            orientation={orientation}
            singles={isSingles}
            mode={mode}
            routeStart={routeStart}
            routeHover={routeHover}
            onHover={setRouteHover}
            onTap={onTap}
            markers={shownCourtMarkers}
            onPressMarker={onPressMarker}
            overlay={{
              awayRight: serveState?.teams?.[0]?.players?.[ui?.positions?.teamA?.right ?? 0]?.name || '',
              awayLeft: serveState?.teams?.[0]?.players?.[ui?.positions?.teamA?.left ?? 1]?.name || '',
              homeRight: serveState?.teams?.[1]?.players?.[ui?.positions?.teamB?.right ?? 0]?.name || '',
              homeLeft: serveState?.teams?.[1]?.players?.[ui?.positions?.teamB?.left ?? 1]?.name || '',
              server: ui?.server ? { team: (ui.server.team === 0 ? 1 : 0) as 0|1, index: ui.server.index as 0|1 } : undefined,
              receiver: ui?.receiver ? { team: (ui.receiver.team === 0 ? 1 : 0) as 0|1, index: ui.receiver.index as 0|1 } : undefined,
              positions: {
                A: { right: (ui?.positions?.teamB?.right ?? 0) as 0|1, left: (ui?.positions?.teamB?.left ?? 1) as 0|1 },
                B: { right: (ui?.positions?.teamA?.right ?? 0) as 0|1, left: (ui?.positions?.teamA?.left ?? 1) as 0|1 },
              },
              opacity: 0.85,
            }}
            focusPoint={focus}
          />
        </View>
      </View>

      {/* MetaPanel/MarkerSheet（略） */}
      <MetaPanel
        visible={!!panel}
        isWin={!!panel?.isWin}
        meta={panel?.meta || {}}
        onChange={m => setPanel(p => (p ? { ...p, meta: m } : p))}
        onCancel={() => { setPanel(null); setShiftY(0); setFocus(null); }}
        onSave={savePanel}
        showErrorReason={!panel?.isWin}
        players={[
          { id: 'A0', name: serveState?.teams?.[0]?.players?.[0]?.name || '主#1' },
          { id: 'A1', name: serveState?.teams?.[0]?.players?.[1]?.name || '主#2' },
          { id: 'B0', name: serveState?.teams?.[1]?.players?.[0]?.name || '客#1' },
          { id: 'B1', name: serveState?.teams?.[1]?.players?.[1]?.name || '客#2' },
        ]}
        showLastHitter={mode === 'route'}
        options={{ shotTypes, errorReasons }}
        onMeasure={setPanelH}
      />
      <MarkerSheet
        visible={markerSheet.visible}
        data={markerSheet.data}
        onClose={() => setMarkerSheet({ visible: false, data: null })}
        onDelete={async id => { await handleDeleteRally(id); setShiftY(0); setFocus(null); }}
      />

      {/* 浮動記錄 Sheet */}
      <Modal visible={recSheetOpen} transparent animationType="slide" onRequestClose={() => setRecSheetOpen(false)}>
        <View style={{ flex:1, backgroundColor:'rgba(0,0,0,0.35)', justifyContent:'flex-end' }}>
          <View style={{ backgroundColor:'#1e1e1e', borderTopLeftRadius:16, borderTopRightRadius:16, padding:12, maxHeight:'80%' }}>
            <View style={{ flexDirection:'row', justifyContent:'space-between', alignItems:'center', marginBottom:8 }}>
              <Text style={{ color:'#fff', fontSize:16, fontWeight:'600' }}>全部記錄</Text>
              <Pressable onPress={()=>setRecSheetOpen(false)} style={{ padding:8 }}>
                <Text style={{ color:'#90caf9' }}>關閉</Text>
              </Pressable>
            </View>

            {/* 固定：篩選列 */}
            <View style={{ flexDirection:'row', marginBottom:8 }}>
              <Pressable onPress={()=>setRecFilter('all')} style={{ paddingVertical:6, paddingHorizontal:10, borderRadius:14, borderWidth:1, borderColor: recFilter==='all'?'#90caf9':'#444', backgroundColor: recFilter==='all'?'rgba(144,202,249,0.15)':'#222', marginRight:8 }}>
                <Text style={{ color:'#fff' }}>全部落點</Text>
              </Pressable>
              <Pressable onPress={()=>setRecFilter('current')} style={{ paddingVertical:6, paddingHorizontal:10, borderRadius:14, borderWidth:1, borderColor: recFilter==='current'?'#90caf9':'#444', backgroundColor: recFilter==='current'?'rgba(144,202,249,0.15)':'#222' }}>
                <Text style={{ color:'#fff' }}>本局落點（第{(serveState?.currentGameIndex ?? 0) + 1}局）</Text>
              </Pressable>
            </View>

            {/* 固定：各局總分標籤 */}
            <View style={{ flexDirection:'row', flexWrap:'wrap', marginBottom:8 }}>
              {gameSums.map(g => {
                const winClr = g.winner === 0 ? '#1976d2' : g.winner === 1 ? '#d32f2f' : '#999';
                return (
                  <View key={'sum-tag-'+g.i} style={{ paddingVertical:4, paddingHorizontal:8, borderRadius:12, borderWidth:1, borderColor:'#333', backgroundColor:'#222', marginRight:6, marginBottom:6 }}>
                    <Text style={{ color:'#fff' }}>G{g.i} {g.home}-{g.away}{g.winner!=null ? (g.winner===0 ? '（主）':'（客）') : ''}</Text>
                    <View style={{ position:'absolute', right:-2, top:-2, width:8, height:8, borderRadius:4, backgroundColor: winClr }} />
                  </View>
                );
              })}
            </View>

            {recSheetLoading ? (
              <View style={{ paddingVertical:30, alignItems:'center' }}>
                <ActivityIndicator color="#90caf9" />
              </View>
            ) : (
              <ScrollView style={{ maxHeight:'100%' }} contentContainerStyle={{ paddingBottom: 10 }}>
                {(recFilter==='current' ? gameSums.filter(g=>g.i===(serveState?.currentGameIndex??0)+1) : gameSums).map(g => {
                  const rowsOfGame = recSheetRows.filter(r => r.game === g.i);
                  return (
                    <View key={'section-'+g.i} style={{ marginBottom: 12 }}>
                      <TrendChart title={`第 ${g.i} 局趨勢`} rows={rowsOfGame.map(r => ({ win: r.win }))} />
                      {rowsOfGame.map(item => {
                        const color = item.win ? '#1976d2' : '#d32f2f';
                        const meta = item.meta || {};
                        return (
                          <View key={item.id} style={{ paddingVertical:10, paddingHorizontal:12, borderRadius:10, borderWidth:1, borderColor:'#333', backgroundColor:'#222', marginBottom:8 }}>
                            <View style={{ flexDirection:'row', justifyContent:'space-between', alignItems:'center' }}>
                              <Text style={{ color:'#fff', fontWeight:'600' }}>第{item.game}局 #{item.no}</Text>
                              <Text style={{ color }}>{item.win ? '得分' : '失分'}</Text>
                            </View>
                            <Text style={{ color:'#ddd', marginTop:4 }}>
                              區 {item.zone} · {meta.shotType || '—'} {meta.forceType ? `· ${meta.forceType}` : ''} {meta.errorReason ? `· ${meta.errorReason}` : ''}
                            </Text>
                            {!!item.createdAt && <Text style={{ color:'#888', marginTop:4 }}>{new Date(item.createdAt).toLocaleString()}</Text>}
                          </View>
                        );
                      })}
                    </View>
                  );
                })}
              </ScrollView>
            )}
          </View>
        </View>
      </Modal>
    </View>
  );
}

/* 折線圖（每 5 分顯示刻度 + 最後分數；加滿版水平線便於閱讀） */
function TrendChart({ title, rows }: { title: string; rows: Array<{ win: boolean }> }) {
  const [w, setW] = React.useState(0);
  const H = 160;
  const PAD = 28;

  const series = React.useMemo(() => {
    const home: number[] = [0];
    const away: number[] = [0];
    let h = 0, a = 0;
    for (let i = 0; i < rows.length; i++) { if (rows[i].win) h++; else a++; home.push(h); away.push(a); }
    const maxY = Math.max(1, h, a);
    return { home, away, maxY };
  }, [rows]);

  const buildPath = (vals: number[], W: number, H: number, maxY: number) => {
    const plotW = Math.max(1, W - PAD * 2);
    const plotH = Math.max(1, H - PAD * 2);
    const n = vals.length; if (n <= 1) return '';
    const stepX = plotW / (n - 1);
    const yOf = (v: number) => PAD + (plotH * (1 - v / maxY));
    let d = `M ${PAD} ${yOf(vals[0])}`;
    for (let i = 1; i < n; i++) {
      const x = PAD + i * stepX;
      const y = yOf(vals[i]);
      d += ` L ${x} ${y}`;
    }
    return d;
  };

  // 刻度：0、5、10、…、最後分數（若不是 5 的倍數也要顯示）
  const ticks = React.useMemo(() => {
    const arr: number[] = [];
    for (let v = 0; v <= series.maxY; v += 5) arr.push(v);
    if (arr[arr.length - 1] !== series.maxY) arr.push(series.maxY);
    return arr;
  }, [series.maxY]);

  const yOf = (v: number) => {
    const plotH = Math.max(1, H - PAD * 2);
    return PAD + (plotH * (1 - v / series.maxY));
  };

  return (
    <View onLayout={e => setW(Math.floor(e.nativeEvent.layout.width))} style={{ marginBottom: 10, padding: 10, borderWidth: 1, borderColor: '#333', borderRadius: 10, backgroundColor: '#222' }}>
      <Text style={{ color:'#fff', fontWeight:'600', marginBottom: 8 }}>{title}</Text>
      {w <= 0 ? null : (
        <Svg width={w} height={H}>
          {/* 座標軸 */}
          <G>
            <Line x1={PAD} y1={PAD} x2={PAD} y2={H - PAD} stroke="#444" strokeWidth={1} />
            <Line x1={PAD} y1={H - PAD} x2={w - PAD} y2={H - PAD} stroke="#444" strokeWidth={1} />
          </G>
          {/* Y 軸刻度 + 滿版水平線 */}
          <G>
            {ticks.map(v => {
              const y = yOf(v);
              return (
                <G key={'tick-'+v}>
                  {/* 滿版水平線（0 線較醒目） */}
                  <Line x1={PAD} y1={y} x2={w - PAD} y2={y} stroke="#3a3a3a" strokeWidth={1} opacity={v === 0 ? 0.55 : 0.28} />
                  {/* 刻度文字 */}
                  <SvgText x={PAD - 6} y={y + 4} fill="#888" fontSize={10} textAnchor="end">{v}</SvgText>
                </G>
              );
            })}
          </G>
          {/* 折線 */}
          <Path d={buildPath(series.home, w, H, series.maxY)} stroke="#1976d2" strokeWidth={2} fill="none" />
          <Path d={buildPath(series.away, w, H, series.maxY)} stroke="#d32f2f" strokeWidth={2} fill="none" />
        </Svg>
      )}
    </View>
  );
}

/* MetaPanel/Group/ChipList 與前版相同 */
function MetaPanel({
  visible,
  isWin,
  meta,
  onChange,
  onCancel,
  onSave,
  showErrorReason,
  players,
  showLastHitter,
  options,
  onMeasure,
}: {
  visible: boolean;
  isWin: boolean;
  meta: any;
  onChange: (m: any) => void;
  onCancel: () => void;
  onSave: () => void;
  showErrorReason: boolean;
  players: Array<{ id: string; name?: string }>;
  showLastHitter?: boolean;
  options: { shotTypes: string[]; errorReasons: string[] };
  onMeasure?: (h: number) => void;
}) {
  const forceOptions = isWin ? ['主動得分', '對手失誤'] : ['主動失誤', '受迫失誤'];
  return (
    <Modal visible={visible} transparent animationType="slide" onRequestClose={onCancel}>
      <View style={{ flex: 1, backgroundColor: 'rgba(0,0,0,0.35)', justifyContent: 'flex-end' }}>
        <View style={{ backgroundColor: '#fff', borderTopLeftRadius: 16, borderTopRightRadius: 16, padding: 16, maxHeight: '45%' }} onLayout={e => onMeasure?.(e.nativeEvent.layout.height)}>
          <Text style={{ fontSize: 16, fontWeight: '600', marginBottom: 8 }}>{isWin ? '得分' : '失分'}選項</Text>
          <Group title="球種">
            <ChipList options={options.shotTypes} value={meta.shotType} onSelect={v => onChange({ ...meta, shotType: v === meta.shotType ? undefined : v })} />
          </Group>
          <Group title="正手/反手">
            <ChipList options={['正手', '反手']} value={meta.hand} onSelect={v => onChange({ ...meta, hand: v as any })} />
          </Group>
          <Group title={isWin ? '是否主動得分' : '是否主動失誤'}>
            <ChipList options={['主動得分', '對手失誤', '主動失誤', '受迫失誤']} value={meta.forceType} onSelect={v => onChange({ ...meta, forceType: v })} />
          </Group>
          {!isWin && showErrorReason && (
            <Group title="失誤原因">
              <ChipList options={options.errorReasons as any} value={meta.errorReason} onSelect={v => onChange({ ...meta, errorReason: v })} />
            </Group>
          )}
          {showLastHitter && (
            <Group title="最後擊球選手">
              <View style={{ flexDirection: 'row', flexWrap: 'wrap' }}>
                {players.map(p => (
                  <Pressable key={p.id} onPress={() => onChange({ ...meta, lastHitter: meta.lastHitter === p.id ? undefined : p.id })} style={{ paddingVertical: 6, paddingHorizontal: 10, borderRadius: 14, borderWidth: 1, borderColor: meta.lastHitter === p.id ? '#1976d2' : '#ccc', backgroundColor: meta.lastHitter === p.id ? 'rgba(25,118,210,0.1)' : '#fff', marginRight: 8, marginBottom: 8 }}>
                    <Text>{p.name || p.id}</Text>
                  </Pressable>
                ))}
              </View>
            </Group>
          )}
          <View style={{ flexDirection: 'row', justifyContent: 'flex-end', marginTop: 12 }}>
            <Pressable onPress={onCancel} style={{ padding: 12, marginRight: 8 }}>
              <Text>取消</Text>
            </Pressable>
            <Pressable onPress={onSave} style={{ padding: 12, backgroundColor: '#1976d2', borderRadius: 8 }}>
              <Text style={{ color: '#fff' }}>儲存</Text>
            </Pressable>
          </View>
        </View>
      </View>
    </Modal>
  );
}
function Group({ title, children }: any) {
  return (
    <View style={{ marginBottom: 10 }}>
      <Text style={{ marginBottom: 6, color: '#333' }}>{title}</Text>
      {children}
    </View>
  );
}
function ChipList({ options, value, onSelect }: { options: string[]; value?: string; onSelect: (v: string) => void }) {
  return (
    <View style={{ flexDirection: 'row', flexWrap: 'wrap' }}>
      {options.map(opt => (
        <Pressable key={opt} onPress={() => onSelect(opt)} style={{ paddingVertical: 6, paddingHorizontal: 10, borderRadius: 14, borderWidth: 1, borderColor: value === opt ? '#1976d2' : '#ccc', backgroundColor: value === opt ? 'rgba(25,118,210,0.1)' : '#fff', marginRight: 8, marginBottom: 8 }}>
          <Text>{opt}</Text>
        </Pressable>
      ))}
    </View>
  );
}ezbmt-tracked/src/screens/SpeedScreen.tsx
 
import React from 'react';
import { View, Text, Pressable, Switch } from 'react-native';
import Court from '../components/Court';
import type { Orientation, Point } from '../types';
import { insertSpeedSession, insertSpeedPoints } from '../db';

const FULL_WID = 6.1;  // 直式雙打外框寬（公尺）
const FULL_LEN = 13.4; // 直式雙打外框長（公尺）

export default function SpeedScreen() {
const [orientation] = React.useState<Orientation>('portrait'); // 以直式為主；Court 內部會把 landscape 轉回直式基準運算
const [singles, setSingles] = React.useState(false);          // 只影響繪圖，不影響距離（距離換算固定以雙打外框）
const [routeStart, setRouteStart] = React.useState<Point | null>(null);
const [routeHover, setRouteHover] = React.useState<Point | null>(null);

const [startNorm, setStartNorm] = React.useState<{ x: number; y: number } | null>(null);
const [endNorm, setEndNorm] = React.useState<{ x: number; y: number } | null>(null);

const [autoStart, setAutoStart] = React.useState(true);
const [running, setRunning] = React.useState(false);
const [startTs, setStartTs] = React.useState<number | null>(null);
const [stopTs, setStopTs] = React.useState<number | null>(null);

const clearAll = () => {
setRouteStart(null);
setRouteHover(null);
setStartNorm(null);
setEndNorm(null);
setStartTs(null);
setStopTs(null);
setRunning(false);
};

const onTap = (e: any) => {
// e: TapEvent（來自 Court）
if (!routeStart) {
setRouteStart(e.point);
setRouteHover(null);
setStartNorm(e.norm ?? null);
setEndNorm(null);
setStopTs(null);
if (autoStart) {
setStartTs(Date.now());
setRunning(true);
}
} else {
setRouteHover(e.point);
setEndNorm(e.norm ?? null);
if (running) {
setStopTs(Date.now());
setRunning(false);
} else if (autoStart && startTs == null) {
// 理論上不會進來；保底：若使用者關閉/打開開關後第一次點才起
setStartTs(Date.now());
setRunning(true);
}
}
};

const onHover = (p: Point | null) => {
if (routeStart && !endNorm) setRouteHover(p || null);
};

// 手動控制計時
const manualStart = () => {
setStartTs(Date.now());
setStopTs(null);
setRunning(true);
};
const manualStop = () => {
if (!running) return;
setStopTs(Date.now());
setRunning(false);
};

// 兩點距離（公尺）：norm 是以直式雙打外框（6.1×13.4）為基準
const distanceM = React.useMemo(() => {
if (!startNorm || !endNorm) return 0;
const dx = (endNorm.x - startNorm.x) * FULL_WID;
const dy = (endNorm.y - startNorm.y) * FULL_LEN;
return Math.sqrt(dx * dx + dy * dy);
}, [startNorm, endNorm]);

// 經過時間（秒）
const elapsedSec = React.useMemo(() => {
if (startTs == null) return 0;
const end = (stopTs ?? (running ? Date.now() : null));
if (!end) return 0;
return Math.max(0, (end - startTs) / 1000);
}, [startTs, stopTs, running]);

const ms = distanceM > 0 && elapsedSec > 0 ? distanceM / elapsedSec : 0;
const kmh = ms * 3.6;

return (
<View style={{ flex: 1 }}>
{/* 頂列：工具 */}
<View style={{ padding: 12, borderBottomWidth: 1, borderColor: '#eee', backgroundColor: '#fafafa' }}>
<View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 6 }}>
<Text style={{ fontSize: 16, fontWeight: '600', marginRight: 12 }}>羽球測速</Text>
<Pressable onPress={clearAll} style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#757575', borderRadius: 8 }}>
<Text style={{ color: '#fff' }}>重置</Text>
</Pressable>
</View>

    <View style={{ flexDirection: 'row', alignItems: 'center' }}>
      <Text style={{ marginRight: 8 }}>單打視覺：</Text>
      <Switch value={singles} onValueChange={setSingles} />
      <Text style={{ marginLeft: 16, marginRight: 8 }}>自動計時（第1點→開始，第2點→停止）：</Text>
      <Switch value={autoStart} onValueChange={setAutoStart} />
      {!autoStart && (
        <View style={{ flexDirection: 'row', marginLeft: 12 }}>
          <Pressable
            onPress={manualStart}
            style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#1976d2', borderRadius: 8, marginRight: 8 }}
          >
            <Text style={{ color: '#fff' }}>開始</Text>
          </Pressable>
          <Pressable
            onPress={manualStop}
            style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#d32f2f', borderRadius: 8 }}
          >
            <Text style={{ color: '#fff' }}>停止</Text>
          </Pressable>
        </View>
      )}
    </View>
  </View>

  {/* 球場與互動 */}
  <View style={{ flex: 1 }}>
    <Court
      orientation={orientation}
      singles={singles}
      mode="route"
      routeStart={routeStart}
      routeHover={routeHover}
      onTap={onTap}
      onHover={onHover}
      markers={[]}
      onPressMarker={undefined}
    />
  </View>

  {/* 結果區 */}
  <View style={{ padding: 12, borderTopWidth: 1, borderColor: '#eee' }}>
    <Text style={{ fontWeight: '600', marginBottom: 6 }}>結果</Text>
    <Text>距離：{distanceM.toFixed(3)} m（以雙打外框 6.1×13.4 m 換算）</Text>
    <Text>時間：{elapsedSec.toFixed(3)} s {running ? '（計時中…）' : ''}</Text>
    <Text style={{ marginTop: 4, fontSize: 16 }}>
      速度：{ms.toFixed(2)} m/s（{kmh.toFixed(1)} km/h）
    </Text>
    <Text style={{ color: '#666', marginTop: 6 }}>
      使用方式：在球場上點下「擊球點」與「落點」。若開啟自動計時，第一次點擊即開始、第二次點擊即停止；關閉自動計時時，請用下方按鈕手動開始/停止。
    </Text>
  </View>
</View>
);
}ezbmt-tracked/src/screens/SettingsScreen.tsx
 
import React from 'react';
import { View, Text, FlatList, TextInput, Pressable, Alert, Switch } from 'react-native';
import { listDictionary, upsertDictionary, deleteDictionary } from '../db';

const C = {
bg: '#111',
card: '#222',
border: '#333',
field: '#111',
fieldBorder: '#444',
text: '#fff',
sub: '#ddd',
hint: '#888',
};

export default function SettingsScreen() {
const [kindShot, setKindShot] = React.useState(true); // true=shot_type, false=error_reason
const [items, setItems] = React.useState<Array<{id:string;label:string;order_no:number}>>([]);
const [label, setLabel] = React.useState('');
const [order, setOrder] = React.useState('0');

const load = React.useCallback(async () => {
const k = kindShot ? 'shot_type' : 'error_reason';
const rows = await listDictionary(k as any);
setItems(rows as any);
}, [kindShot]);

React.useEffect(()=>{ load(); }, [load]);

const add = async () => {
if (!label.trim()) return;
try {
await upsertDictionary({ kind: kindShot ? 'shot_type':'error_reason', label: label.trim(), order_no: Number(order)||0 });
setLabel(''); setOrder('0'); load();
} catch (e:any) { Alert.alert('新增失敗', String(e?.message||e)); }
};

const remove = async (id:string) => {
try { await deleteDictionary(id); load(); } catch(e:any){ Alert.alert('刪除失敗', String(e?.message||e)); }
};

const renderItem = ({item}:{item:{id:string;label:string;order_no:number}}) => (
<View style={{ padding:10, borderWidth:1, borderColor:C.border, backgroundColor:C.card, borderRadius:8, marginBottom:8, flexDirection:'row', justifyContent:'space-between', alignItems:'center' }}>
<Text style={{ color: C.text }}>{item.label}（排序 {item.order_no}）</Text>
<Pressable onPress={()=>remove(item.id)} style={{ paddingVertical:6, paddingHorizontal:10, backgroundColor:'#d32f2f', borderRadius:8 }}>
<Text style={{ color:'#fff' }}>刪除</Text>
</Pressable>
</View>
);

return (
<View style={{ flex:1, padding:12, backgroundColor: C.bg }}>
<View style={{ flexDirection:'row', alignItems:'center', marginBottom:8 }}>
<Text style={{ marginRight:8, color: C.text }}>編輯：</Text>
<Text style={{ marginRight:6, color: kindShot?'#90caf9':C.sub }}>球種</Text>
<Switch
value={kindShot}
onValueChange={setKindShot}
trackColor={{ false: '#555', true: '#1976d2' }}
thumbColor="#fff"
/>
<Text style={{ marginLeft:6, color: !kindShot?'#90caf9':C.sub }}>失誤原因</Text>
</View>

  <FlatList
    data={items}
    keyExtractor={(i)=>i.id}
    renderItem={renderItem}
  />

  <View style={{ borderTopWidth:1, borderColor:C.border, paddingTop:10, marginTop:10 }}>
    <Text style={{ fontWeight:'600', marginBottom:6, color: C.text }}>新增</Text>
    <TextInput
      placeholder="名稱（如：切球）"
      placeholderTextColor={C.hint}
      value={label}
      onChangeText={setLabel}
      style={{ borderWidth:1, borderColor:C.fieldBorder, borderRadius:8, paddingHorizontal:10, paddingVertical:8, marginBottom:6, color: C.text, backgroundColor: C.field }}
    />
    <TextInput
      placeholder="排序（數字，小到大）"
      placeholderTextColor={C.hint}
      value={order}
      onChangeText={setOrder}
      keyboardType="number-pad"
      style={{ borderWidth:1, borderColor:C.fieldBorder, borderRadius:8, paddingHorizontal:10, paddingVertical:8, marginBottom:8, width:160, color: C.text, backgroundColor: C.field }}
    />
    <Pressable onPress={add} style={{ backgroundColor:'#1976d2', paddingVertical:10, borderRadius:8, alignItems:'center' }}>
      <Text style={{ color:'#fff' }}>新增項目</Text>
    </Pressable>
  </View>
</View>
);
}ezbmt-tracked/src/screens/AnalysisScreen.tsx
 
import React from 'react';
import { View, Text, Pressable, Alert, ScrollView } from 'react-native';
import { useRoute, useNavigation } from '@react-navigation/native';
import { listRalliesOrdered } from '../db';
import Heatmap from '../components/Heatmap';
import HeatGrid from '../components/HeatGrid';
import ZoneMatrix from '../components/ZoneMatrix';
import SimpleBarChart, { BarRow } from '../components/SimpleBarChart';
import { shareCsv, shareJson } from '../lib/exportPdf';
import { exportPdfReport } from '../lib/export';
import CourtBackground from '../components/CourtBackground';

type Row = {
id: string;
match_id: string;
game_index: number;
rally_no: number;
winner_side: 'home' | 'away';
end_zone: string; // '1'..'6'|'out'
meta_json: string;
route_end_rx?: number | null;
route_end_ry?: number | null;
route_start_rx?: number | null;
route_start_ry?: number | null;
};

export default function AnalysisScreen() {
const route = useRoute<any>();
const navigation = useNavigation<any>();
const matchId = route.params?.matchId as string;

const [rows, setRows] = React.useState<Row[]>([]);
const [loading, setLoading] = React.useState(true);

// Heatmap 尺寸
const [heatW, setHeatW] = React.useState(0);
const [heatH, setHeatH] = React.useState(0);

// 篩選
const [gameFilter, setGameFilter] = React.useState<number | 'ALL'>('ALL');
const [resultFilter, setResultFilter] = React.useState<'ALL'|'WIN'|'LOSS'>('ALL');
const [shotFilter, setShotFilter] = React.useState<string>('ALL');
const [forceFilter, setForceFilter] = React.useState<string>('ALL');
const [reasonFilter, setReasonFilter] = React.useState<string>('ALL');
const [hasRouteOnly, setHasRouteOnly] = React.useState<boolean>(false);

// 視圖切換
const [viewMode, setViewMode] = React.useState<'scatter'|'grid'>('grid');
const [gridSize, setGridSize] = React.useState(20);

React.useEffect(() => {
(async () => {
try {
const rs = await listRalliesOrdered(matchId);
setRows((rs as unknown) as Row[]);
} catch (e: any) {
Alert.alert('載入失敗', String(e && e.message ? e.message : e));
} finally {
setLoading(false);
}
})();
}, [matchId]);

const filtered = React.useMemo(() => {
return rows.filter((r) => {
if (gameFilter !== 'ALL' && r.game_index !== gameFilter) return false;
const meta = safeMeta(r.meta_json);
if (resultFilter === 'WIN' && r.winner_side !== 'home') return false;
if (resultFilter === 'LOSS' && r.winner_side !== 'away') return false;
if (shotFilter !== 'ALL' && (meta.shotType || '') !== shotFilter) return false;
if (forceFilter !== 'ALL' && (meta.forceType || '') !== forceFilter) return false;
if (reasonFilter !== 'ALL' && (meta.errorReason || '') !== reasonFilter) return false;
if (hasRouteOnly) {
const has = (r.route_end_rx != null && r.route_end_ry != null) || (r.route_start_rx != null && r.route_start_ry != null);
if (!has) return false;
}
return true;
});
}, [rows, gameFilter, resultFilter, shotFilter, forceFilter, reasonFilter, hasRouteOnly]);

const points = filtered
.map((r) => {
const rx = (r.route_end_rx != null ? r.route_end_rx : r.route_start_rx);
const ry = (r.route_end_ry != null ? r.route_end_ry : r.route_start_ry);
if (rx == null || ry == null) return null;
return { rx: Number(rx), ry: Number(ry), kind: r.winner_side === 'home' ? 'win' : 'loss' as const };
})
.filter(Boolean) as Array<{ rx: number; ry: number; kind: 'win' | 'loss' }>;

const byZone = groupByZone(filtered);
const byMeta = groupMeta(filtered);
const games = uniq(rows.map(r => r.game_index));
const optsShot = uniq(rows.map(r => safeMeta(r.meta_json).shotType || '')).filter(Boolean);
const optsForce = uniq(rows.map(r => safeMeta(r.meta_json).forceType || '')).filter(Boolean);
const optsReason = uniq(rows.map(r => safeMeta(r.meta_json).errorReason || '')).filter(Boolean);

// 球種聚合（得/失）
const shotAgg: BarRow[] = React.useMemo(() => {
const map = new Map<string, { win:number; loss:number }>();
for (let i=0;i<filtered.length;i++){
const r = filtered[i];
const meta = safeMeta(r.meta_json);
const k = meta.shotType || '未填';
const cur = map.get(k) || { win:0, loss:0 };
if (r.winner_side === 'home') cur.win += 1; else cur.loss += 1;
map.set(k, cur);
}
const arr: BarRow[] = [];
map.forEach((v,k)=>arr.push({ label:k, win:v.win, loss:v.loss }));
arr.sort((a,b)=> (b.win+b.loss) - (a.win+a.loss));
return arr;
}, [filtered]);

// 可回放的 ids（有路徑）
const playableIds = React.useMemo(() => {
return filtered
.filter(r => (r.route_end_rx != null && r.route_end_ry != null) || (r.route_start_rx != null && r.route_start_ry != null))
.map(r => r.id);
}, [filtered]);

function avgRouteLen(rs: Row[]) {
let n = 0, sum = 0;
for (let i = 0; i < rs.length; i++) {
const r = rs[i];
const sx = (r.route_start_rx != null ? Number(r.route_start_rx) : null);
const sy = (r.route_start_ry != null ? Number(r.route_start_ry) : null);
const ex = (r.route_end_rx != null ? Number(r.route_end_rx) : null);
const ey = (r.route_end_ry != null ? Number(r.route_end_ry) : null);
if (sx == null || sy == null || ex == null || ey == null) continue;
const dx = ex - sx;
const dy = ey - sy;
sum += Math.hypot(dx, dy);
n += 1;
}
return n ? (sum / n) : 0;
}

return (
<ScrollView contentContainerStyle={{ padding: 12 }}>
<Text style={{ fontSize: 16, fontWeight: '600', marginBottom: 8 }}>熱區（終點/單擊落點）</Text>

  {/* 篩選列 */}
  <Filters
    games={games}
    gameFilter={gameFilter}
    setGameFilter={setGameFilter}
    resultFilter={resultFilter}
    setResultFilter={setResultFilter}
    shotFilter={shotFilter}
    setShotFilter={setShotFilter}
    forceFilter={forceFilter}
    setForceFilter={setForceFilter}
    reasonFilter={reasonFilter}
    setReasonFilter={setReasonFilter}
    optsShot={optsShot}
    optsForce={optsForce}
    optsReason={optsReason}
  />

  <View style={{ flexDirection:'row', flexWrap:'wrap', alignItems:'center', marginBottom:8 }}>
    <Chip text={'僅含線路：' + (hasRouteOnly ? '開' : '關')} active={hasRouteOnly} onPress={()=>setHasRouteOnly(v=>!v)} />
    <Text style={{ marginLeft: 12, color:'#555' }}>平均路徑長度（相對單位）：{avgRouteLen(filtered).toFixed(3)}</Text>
  </View>

  {/* 視圖切換 */}
  <View style={{ flexDirection:'row', marginBottom:8 }}>
    <Chip text="散點" active={viewMode==='scatter'} onPress={()=>setViewMode('scatter')} />
    <Chip text="熱區" active={viewMode==='grid'} onPress={()=>setViewMode('grid')} />
  </View>

  <View
    style={{ width:'100%', aspectRatio: 6.1/13.4, backgroundColor:'#f3f3f3', borderRadius:8, overflow:'hidden', marginBottom: 12 }}
    onLayout={(e) => {
      const sz = e.nativeEvent.layout;
      if (sz && sz.width && sz.height) {
        setHeatW(Math.max(1, Math.floor(sz.width)));
        setHeatH(Math.max(1, Math.floor(sz.height)));
      }
    }}
  >
    {heatW > 0 && heatH > 0 && (
      viewMode === 'scatter'
        ? <Heatmap width={heatW} height={heatH} points={points} />
        : <HeatGrid width={heatW} height={heatH} points={points} grid={gridSize} mode="all" />
    )}
  </View>

  {/* 區域矩陣（6區＋界外） */}
  <ZoneMatrix stats={byZone} showOut title="區域矩陣（6區＋界外）" />

  <Text style={{ fontSize: 16, fontWeight: '600', marginTop: 12, marginBottom: 8 }}>區域統計（清單）</Text>
  {Object.keys(byZone).sort().map((k) => (
    <Text key={k} style={{ marginBottom: 4 }}>
      區 {k}：得分 {byZone[k].win}，失分 {byZone[k].loss}
    </Text>
  ))}

  <Text style={{ fontSize: 16, fontWeight: '600', marginTop: 12, marginBottom: 8 }}>球種 × 主/受迫 × 原因</Text>
  {byMeta.map((m, idx) => (
    <Text key={String(idx)} style={{ marginBottom: 4 }}>
      {(m.shot || '未填') + '｜' + (m.force || '未填') + '｜' + (m.reason || '—')}：{m.count} 次
    </Text>
  ))}

  {/* 球種分布長條圖（堆疊：得/失） */}
  <View style={{ marginTop: 12 }}>
    <SimpleBarChart data={shotAgg} title="球種分布（得/失）" />
  </View>

  <View style={{ height: 12 }} />

  {/* 動作按鈕列 */}
  <View style={{ flexDirection:'row', flexWrap:'wrap' }}>
    <Pressable
      onPress={() => {
        if (playableIds.length === 0) {
          Alert.alert('提示', '目前篩選結果沒有可播放的路徑');
          return;
        }
        navigation.navigate('Replay', { matchId, ids: playableIds });
      }}
      style={{ padding: 12, backgroundColor: '#009688', borderRadius: 8, marginRight: 8 }}
    >
      <Text style={{ color:'#fff' }}>路徑回放</Text>
    </Pressable>

    <Pressable onPress={() => exportCsv(matchId, filtered)} style={{ padding: 12, backgroundColor: '#1976d2', borderRadius: 8, marginRight: 8 }}>
      <Text style={{ color:'#fff' }}>分享 CSV</Text>
    </Pressable>

    <Pressable onPress={() => shareJson(matchId, filtered)} style={{ padding: 12, backgroundColor: '#455a64', borderRadius: 8, marginRight: 8 }}>
      <Text style={{ color:'#fff' }}>分享 JSON</Text>
    </Pressable>

    <Pressable
      onPress={() => {
        const shotAggForPdf = shotAgg; // 就用上面計算好的
const routesSample = filtered.map((r)=> {
  const sx = (r.route_start_rx != null ? Number(r.route_start_rx) : null);
  const sy = (r.route_start_ry != null ? Number(r.route_start_ry) : null);
  const ex = (r.route_end_rx != null ? Number(r.route_end_rx) : null);
  const ey = (r.route_end_ry != null ? Number(r.route_end_ry) : null);
  if (sx==null||sy==null||ex==null||ey==null) return null;
  return { sx, sy, ex, ey, kind: r.winner_side==='home'?'win':'loss' as const };
}).filter(Boolean) as Array<{sx:number;sy:number;ex:number;ey:number;kind:'win'|'loss'}>;

exportPdfReport(matchId, {
  points: pts,
  zoneStat: groupByZone(filtered),
  metaStat: groupMeta(filtered),
  shotAgg: shotAggForPdf,
  routesSample,
})

      }}
      style={{ padding: 12, backgroundColor: '#2e7d32', borderRadius: 8 }}
    >
      <Text style={{ color:'#fff' }}>匯出 PDF</Text>
    </Pressable>
  </View>
</ScrollView>
);
}

function Filters(props: {
games: number[];
gameFilter: number|'ALL'; setGameFilter: (v:number|'ALL')=>void;
resultFilter: 'ALL'|'WIN'|'LOSS'; setResultFilter: (v:'ALL'|'WIN'|'LOSS')=>void;
shotFilter: string; setShotFilter:(v:string)=>void;
forceFilter: string; setForceFilter:(v:string)=>void;
reasonFilter: string; setReasonFilter:(v:string)=>void;
optsShot: string[]; optsForce: string[]; optsReason: string[];
}) {
return (
<View style={{ marginBottom: 8 }}>
<Row>
<Chip text="全部局" active={props.gameFilter==='ALL'} onPress={()=>props.setGameFilter('ALL')} />
{props.games.map(g => <Chip key={String(g)} text={'第'+g+'局'} active={props.gameFilter===g} onPress={()=>props.setGameFilter(g)} />)}
</Row>
<Row>
<Chip text="勝負：全部" active={props.resultFilter==='ALL'} onPress={()=>props.setResultFilter('ALL')} />
<Chip text="得分" active={props.resultFilter==='WIN'} onPress={()=>props.setResultFilter('WIN')} />
<Chip text="失分" active={props.resultFilter==='LOSS'} onPress={()=>props.setResultFilter('LOSS')} />
</Row>
<Row>
<Chip text="球種：全部" active={props.shotFilter==='ALL'} onPress={()=>props.setShotFilter('ALL')} />
{props.optsShot.map(s => <Chip key={s} text={s} active={props.shotFilter===s} onPress={()=>props.setShotFilter(s)} />)}
</Row>
<Row>
<Chip text="主/受迫：全部" active={props.forceFilter==='ALL'} onPress={()=>props.setForceFilter('ALL')} />
{props.optsForce.map(s => <Chip key={s} text={s} active={props.forceFilter===s} onPress={()=>props.setForceFilter(s)} />)}
</Row>
<Row>
<Chip text="原因：全部" active={props.reasonFilter==='ALL'} onPress={()=>props.setReasonFilter('ALL')} />
{props.optsReason.map(s => <Chip key={s} text={s} active={props.reasonFilter===s} onPress={()=>props.setReasonFilter(s)} />)}
</Row>
</View>
);
}

function Row({ children }: any) {
return <View style={{ flexDirection:'row', flexWrap:'wrap', marginBottom:6 }}>{children}</View>;
}
function Chip({ text, active, onPress }: { text: string; active?: boolean; onPress: ()=>void }) {
return (
<Pressable onPress={onPress} style={{
paddingVertical:6, paddingHorizontal:10, borderRadius:14,
borderWidth:1, borderColor: active ? '#1976d2' : '#ccc',
backgroundColor: active ? 'rgba(25,118,210,0.1)' : '#fff',
marginRight:8, marginBottom:8
}}>
<Text>{text}</Text>
</Pressable>
);
}

function groupByZone(rows: Row[]) {
const acc: Record<string, { win: number; loss: number }> = {};
for (let i = 0; i < rows.length; i++) {
const r = rows[i];
const z = String(r.end_zone || 'out');
if (!acc[z]) acc[z] = { win: 0, loss: 0 };
if (r.winner_side === 'home') acc[z].win += 1; else acc[z].loss += 1;
}
return acc;
}
function groupMeta(rows: Row[]) {
const map = new Map<string, number>();
for (let i = 0; i < rows.length; i++) {
const meta = safeMeta(rows[i].meta_json);
const shot = meta && meta.shotType ? String(meta.shotType) : '';
const force = meta && meta.forceType ? String(meta.forceType) : '';
const reason = meta && meta.errorReason ? String(meta.errorReason) : '';
const key = [shot, force, reason].join('||');
const prev = map.get(key) || 0;
map.set(key, prev + 1);
}
const out: { shot?: string; force?: string; reason?: string; count: number }[] = [];
map.forEach((count, key) => {
const parts = key.split('||');
out.push({ shot: parts[0] || '', force: parts[1] || '', reason: parts[2] || '', count: count });
});
out.sort((a,b)=> b.count - a.count);
return out;
}
function safeMeta(json: string) { try { return JSON.parse(json || '{}'); } catch(_){ return {}; } }
function uniq(arr: any[]) { const set = new Set<string>(); const out: string[] = []; for (let i=0;i<arr.length;i++){ const v = String(arr[i]); if (!set.has(v)) { set.add(v); out.push(arr[i]); } } return out as any; }

function exportCsv(matchId: string, rows: Row[]) {
const header = ['game_index','rally_no','winner_side','end_zone','shotType','hand','forceType','errorReason','end_rx','end_ry'];
const lines = [header.join(',')];
for (let i=0;i<rows.length;i++) {
const r = rows[i];
const meta = safeMeta(r.meta_json);
const end_rx = (r.route_end_rx != null ? r.route_end_rx : r.route_start_rx) ?? '';
const end_ry = (r.route_end_ry != null ? r.route_end_ry : r.route_start_ry) ?? '';
const line = [
r.game_index, r.rally_no, r.winner_side, r.end_zone,
csvSafe(meta.shotType), csvSafe(meta.hand), csvSafe(meta.forceType), csvSafe(meta.errorReason),
end_rx, end_ry
].join(',');
lines.push(line);
}
const csv = lines.join('\n');
shareCsv(matchId, csv).catch((e)=>Alert.alert('分享失敗', String(e && e.message ? e.message : e)));
}
function csvSafe(v:any){ return v==null ? '' : String(v).replace(/,/g,';').replace(/\r?\n/g,' '); }ezbmt-tracked/src/screens/MatchMembersScreen.tsx
 
import React from 'react';
import { View, Text, FlatList, Pressable, Alert, ScrollView } from 'react-native';
import { useRoute } from '@react-navigation/native';
import { listMatchMembers, upsertMatchMember, deleteMatchMember, listEventMembersBasic, getMatch, getMyEventRole } from '../db';

type MemberRole = 'owner'|'coach'|'recorder'|'player'|'viewer';

const ROLES: Array<{ key: MemberRole; label: string }> = [
{ key: 'coach',    label: '教練' },
{ key: 'recorder', label: '記錄' },
{ key: 'player',   label: '選手' },
{ key: 'viewer',   label: '觀看' },
];

const C = {
bg: '#111',
card: '#222',
border: '#333',
text: '#fff',
sub: '#bbb',
chipOn: '#90caf9',
chipOff: '#555',
};

export default function MatchMembersScreen() {
const route = useRoute<any>();
const matchId = route.params?.matchId as string;

const [eventId, setEventId] = React.useState<string>('');
const [mine, setMine] = React.useState<MemberRole|null>(null);
const [members, setMembers] = React.useState<Array<{ id:string; user_id:string; role:MemberRole; name:string }>>([]);
const [candidates, setCandidates] = React.useState<Array<{ user_id:string; name:string }>>([]);
const canManage = mine === 'owner' || mine === 'coach' || mine === 'recorder';

const load = React.useCallback(async () => {
try {
const m = await getMatch(matchId);
const eid = m?.event_id as string;
setEventId(eid);

  const [myRole, mm, evMembers] = await Promise.all([
    getMyEventRole(eid),
    listMatchMembers(matchId),
    listEventMembersBasic(eid),
  ]);
  setMine(myRole);

  setMembers(mm);
  const existing = new Set(mm.map((x: { user_id: string }) => x.user_id));
  setCandidates(evMembers.filter((x: { user_id: string }) => !existing.has(x.user_id)));
} catch (e:any) {
  Alert.alert('載入失敗', String(e?.message || e));
}
}, [matchId]);

React.useEffect(() => { load(); }, [load]);

async function changeRole(memberId: string, userId: string, newRole: MemberRole) {
try {
if (!canManage) return;
await upsertMatchMember({ matchId, userId, role: newRole });
load();
} catch (e:any) {
Alert.alert('變更失敗', String(e?.message || e));
}
}

async function removeMember(memberId: string) {
try {
if (!canManage) return;
await deleteMatchMember(memberId);
load();
} catch (e:any) {
Alert.alert('移除失敗', String(e?.message || e));
}
}

async function addToMatch(userId: string, role: MemberRole) {
try {
if (!canManage) return;
await upsertMatchMember({ matchId, userId, role });
load();
} catch (e:any) {
Alert.alert('新增失敗', String(e?.message || e));
}
}

const renderRow = ({ item }: { item: { id:string; user_id:string; role:MemberRole; name:string } }) => (
<View style={{ padding:10, borderWidth:1, borderColor:C.border, backgroundColor:C.card, borderRadius:8, marginBottom:8 }}>
<Text style={{ fontWeight:'600', marginBottom:6, color: C.text }}>{item.name}</Text>
<View style={{ flexDirection:'row', flexWrap:'wrap', alignItems:'center' }}>
{ROLES.map(r => {
const selected = item.role === r.key;
return (
<Pressable
key={r.key}
onPress={() => canManage && changeRole(item.id, item.user_id, r.key)}
style={{
paddingVertical:6, paddingHorizontal:10, borderRadius:14,
borderWidth:1, borderColor: selected ? C.chipOn : C.chipOff,
backgroundColor: selected ? 'rgba(144,202,249,0.15)' : C.card,
marginRight:8, marginBottom:8, opacity: canManage ? 1 : 0.5
}}
>
<Text style={{ color: C.text }}>{r.label}</Text>
</Pressable>
);
})}
{canManage && (
<Pressable
onPress={() => removeMember(item.id)}
style={{ paddingVertical:6, paddingHorizontal:10, backgroundColor:'#d32f2f', borderRadius:8, marginLeft:8 }}
>
<Text style={{ color:'#fff' }}>移除</Text>
</Pressable>
)}
</View>
</View>
);

return (
<View style={{ flex:1, backgroundColor: C.bg }}>
<ScrollView
style={{ flex:1, backgroundColor: C.bg }}
contentContainerStyle={{ padding:12, flexGrow: 1, paddingBottom: 16 }}
>
<Text style={{ fontSize:16, fontWeight:'600', marginBottom:8, color: C.text }}>場次成員</Text>

    <FlatList
      data={members}
      keyExtractor={(i)=>i.id}
      renderItem={renderRow}
      scrollEnabled={false}
    />

    {canManage && (
      <View style={{ marginTop:12 }}>
        <Text style={{ fontWeight:'600', marginBottom:8, color: C.text }}>從事件成員加入</Text>
        {candidates.map(c => (
          <View key={c.user_id} style={{ padding:10, borderWidth:1, borderColor:C.border, backgroundColor:C.card, borderRadius:8, marginBottom:8 }}>
            <Text style={{ marginBottom:6, color: C.text }}>{c.name}</Text>
            <View style={{ flexDirection:'row', flexWrap:'wrap' }}>
              {ROLES.map(r => (
                <Pressable
                  key={r.key}
                  onPress={() => addToMatch(c.user_id, r.key)}
                  style={{ paddingVertical:6, paddingHorizontal:10, borderRadius:14, borderWidth:1, borderColor:C.chipOff, backgroundColor:C.card, marginRight:8, marginBottom:8 }}
                >
                  <Text style={{ color: C.text }}>{r.label}</Text>
                </Pressable>
              ))}
            </View>
          </View>
        ))}
        {!candidates.length && <Text style={{ color: C.sub }}>事件所有成員都已在本場次中</Text>}
      </View>
    )}
  </ScrollView>
</View>
);
}ezbmt-tracked/src/types.ts
 
export type Side = 'home' | 'away';
export type Zone = 1 | 2 | 3 | 4 | 5 | 6 | 'out';
export type Orientation = 'portrait' | 'landscape';

export type Point = { x: number; y: number };

export type TapEvent = {
  side: Side;        // portrait: 上=away，下=home；landscape：左=home，右=away（整張左轉90°）
  zone: Zone;        // 1..6 或 'out'
  point: Point;      // 以螢幕座標（px）
  norm?: {           // 以「直式雙打外框」為基準的相對座標（0..1，可超界）
    x: number;       // (px - innerX) / innerW
    y: number;       // (py - innerY) / innerH
  };
  inBounds: boolean; // 是否在場內（雙打外框且符合單/雙有效寬）
};

export type RallyEndMeta = {
  shotType?: string;
  hand?: '正手' | '反手';
  forceType?: '主動得分' | '對手失誤' | '主動失誤' | '受迫失誤';
  errorReason?: '出界' | '掛網' | '質量不好';
  lastHitter?: string;
};

export type RallyRecord = {
  id: string;
  matchId?: string;
  gameIndex: number; // 1..N（顯示用）
  rallyNo: number;
  winnerSide: Side;
  endZone: Zone;
  meta: RallyEndMeta;
  route?: { start: Point; end: Point }; // 以螢幕座標（px）
  createdAt: string;
};
ezbmt-tracked/src/components/MatchRulesSheet.tsx
 
import React from 'react';
import { View, Text, Modal, Pressable, Switch, Platform, ActionSheetIOS, Alert } from 'react-native';

type Rules = { bestOf: number; pointsToWin: number; deuce: boolean; cap?: number | null };

type Props = {
visible: boolean;
initial: Rules;
onClose: () => void;
onSave: (rules: Rules) => void;
};

// 可調整的選單
const BEST_OF_OPTIONS = [1, 3, 5] as const;
const POINTS_OPTIONS = [11, 15, 21] as const;
const CAP_OPTIONS = [null, 30] as const; // null=無封頂

export default function MatchRulesSheet({ visible, initial, onClose, onSave }: Props) {
const [bestOf, setBestOf] = React.useState<number>(initial.bestOf);
const [points, setPoints] = React.useState<number>(initial.pointsToWin);
const [deuce, setDeuce] = React.useState<boolean>(initial.deuce);
const [cap, setCap] = React.useState<number | null>(initial.cap ?? 30);

React.useEffect(() => {
if (visible) {
setBestOf(initial.bestOf);
setPoints(initial.pointsToWin);
setDeuce(initial.deuce);
setCap(initial.cap ?? 30);
}
}, [visible, initial]);

const openPicker = <T extends number | null>(
title: string,
options: readonly T[],
format: (v: T) => string,
onSelected: (v: T) => void
) => {
if (Platform.OS === 'ios') {
const labels = options.map(format);
ActionSheetIOS.showActionSheetWithOptions(
{ title, options: [...labels, '取消'], cancelButtonIndex: labels.length },
(idx) => {
if (idx != null && idx >= 0 && idx < labels.length) onSelected(options[idx]);
}
);
} else {
// Android：用 Alert 選單
Alert.alert(
title,
'',
[
...options.map((v) => ({ text: format(v), onPress: () => onSelected(v) })),
{ text: '取消', style: 'cancel' },
],
{ cancelable: true }
);
}
};

return (
<Modal visible={visible} transparent animationType="slide" onRequestClose={onClose}>
<View style={{ flex: 1, backgroundColor: 'rgba(0,0,0,0.35)', justifyContent: 'flex-end' }}>
<View style={{ backgroundColor: '#fff', borderTopLeftRadius: 16, borderTopRightRadius: 16, padding: 16 }}>
<Text style={{ fontSize: 16, fontWeight: '600', marginBottom: 12 }}>比賽規則</Text>

      <Row label="Best of (1/3/5)">
        <PickerButton
          text={String(bestOf)}
          onPress={() =>
            openPicker('Best of', BEST_OF_OPTIONS, (v) => String(v), (v) => setBestOf(v))
          }
        />
      </Row>

      <Row label="每局目標分 (11/15/21)">
        <PickerButton
          text={String(points)}
          onPress={() =>
            openPicker('每局目標分', POINTS_OPTIONS, (v) => String(v), (v) => setPoints(v))
          }
        />
      </Row>

      <Row label="Deuce（需領先2分）">
        <Switch value={deuce} onValueChange={setDeuce} />
      </Row>

      <Row label="封頂分（cap；30=29平搶1；空白=無封頂）">
        <PickerButton
          text={cap == null ? '無封頂' : String(cap)}
          onPress={() =>
            openPicker('封頂分', CAP_OPTIONS, (v) => (v == null ? '無封頂' : String(v)), (v) => setCap(v))
          }
        />
      </Row>

      <View style={{ flexDirection: 'row', justifyContent: 'flex-end', marginTop: 14 }}>
        <Pressable onPress={onClose} style={{ padding: 12, marginRight: 8 }}>
          <Text>取消</Text>
        </Pressable>
        <Pressable
          onPress={() => onSave({ bestOf, pointsToWin: points, deuce, cap })}
          style={{ padding: 12, backgroundColor: '#1976d2', borderRadius: 8 }}
        >
          <Text style={{ color: '#fff' }}>儲存</Text>
        </Pressable>
      </View>
    </View>
  </View>
</Modal>
);
}

function Row({ label, children }: any) {
return (
<View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 10 }}>
<Text style={{ width: 180 }}>{label}</Text>
{children}
</View>
);
}

function PickerButton({ text, onPress }: { text: string; onPress: () => void }) {
return (
<Pressable
onPress={onPress}
style={{
minWidth: 100,
paddingVertical: 8,
paddingHorizontal: 12,
borderWidth: 1,
borderColor: '#ccc',
borderRadius: 8,
backgroundColor: '#fff',
}}
>
<Text>{text}</Text>
</Pressable>
);
}ezbmt-tracked/src/components/Court.tsx
 
import React, { useMemo, useState, useCallback } from 'react';
import { View, LayoutChangeEvent } from 'react-native';
import Svg, { Rect, Line, Text as SvgText, G, Circle } from 'react-native-svg';
import type { Orientation, Side, Zone, TapEvent, Point } from '../types';

type Marker = {
  id: string;
  rx: number;
  ry: number;
  kind: 'win' | 'loss';
};

type OverlayPositions = {
  A: { right: 0 | 1; left: 0 | 1 };
  B: { right: 0 | 1; left: 0 | 1 };
};

type Props = {
  orientation: Orientation;
  singles: boolean;
  mode: 'tap' | 'route';
  routeStart: Point | null;
  routeHover: Point | null;
  onTap: (e: TapEvent) => void;
  onHover?: (p: Point | null) => void;
  markers?: Marker[];
  onPressMarker?: (id: string) => void;

  // 站位疊加
  overlay?: {
    homeRight?: string;
    homeLeft?: string;
    awayRight?: string;
    awayLeft?: string;
    server?: { team: 0 | 1; index: 0 | 1 };
    receiver?: { team: 0 | 1; index: 0 | 1 };
    positions?: OverlayPositions;
    opacity?: number;
  };

  // 新增：父層控制的黑點（以 Court 內部座標 px）
  focusPoint?: { x: number; y: number } | null;
};

/* 球場比例 */
const FULL_LEN = 13.4;
const FULL_WID = 6.1;
const PORTRAIT_RATIO = FULL_WID / FULL_LEN;
const LANDSCAPE_RATIO = FULL_LEN / FULL_WID;

/* 實際尺寸 */
const SHORT_LINE_DIST = 1.98;
const DBL_LONG_BACK = 0.76;
const SNG_WID = 5.18;
const SIDE_GAP = (FULL_WID - SNG_WID) / 2;

export default function Court({
  orientation, singles, mode, routeStart, routeHover, onTap, onHover, markers = [], onPressMarker, overlay, focusPoint,
}: Props) {
  const [box, setBox] = useState({ w: 0, h: 0 });
  const onLayout = useCallback((e: LayoutChangeEvent) => {
    const { width, height } = e.nativeEvent.layout;
    setBox({ w: width, h: height });
  }, []);

  const draw = useMemo(() => {
    const { w: Wv, h: Hv } = box;
    if (Wv <= 0 || Hv <= 0) return { CW: 0, CH: 0, W: 0, H: 0, padX: 0, padY: 0, x: 0, y: 0 };
    const ratio = orientation === 'portrait' ? PORTRAIT_RATIO : LANDSCAPE_RATIO;
    let H = Hv * 0.9;
    let W = H * ratio;
    if (W > Wv * 0.96) {
      W = Wv * 0.96;
      H = W / ratio;
    }
    const padX = Math.round(W * 0.1);
    const padY = Math.round(H * 0.06);
    const CW = W + padX * 2;
    const CH = H + padY * 2;
    return { CW, CH, W, H, padX, padY, x: (Wv - CW) / 2, y: (Hv - CH) / 2 };
  }, [box, orientation]);

  return (
    <View style={{ flex: 1 }} onLayout={onLayout}>
      {draw.CW > 0 && (
        <CourtSurface
          containerW={draw.CW}
          containerH={draw.CH}
          width={draw.W}
          height={draw.H}
          padX={draw.padX}
          padY={draw.padY}
          offsetX={draw.x}
          offsetY={draw.y}
          orientation={orientation}
          singles={singles}
          mode={mode}
          routeStart={routeStart}
          routeHover={routeHover}
          onTap={onTap}
          onHover={onHover}
          markers={markers}
          onPressMarker={onPressMarker}
          overlay={overlay}
          focusPoint={focusPoint}
        />
      )}
    </View>
  );
}

function CourtSurface({
  containerW, containerH, width, height, padX, padY, offsetX, offsetY,
  orientation, singles, mode, routeStart, routeHover, onTap, onHover, markers, onPressMarker, overlay, focusPoint,
}: {
  containerW: number; containerH: number; width: number; height: number; padX: number; padY: number; offsetX: number; offsetY: number;
} & Props) {
  const border = Math.max(2, Math.round(Math.min(width, height) * 0.02));
  const innerX = padX + border;
  const innerY = padY + border;
  const innerW = width - border * 2;
  const innerH = height - border * 2;

  const sx = innerW / FULL_WID;
  const sy = innerH / FULL_LEN;

  const midY = innerY + innerH / 2;
  const midX = innerX + innerW / 2;
  const topBack = innerY;
  const bottomBack = innerY + innerH;
  const topShort = midY - SHORT_LINE_DIST * sy;
  const bottomShort = midY + SHORT_LINE_DIST * sy;
  const topDblLong = topBack + DBL_LONG_BACK * sy;
  const bottomDblLong = bottomBack - DBL_LONG_BACK * sy;
  const singleLeft = innerX + SIDE_GAP * sx;
  const singleRight = innerX + innerW - SIDE_GAP * sx;

  const halfH = innerH / 2;
  const frontH = SHORT_LINE_DIST * sy;
  const midH = (halfH - frontH) / 2;
  const backH = (halfH - frontH) / 2;

  const effX = singles ? singleLeft : innerX;
  const effW = singles ? (singleRight - singleLeft) : innerW;

  function zoneNumber(rowType: 0 | 1 | 2, isRightFromPlayer: boolean): Zone {
    const base = rowType === 0 ? 1 : (rowType === 1 ? 5 : 3);
    return (base + (isRightFromPlayer ? 0 : 1)) as Zone;
  }

  function RealCourt() {
    const frame = '#151515';
    const line = '#f0e6da';
    const grass = '#2e7d32';
    const lineW = Math.max(3, Math.round(Math.min(innerW, innerH) * 0.012));
    return (
      <>
        <Rect x={innerX} y={innerY} width={innerW} height={innerH} fill={grass} />
        <Rect x={innerX} y={innerY} width={innerW} height={innerH} fill="none" stroke={frame} strokeWidth={lineW} />
        <Line x1={singleLeft} y1={innerY} x2={singleLeft} y2={innerY + innerH} stroke={line} strokeWidth={lineW} />
        <Line x1={singleRight} y1={innerY} x2={singleRight} y2={innerY + innerH} stroke={line} strokeWidth={lineW} />
        <Line x1={innerX} y1={midY} x2={innerX + innerW} y2={midY} stroke={line} strokeWidth={lineW} />
        <Line x1={innerX} y1={topShort} x2={innerX + innerW} y2={topShort} stroke={line} strokeWidth={lineW} />
        <Line x1={innerX} y1={bottomShort} x2={innerX + innerW} y2={bottomShort} stroke={line} strokeWidth={lineW} />
        <Line x1={midX} y1={topShort} x2={midX} y2={topBack} stroke={line} strokeWidth={lineW} />
        <Line x1={midX} y1={bottomShort} x2={midX} y2={bottomBack} stroke={line} strokeWidth={lineW} />
        <Line x1={innerX} y1={topDblLong} x2={innerX + innerW} y2={topDblLong} stroke={line} strokeWidth={lineW} />
        <Line x1={innerX} y1={bottomDblLong} x2={innerX + innerW} y2={bottomDblLong} stroke={line} strokeWidth={lineW} />
      </>
    );
  }

  function unrotateForLandscape(x: number, y: number) {
    const cx = containerW / 2, cy = containerH / 2;
    const dx = x - cx, dy = y - cy;
    return { x: cx - dy, y: cy + dx };
  }

  function classifyTapPortrait(px: number, py: number): TapEvent {
    const inOuter = px >= innerX && px <= innerX + innerW && py >= innerY && py <= innerY + innerH;
    const side: Side = py < midY ? 'away' : 'home';

    const inSinglesX = px >= effX && px <= effX + effW;
    const inBounds = inOuter && inSinglesX;

    const relFromNet = side === 'home' ? (py - midY) : (midY - py);
    let rowType: 0 | 1 | 2;
    if (relFromNet < frontH) rowType = 0;
    else if (relFromNet < frontH + midH) rowType = 1;
    else rowType = 2;

    const cellW = (effW / 2);
    const col = Math.max(0, Math.min(1, Math.floor((px - effX) / cellW))) as 0 | 1;
    const isRightFromPlayer = side === 'home' ? (col === 1) : (col === 0);
    const zone = zoneNumber(rowType, isRightFromPlayer);

    const rx = (px - innerX) / innerW;
    const ry = (py - innerY) / innerH;

    return { side, zone, point: { x: px, y: py }, norm: { x: rx, y: ry }, inBounds };
  }

  function classifyTap(x: number, y: number): TapEvent {
    if (orientation === 'portrait') {
      return classifyTapPortrait(x, y);
    } else {
      const r = unrotateForLandscape(x, y);
      return classifyTapPortrait(r.x, r.y);
    }
  }

  const onResponderMove = (evt: any) => {
    if (!routeStart || mode !== 'route') return;
    const { locationX, locationY } = evt?.nativeEvent || {};
    if (typeof locationX !== 'number' || typeof locationY !== 'number') return;
    onHover?.({ x: locationX, y: locationY });
  };

  const onResponderRelease = (evt: any) => {
    const { locationX, locationY } = evt?.nativeEvent || {};
    if (typeof locationX !== 'number' || typeof locationY !== 'number') return;

    const portraitPt = orientation === 'portrait'
      ? { x: locationX, y: locationY }
      : unrotateForLandscape(locationX, locationY);

    if (onPressMarker && markers && markers.length) {
      const near = markers.find(m => {
        const mx = innerX + m.rx * innerW;
        const my = innerY + m.ry * innerH;
        const dx = portraitPt.x - mx;
        const dy = portraitPt.y - my;
        return (dx*dx + dy*dy) <= (16*16);
      });
      if (near) { onPressMarker(near.id); return; }
    }

    onTap(classifyTap(locationX, locationY));
    onHover?.(null);
  };

  function renderZonesPortrait(side: Side) {
    const isAway = side === 'away';
    const rowsH = isAway ? [backH, midH, frontH] : [frontH, midH, backH];
    const startY = isAway ? innerY : midY;
    const cellW = (effW / 2);
    let y = startY;
    const nodes: any[] = [];
    for (let i = 0; i < 3; i++) {
      const rowH = rowsH[i];
      const xLeft = effX, xRight = effX + cellW;

      const rowType: 0 | 1 | 2 = isAway ? ((i === 0 ? 2 : i === 1 ? 1 : 0) as 0 | 1 | 2) : (i as 0 | 1 | 2);
      const rightLabel = zoneNumber(rowType, true);
      const leftLabel = zoneNumber(rowType, false);
      const leftZone = isAway ? rightLabel : leftLabel;
      const rightZone = isAway ? leftLabel : rightLabel;

      nodes.push(
        <G key={side + '-row' + i + '-L'}>
          <Rect x={xLeft} y={y} width={cellW} height={rowH} fill={side === 'home' ? 'rgba(76,175,80,0.12)' : 'rgba(244,67,54,0.12)'} />
          <SvgText x={xLeft + cellW / 2} y={y + rowH / 2} fontSize={Math.min(cellW, rowH) * 0.35} fill="#222" textAnchor="middle" alignmentBaseline="middle">
            {String(leftZone)}
          </SvgText>
        </G>
      );
      nodes.push(
        <G key={side + '-row' + i + '-R'}>
          <Rect x={xRight} y={y} width={cellW} height={rowH} fill={side === 'home' ? 'rgba(76,175,80,0.12)' : 'rgba(244,67,54,0.12)'} />
          <SvgText x={xRight + cellW / 2} y={y + rowH / 2} fontSize={Math.min(cellW, rowH) * 0.35} fill="#222" textAnchor="middle" alignmentBaseline="middle">
            {String(rightZone)}
          </SvgText>
        </G>
      );

      y += rowH;
    }
    return nodes;
  }

  function renderMarkers() {
    if (!markers || markers.length === 0) return null;
    const R = Math.max(6, Math.round(Math.min(innerW, innerH) * 0.015));
    return markers.map((m) => {
      const px = innerX + m.rx * innerW;
      const py = innerY + m.ry * innerH;
      const fill = m.kind === 'win' ? 'rgba(33,150,243,0.5)' : 'rgba(244,67,54,0.5)';
      const stroke = m.kind === 'win' ? 'rgba(33,150,243,0.9)' : 'rgba(244,67,54,0.9)';
      return <Circle key={m.id} cx={px} cy={py} r={R} fill={fill} stroke={stroke} strokeWidth={2} />;
    });
  }

  function textW(txt: string, fs: number) {
    const n = (txt || '').length;
    return Math.max(24, Math.round(n * fs * 0.58));
  }
  function NameBadge({ x, y, label, fs, mark }: { x: number; y: number; label: string; fs: number; mark?: 'S' | 'R' }) {
    const padX = 10, padY = 6;
    const w = textW(label, fs) + padX * 2;
    const h = fs + padY * 2;
    const rx = 10;
    const bg = 'rgba(0,0,0,0.35)';
    return (
      <G>
        <Rect x={x - w / 2} y={y - h / 2} width={w} height={h} rx={rx} ry={rx} fill={bg} />
        <SvgText x={x} y={y} fontSize={fs} fill="#fff" textAnchor="middle" alignmentBaseline="middle">
          {label || ''}
        </SvgText>
        {mark ? (
          <G>
            <Circle cx={x + w / 2 - 12} cy={y - h / 2 + 12} r={10} fill={mark === 'S' ? '#1976d2' : '#d32f2f'} />
            <SvgText x={x + w / 2 - 12} y={y - h / 2 + 12} fontSize={10} fill="#fff" textAnchor="middle" alignmentBaseline="middle">
              {mark}
            </SvgText>
          </G>
        ) : null}
      </G>
    );
  }

  return (
    <View style={{ width: containerW, height: containerH, marginLeft: offsetX, marginTop: offsetY }}>
      <Svg width={containerW} height={containerH} viewBox={'0 0 ' + containerW + ' ' + containerH}>
        <G transform={orientation === 'landscape' ? `rotate(-90 ${containerW / 2} ${containerH / 2})` : undefined}>
          {RealCourt()}
          {renderZonesPortrait('away')}
          {renderZonesPortrait('home')}
          {renderMarkers()}

          {routeStart && (
            <>
              <Circle cx={routeStart.x} cy={routeStart.y} r={12} fill="#1976d2" />
              {routeHover && (
                <>
                  <Line x1={routeStart.x} y1={routeStart.y} x2={routeHover.x} y2={routeHover.y} stroke="#1976d2" strokeWidth={6} strokeDasharray="12,8" opacity={0.85} />
                  <Circle cx={routeHover.x} cy={routeHover.y} r={10} fill="#1976d2" opacity={0.9} />
                </>
              )}
            </>
          )}

          {/* 疊加名牌 */}
          {(() => {
            if (!overlay) return null;
            const fs = Math.max(12, Math.round(Math.min(innerW, innerH) * 0.04));
            const cellW = (singles ? (singleRight - singleLeft) : innerW) / 2;
            const ex = singles ? singleLeft : innerX;
            const xLeft = ex + cellW / 2;
            const xRight = ex + cellW * 1.5;
            const yAway = innerY + innerH * 0.25;
            const yHome = innerY + innerH * 0.75;

            const pos = overlay.positions;
            const srv = overlay.server;
            const rcv = overlay.receiver;
            const markOf = (team: 0 | 1, side: 'R' | 'L'): 'S' | 'R' | undefined => {
              const map = team === 0 ? pos?.A : pos?.B;
              const at = side === 'R' ? map?.right : map?.left;
              if (srv && srv.team === team && srv.index === at) return 'S';
              if (rcv && rcv.team === team && rcv.index === at) return 'R';
              return undefined;
            };

            return (
              <>
                {!!overlay.awayRight && <NameBadge x={xLeft}  y={yAway} label={overlay.awayRight} fs={fs} mark={markOf(1,'R')} />}
                {!!overlay.awayLeft  && <NameBadge x={xRight} y={yAway} label={overlay.awayLeft } fs={fs} mark={markOf(1,'L')} />}
                {!!overlay.homeLeft  && <NameBadge x={xLeft}  y={yHome} label={overlay.homeLeft } fs={fs} mark={markOf(0,'L')} />}
                {!!overlay.homeRight && <NameBadge x={xRight} y={yHome} label={overlay.homeRight} fs={fs} mark={markOf(0,'R')} />}
              </>
            );
          })()}

          {/* 受控黑點（直到父層清除） */}
          {focusPoint ? <Circle cx={focusPoint.x} cy={focusPoint.y} r={10} fill="rgba(0,0,0,0.85)" /> : null}
        </G>
      </Svg>

      <View
        style={{ position: 'absolute', left: 0, top: 0, right: 0, bottom: 0 }}
        pointerEvents="box-only"
        onStartShouldSetResponder={() => true}
        onResponderMove={onResponderMove}
        onResponderRelease={onResponderRelease}
      />
    </View>
  );
}ezbmt-tracked/src/components/GlobalBackground.tsx
 
import React from 'react';
import { Image, View, StyleSheet } from 'react-native';
import { useBgStore } from '../store/bg';

// 有上傳用使用者圖片，沒上傳用預設圖
const DEFAULT_BG = require('../images/bg_default.jpg');

export default function GlobalBackground() {
const uri = useBgStore(s => s.uri);
const opacity = useBgStore(s => s.opacity);
const source = uri ? { uri } : DEFAULT_BG;

return (
<View pointerEvents="none" style={StyleSheet.absoluteFillObject}>
<Image
source={source}
style={[StyleSheet.absoluteFillObject, { opacity }]}
resizeMode="cover"  // 中心裁切
/>
</View>
);
}ezbmt-tracked/src/components/RoutePlayer.tsx
 
import React from 'react';
import { View, Text, Pressable } from 'react-native';
import Svg, { Rect, Line, Circle } from 'react-native-svg';

type RouteItem = {
  sx: number; sy: number;
  ex: number; ey: number;
  kind: 'win' | 'loss';
  meta?: { shotType?: string; forceType?: string; errorReason?: string };
};

type Props = {
  width: number;
  height: number;
  routes: RouteItem[];
  autoPlay?: boolean;
  initialSpeed?: 0.5 | 1 | 2;
  filter?: 'all' | 'win' | 'loss' | 'random';
  onIndexChange?: (index: number) => void;
};

const FULL_LEN = 13.4;
const FULL_WID = 6.1;
const SHORT_LINE_DIST = 1.98;
const DBL_LONG_BACK = 0.76;

export default function RoutePlayer({
  width, height, routes, autoPlay = true, initialSpeed = 1, filter = 'all', onIndexChange,
}: Props) {
  const [index, setIndex] = React.useState(0);
  const [t, setT] = React.useState(0); // 0..1
  const [playing, setPlaying] = React.useState(autoPlay);
  const [speed, setSpeed] = React.useState<0.5 | 1 | 2>(initialSpeed);

  const rafRef = React.useRef<number | null>(null);
  const lastTsRef = React.useRef<number | null>(null);

  const filtered = React.useMemo(() => {
    if (filter === 'all') return routes;
    if (filter === 'win') return routes.filter(r => r.kind === 'win');
    if (filter === 'loss') return routes.filter(r => r.kind === 'loss');
    if (filter === 'random') {
      const arr = routes.slice();
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        const tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;
      }
      return arr;
    }
    return routes;
  }, [routes, filter]);

  const total = filtered.length;
  const idx = Math.max(0, Math.min(index, Math.max(0, total - 1)));
  const cur = total ? filtered[idx] : null;

  React.useEffect(() => { setIndex(0); setT(0); setPlaying(autoPlay); }, [filter, routes, autoPlay]);

  React.useEffect(() => { onIndexChange?.(idx); }, [idx, onIndexChange]);

  React.useEffect(() => {
    if (!playing || !cur) return;
    const step = (ts: number) => {
      const last = lastTsRef.current;
      lastTsRef.current = ts;
      const dt = last ? (ts - last) : 16;
      const dur = 1500 / speed;
      setT((prev) => {
        const nt = prev + dt / dur;
        if (nt >= 1) {
          next();
          return 0;
        }
        return nt;
      });
      rafRef.current = requestAnimationFrame(step);
    };
    rafRef.current = requestAnimationFrame(step);
    return () => {
      if (rafRef.current) cancelAnimationFrame(rafRef.current);
      rafRef.current = null;
      lastTsRef.current = null;
    };
  }, [playing, idx, speed, cur]);

  function toggle() { setPlaying(p => !p); }
  function replay() { setT(0); if (total) setPlaying(true); }
  function prev() {
    if (idx > 0) { setIndex(i => i - 1); setT(0); setPlaying(true); }
    else { setT(0); setPlaying(false); }
  }
  function next() {
    if (idx < total - 1) { setIndex(i => i + 1); setT(0); setPlaying(true); }
    else { setPlaying(false); setT(1); }
  }

  const dotR = Math.max(4, Math.round(Math.min(width, height) * 0.01));
  const trackW = Math.max(3, Math.round(Math.min(width, height) * 0.008));

  const sx = cur ? cur.sx * width : 0;
  const sy = cur ? cur.sy * height : 0;
  const ex = cur ? cur.ex * width : 0;
  const ey = cur ? cur.ey * height : 0;
  const cx = sx + (ex - sx) * t;
  const cy = sy + (ey - sy) * t;
  const color = cur?.kind === 'win' ? '#1976d2' : '#d32f2f';

  function CourtLines() {
    // 實際以整張直式球場填滿畫布（你的 routes 已是 portrait 相對座標）
    const innerW = width, innerH = height;
    const midY = innerH / 2;
    const midX = innerW / 2;
    const syScale = innerH / FULL_LEN;
    const sxScale = innerW / FULL_WID;
    const topBack = 0;
    const bottomBack = innerH;
    const topShort = midY - SHORT_LINE_DIST * syScale;
    const bottomShort = midY + SHORT_LINE_DIST * syScale;
    const topDblLong = topBack + DBL_LONG_BACK * syScale;
    const bottomDblLong = bottomBack - DBL_LONG_BACK * syScale;
    const singleLeft = (innerW - (5.18 * sxScale)) / 2;
    const singleRight = innerW - singleLeft;

    const line = '#f0e6da';
    const lineW = Math.max(2, Math.round(Math.min(innerW, innerH) * 0.012));

    return (
      <>
        <Rect x={0} y={0} width={innerW} height={innerH} fill="#2e7d32" />
        <Line x1={0} y1={0} x2={innerW} y2={0} stroke={line} strokeWidth={lineW} />
        <Line x1={0} y1={innerH} x2={innerW} y2={innerH} stroke={line} strokeWidth={lineW} />
        <Line x1={0} y1={0} x2={0} y2={innerH} stroke={line} strokeWidth={lineW} />
        <Line x1={innerW} y1={0} x2={innerW} y2={innerH} stroke={line} strokeWidth={lineW} />
        <Line x1={singleLeft} y1={0} x2={singleLeft} y2={innerH} stroke={line} strokeWidth={lineW} />
        <Line x1={singleRight} y1={0} x2={singleRight} y2={innerH} stroke={line} strokeWidth={lineW} />
        <Line x1={0} y1={midY} x2={innerW} y2={midY} stroke={line} strokeWidth={lineW} />
        <Line x1={0} y1={topShort} x2={innerW} y2={topShort} stroke={line} strokeWidth={lineW} />
        <Line x1={0} y1={bottomShort} x2={innerW} y2={bottomShort} stroke={line} strokeWidth={lineW} />
        <Line x1={midX} y1={topShort} x2={midX} y2={0} stroke={line} strokeWidth={lineW} />
        <Line x1={midX} y1={bottomShort} x2={midX} y2={innerH} stroke={line} strokeWidth={lineW} />
        <Line x1={0} y1={topDblLong} x2={innerW} y2={topDblLong} stroke={line} strokeWidth={lineW} />
        <Line x1={0} y1={bottomDblLong} x2={innerW} y2={bottomDblLong} stroke={line} strokeWidth={lineW} />
      </>
    );
  }

  const badge = (txt: string) => (
    <View style={{ paddingVertical: 4, paddingHorizontal: 8, borderRadius: 12, backgroundColor: 'rgba(0,0,0,0.35)', marginRight: 6 }}>
      <Text style={{ color: '#fff' }}>{txt}</Text>
    </View>
  );

  return (
    <View style={{ width, height }}>
      <Svg width={width} height={height}>
        <CourtLines />
        {cur && (
          <>
            <Line x1={sx} y1={sy} x2={ex} y2={ey} stroke={color} strokeWidth={trackW} strokeDasharray="12,8" opacity={0.5} />
            <Circle cx={sx} cy={sy} r={dotR} fill={color} opacity={0.85} />
            <Circle cx={ex} cy={ey} r={dotR} fill={color} opacity={0.85} />
            <Circle cx={cx} cy={cy} r={dotR + 2} fill={color} />
          </>
        )}
      </Svg>

      {/* 當前球的標籤（球種/主受迫/原因） */}
      {cur?.meta && (
        <View style={{ position: 'absolute', left: 10, top: 10, flexDirection: 'row' }}>
          {!!cur.meta.shotType && badge(cur.meta.shotType)}
          {!!cur.meta.forceType && badge(cur.meta.forceType)}
          {!!cur.meta.errorReason && badge(cur.meta.errorReason)}
        </View>
      )}

      {/* 控制列 */}
      <View style={{ position: 'absolute', left: 10, right: 10, bottom: 10, backgroundColor: 'rgba(0,0,0,0.5)', borderRadius: 10, padding: 8 }}>
        <View style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between' }}>
          <Text style={{ color: '#fff' }}>{total ? `第 ${idx + 1}/${total} 球` : '無可播放路徑'}</Text>
          <View style={{ flexDirection: 'row', alignItems: 'center' }}>
            <Pressable onPress={prev} style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#424242', borderRadius: 6, marginRight: 6 }}>
              <Text style={{ color: '#fff' }}>上一球</Text>
            </Pressable>
            <Pressable onPress={toggle} style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#1976d2', borderRadius: 6, marginRight: 6 }}>
              <Text style={{ color: '#fff' }}>{playing ? '暫停' : '播放'}</Text>
            </Pressable>
            <Pressable onPress={replay} style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#455a64', borderRadius: 6, marginRight: 6 }}>
              <Text style={{ color: '#fff' }}>重播</Text>
            </Pressable>
            <Pressable onPress={next} style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#424242', borderRadius: 6 }}>
              <Text style={{ color: '#fff' }}>下一球</Text>
            </Pressable>
          </View>
        </View>

        <View style={{ flexDirection: 'row', marginTop: 8 }}>
          {(['all','win','loss','random'] as Array<'all'|'win'|'loss'|'random'>).map((f) => (
            <View key={f} style={{ paddingVertical: 6, paddingHorizontal: 10, borderRadius: 6, borderWidth: 1, borderColor: filter === f ? '#90caf9' : '#bbb', backgroundColor: filter === f ? 'rgba(144,202,249,0.15)' : 'rgba(255,255,255,0.05)', marginRight: 6 }}>
              <Text style={{ color: '#fff' }}>{f === 'all' ? '全部' : f === 'win' ? '只播得分' : f === 'loss' ? '只播失分' : '隨機'}</Text>
            </View>
          ))}
          {([0.5, 1, 2] as (0.5 | 1 | 2)[]).map((s) => (
            <Pressable
              key={String(s)}
              onPress={() => setSpeed(s)}
              style={{ paddingVertical: 6, paddingHorizontal: 10, borderRadius: 6, borderWidth: 1, borderColor: speed === s ? '#90caf9' : '#bbb', backgroundColor: speed === s ? 'rgba(144,202,249,0.15)' : 'rgba(255,255,255,0.05)', marginRight: 6 }}
            >
              <Text style={{ color: '#fff' }}>{s}x</Text>
            </Pressable>
          ))}
        </View>
      </View>
    </View>
  );
}ezbmt-tracked/src/components/MarkerSheet.tsx
 
import React from 'react';
import { View, Text, Modal, Pressable, ScrollView } from 'react-native';

type Props = {
  visible: boolean;
  data: { id: string; kind: 'win' | 'loss'; meta: any } | null;
  onClose: () => void;
  onDelete: (id: string) => void;
};

export default function MarkerSheet({ visible, data, onClose, onDelete }: Props) {
  if (!data) return null;
  const { id, kind, meta } = data;
  return (
    <Modal visible={visible} transparent animationType="slide" onRequestClose={onClose}>
      <View style={{ flex:1, backgroundColor:'rgba(0,0,0,0.35)', justifyContent:'flex-end' }}>
        <View style={{ backgroundColor:'#fff', borderTopLeftRadius:16, borderTopRightRadius:16, padding:16, maxHeight:'70%' }}>
          <Text style={{ fontSize:16, fontWeight:'600', marginBottom:8 }}>落點詳情</Text>
          <Text style={{ marginBottom:8 }}>結果：{kind === 'win' ? '得分' : '失分'}</Text>
          <ScrollView style={{ maxHeight:300 }}>
            <Text selectable style={{ color:'#444' }}>{JSON.stringify(meta || {}, null, 2)}</Text>
          </ScrollView>
          <View style={{ flexDirection:'row', justifyContent:'space-between', marginTop:12 }}>
            <Pressable onPress={() => onDelete(id)} style={{ padding:12, backgroundColor:'#d32f2f', borderRadius:8 }}>
              <Text style={{ color:'#fff' }}>刪除此筆</Text>
            </Pressable>
            <Pressable onPress={onClose} style={{ padding:12 }}>
              <Text>關閉</Text>
            </Pressable>
          </View>
        </View>
      </View>
    </Modal>
  );
}
ezbmt-tracked/src/components/HeatGrid.tsx
 
import React, { useMemo } from 'react';
import { View } from 'react-native';
import Svg, { Rect } from 'react-native-svg';

type Pt = { rx: number; ry: number; kind: 'win' | 'loss' };
type Props = {
width: number;
height: number;
points: Pt[]; // portrait 相對座標
grid: number; // 每格邊長（px）
mode?: 'all' | 'win' | 'loss';
};

export default function HeatGrid({ width, height, points, grid, mode = 'all' }: Props) {
const { cols, rows, cells, maxWin, maxLoss } = useMemo(() => {
const cols = Math.max(1, Math.floor(width / grid));
const rows = Math.max(1, Math.floor(height / grid));
const cells: Array<Array<{ win: number; loss: number }>> = Array.from({ length: rows }, () =>
Array.from({ length: cols }, () => ({ win: 0, loss: 0 }))
);
let maxWin = 0, maxLoss = 0;

for (let i = 0; i < points.length; i++) {
  const p = points[i];
  if (p.rx < 0 || p.rx > 1 || p.ry < 0 || p.ry > 1) continue;
  const cx = Math.min(cols - 1, Math.max(0, Math.floor(p.rx * cols)));
  const cy = Math.min(rows - 1, Math.max(0, Math.floor(p.ry * rows)));
  if (p.kind === 'win') cells[cy][cx].win += 1; else cells[cy][cx].loss += 1;
  if (cells[cy][cx].win > maxWin) maxWin = cells[cy][cx].win;
  if (cells[cy][cx].loss > maxLoss) maxLoss = cells[cy][cx].loss;
}
return { cols, rows, cells, maxWin, maxLoss };
}, [width, height, points, grid]);

const cellW = width / cols;
const cellH = height / rows;

return (
<View style={{ width, height }}>
<Svg width={width} height={height}>
{cells.map((row, y) =>
row.map((c, x) => {
if (c.win === 0 && c.loss === 0) return null;
let fill = 'transparent';
let alpha = 0;

        if (mode === 'win') {
          alpha = maxWin ? c.win / maxWin : 0;
          fill = `rgba(33,150,243,${0.15 + 0.55 * alpha})`;
        } else if (mode === 'loss') {
          alpha = maxLoss ? c.loss / maxLoss : 0;
          fill = `rgba(244,67,54,${0.15 + 0.55 * alpha})`;
        } else {
          const aWin = maxWin ? c.win / maxWin : 0;
          const aLoss = maxLoss ? c.loss / maxLoss : 0;
          if (aWin >= aLoss) {
            fill = `rgba(33,150,243,${0.15 + 0.55 * aWin})`;
          } else {
            fill = `rgba(244,67,54,${0.15 + 0.55 * aLoss})`;
          }
        }

        return (
          <Rect
            key={`${x}-${y}`}
            x={x * cellW}
            y={y * cellH}
            width={cellW}
            height={cellH}
            fill={fill}
          />
        );
      })
    )}
  </Svg>
</View>
);
}ezbmt-tracked/src/components/IntroShuttle.tsx
 
import React from 'react';
import { View, useWindowDimensions } from 'react-native';
import Svg, { Path, Circle, Line } from 'react-native-svg';
import Animated, {
useSharedValue,
useAnimatedStyle,
withRepeat,
withTiming,
Easing,
} from 'react-native-reanimated';

export default function IntroShuttle({ once = false }: { once?: boolean }) {
const { width } = useWindowDimensions();
const W = Math.min(width - 32, 560);
const H = 120;

const t = useSharedValue(0);

React.useEffect(() => {
const duration = 1600;
if (once) {
t.value = withTiming(1, { duration, easing: Easing.inOut(Easing.ease) });
} else {
t.value = withRepeat(
withTiming(1, { duration, easing: Easing.inOut(Easing.ease) }),
-1,
true
);
}
}, [once, t]);

// 動畫中的羽球位置與旋轉
const shuttleStyle = useAnimatedStyle(() => {
const x = 16 + (W - 32) * t.value;
const y = H * 0.65 - Math.sin(Math.PI * t.value) * (H * 0.42);
const dy =
(-Math.cos(Math.PI * t.value) * (H * 0.42) * Math.PI) / (W - 32);
const angle = Math.atan2(dy, 1); // 弧度

return {
  transform: [
    { translateX: x },
    { translateY: y },
    { rotate: angle + 'rad' },
    { translateX: -12 },
    { translateY: -12 },
  ],
};
});

// 幫助產生 Path d（不用模板字串，避免貼上時出錯）
const line = (x1: number, y1: number, x2: number, y2: number) =>
'M' + x1 + ' ' + y1 + ' L ' + x2 + ' ' + y2;
const quad = (x1: number, y1: number, cx: number, cy: number, x2: number, y2: number) =>
'M' + x1 + ' ' + y1 + ' Q ' + cx + ' ' + cy + ' ' + x2 + ' ' + y2;

return (
<View style={{ width: W, height: H, alignSelf: 'center' }}>
<Svg width={W} height={H}>
{/* 背景淡線 */}
<Path
d={line(0, H * 0.7, W, H * 0.7)}
stroke="#f0e6da"
strokeWidth={2}
opacity={0.4}
/>
<Path
d={line(0, H * 0.9, W, H * 0.9)}
stroke="#f0e6da"
strokeWidth={2}
opacity={0.2}
/>

    {/* 參考拋物線（淡藍） */}
    <Path
      d={quad(16, H * 0.65, W / 2, H * 0.1, W - 16, H * 0.65)}
      stroke="#1976d2"
      strokeWidth={2}
      fill="none"
      opacity={0.25}
    />
  </Svg>

  <Animated.View
    style={[{ position: 'absolute', left: 0, top: 0 }, shuttleStyle]}
  >
    {/* 迷你羽球圖形 */}
    <Svg width={24} height={24} viewBox="0 0 48 48">
      <Circle cx="18" cy="18" r="9" fill="#fff" />
      <Line
        x1="18"
        y1="22"
        x2="6"
        y2="34"
        stroke="#fff"
        strokeWidth={3}
        strokeLinecap="round"
      />
      <Line
        x1="22"
        y1="21"
        x2="11"
        y2="37"
        stroke="#fff"
        strokeWidth={3}
        strokeLinecap="round"
      />
      <Line
        x1="26"
        y1="19"
        x2="17"
        y2="38"
        stroke="#fff"
        strokeWidth={3}
        strokeLinecap="round"
      />
      <Circle
        cx="18"
        cy="18"
        r="11"
        stroke="#1976d2"
        strokeWidth={1.5}
        fill="none"
        opacity={0.4}
      />
    </Svg>
  </Animated.View>
</View>
);
}ezbmt-tracked/src/components/PS.tsx
 
import React from 'react';
import { View, Text, TextInput, Pressable, Alert, Image } from 'react-native';
import { supa, getCurrentUser } from '../lib/supabase';
import { useBgStore } from '../store/bg';
import { launchImageLibrary, type ImageLibraryOptions } from 'react-native-image-picker';

export default function ProfileScreen({ navigation }: any) {
const [name, setName] = React.useState('');
const [busy, setBusy] = React.useState(false);

const bgUri = useBgStore(s => s.uri);
const opacity = useBgStore(s => s.opacity);
const setOpacity = useBgStore(s => s.setOpacity);
const setFromBase64 = useBgStore(s => s.setFromBase64);
const clearBg = useBgStore(s => s.clear);

React.useEffect(() => {
(async () => {
const u = await getCurrentUser();
if (!u) return;
const { data } = await supa.from('profiles').select('name').eq('id', u.id).single();
if (data?.name) setName(String(data.name));
})();
}, []);

const save = async () => {
setBusy(true);
try {
const u = await getCurrentUser();
if (!u) throw new Error('未登入');
await supa.from('profiles').upsert({ id: u.id, name });
Alert.alert('成功', '已更新個人資料');
} catch (e: any) {
Alert.alert('失敗', String(e?.message || e));
} finally { setBusy(false); }
};

async function handleSignOut() {
try {
await supa.auth.signOut();   // 改用 supa.auth.signOut()
navigation.replace('Auth');
} catch (e:any) {
Alert.alert('登出失敗', String(e?.message || e));
}
}

async function pickBackground() {
try {
const opts: ImageLibraryOptions = {
mediaType: 'photo',
quality: 0.9,           // 修正：PhotoQuality（0~1），用 0.9
includeBase64: true,
selectionLimit: 1,
};
const res = await launchImageLibrary(opts);
if (res.didCancel) return;
const a = res.assets && res.assets[0];
if (!a?.base64) { Alert.alert('失敗', '此圖片無法取得內容，請再試一次'); return; }
const ext = (a.fileName?.split('.').pop() || (a.type?.split('/')?.pop() || 'jpg')).toLowerCase();
await setFromBase64(a.base64, ext);
Alert.alert('成功', '已設定背景圖');
} catch (e: any) {
Alert.alert('失敗', String(e?.message || e));
}
}

return (
<View style={{ flex:1, padding:16 }}>
<Text style={{ fontSize:16, fontWeight:'600', marginBottom:8 }}>個人資料</Text>
<TextInput
value={name}
onChangeText={setName}
placeholder="暱稱"
style={{ borderWidth:1, borderColor:'#ccc', borderRadius:8, paddingHorizontal:10, paddingVertical:8, marginBottom:10 }}
/>
<Pressable onPress={save} disabled={busy} style={{ backgroundColor:'#1976d2', paddingVertical:10, borderRadius:8, alignItems:'center', marginBottom:10 }}>
<Text style={{ color:'#fff' }}>儲存</Text>
</Pressable>
<Pressable onPress={handleSignOut} style={{ backgroundColor:'#d32f2f', paddingVertical:10, borderRadius:8, alignItems:'center', marginBottom:16 }}>
<Text style={{ color:'#fff' }}>登出</Text>
</Pressable>

  {/* 背景設定 */}
  <Text style={{ fontSize:16, fontWeight:'600', marginBottom:8 }}>背景圖片（本機）</Text>
  {bgUri ? (
    <View style={{ marginBottom: 10 }}>
      <Image source={{ uri: bgUri }} resizeMode="cover" style={{ width: '100%', height: 160, borderRadius: 8, backgroundColor:'#eee' }} />
      <Text style={{ color:'#555', marginTop:6 }}>目前透明度：{Math.round(opacity*100)}%</Text>
    </View>
  ) : (
    <Text style={{ color:'#666', marginBottom: 8 }}>尚未設定背景圖</Text>
  )}

  <View style={{ flexDirection:'row', flexWrap:'wrap', marginBottom:10 }}>
    <Pressable onPress={pickBackground} style={{ paddingVertical:8, paddingHorizontal:12, backgroundColor:'#1976d2', borderRadius:8, marginRight:8, marginBottom:8 }}>
      <Text style={{ color:'#fff' }}>選擇圖片</Text>
    </Pressable>
    {!!bgUri && (
      <Pressable onPress={clearBg} style={{ paddingVertical:8, paddingHorizontal:12, backgroundColor:'#9e9e9e', borderRadius:8, marginRight:8, marginBottom:8 }}>
        <Text style={{ color:'#fff' }}>清除背景</Text>
      </Pressable>
    )}
  </View>

  {!!bgUri && (
    <>
      <Text style={{ marginBottom:6 }}>透明度</Text>
      <View style={{ flexDirection:'row', flexWrap:'wrap' }}>
        {[0.15, 0.25, 0.4].map(v => (
          <Pressable
            key={String(v)}
            onPress={() => setOpacity(v)}
            style={{
              paddingVertical:6, paddingHorizontal:10, borderRadius:14,
              borderWidth:1, borderColor: opacity===v?'#1976d2':'#ccc',
              backgroundColor: opacity===v?'rgba(25,118,210,0.1)':'#fff',
              marginRight:8, marginBottom:8
            }}
          >
            <Text>{Math.round(v*100)}%</Text>
          </Pressable>
        ))}
      </View>
    </>
  )}
</View>
);
}ezbmt-tracked/src/components/CourtBackground.tsx
 
import React from 'react';
import Svg, { Rect, Line } from 'react-native-svg';

type Props = {
width: number;
height: number;
};

const FULL_LEN = 13.4;
const FULL_WID = 6.1;
const SHORT_LINE_DIST = 1.98;
const DBL_LONG_BACK = 0.76;

export default function CourtBackground({ width, height }: Props) {
const midY = height / 2;
const midX = width / 2;
const sy = height / FULL_LEN;
const sx = width / FULL_WID;

const topShort = midY - SHORT_LINE_DIST * sy;
const bottomShort = midY + SHORT_LINE_DIST * sy;
const topDblLong = 0 + DBL_LONG_BACK * sy;
const bottomDblLong = height - DBL_LONG_BACK * sy;

const singleInnerW = 5.18 * sx;
const singleLeft = (width - singleInnerW) / 2;
const singleRight = width - singleLeft;

const line = '#f0e6da';
const lineW = Math.max(2, Math.round(Math.min(width, height) * 0.012));

return (
<Svg width={width} height={height}>
{/* 草地 */}
<Rect x={0} y={0} width={width} height={height} fill="#2e7d32" />

  {/* 外框 */}
  <Line x1={0} y1={0} x2={width} y2={0} stroke={line} strokeWidth={lineW} />
  <Line x1={0} y1={height} x2={width} y2={height} stroke={line} strokeWidth={lineW} />
  <Line x1={0} y1={0} x2={0} y2={height} stroke={line} strokeWidth={lineW} />
  <Line x1={width} y1={0} x2={width} y2={height} stroke={line} strokeWidth={lineW} />

  {/* 單打邊線 */}
  <Line x1={singleLeft} y1={0} x2={singleLeft} y2={height} stroke={line} strokeWidth={lineW} />
  <Line x1={singleRight} y1={0} x2={singleRight} y2={height} stroke={line} strokeWidth={lineW} />

  {/* 網 */}
  <Line x1={0} y1={midY} x2={width} y2={midY} stroke={line} strokeWidth={lineW} />

  {/* 短發球線 */}
  <Line x1={0} y1={topShort} x2={width} y2={topShort} stroke={line} strokeWidth={lineW} />
  <Line x1={0} y1={bottomShort} x2={width} y2={bottomShort} stroke={line} strokeWidth={lineW} />

  {/* 中央分界線（短發球線之上/之下） */}
  <Line x1={midX} y1={topShort} x2={midX} y2={0} stroke={line} strokeWidth={lineW} />
  <Line x1={midX} y1={bottomShort} x2={midX} y2={height} stroke={line} strokeWidth={lineW} />

  {/* 雙打長發球線 */}
  <Line x1={0} y1={topDblLong} x2={width} y2={topDblLong} stroke={line} strokeWidth={lineW} />
  <Line x1={0} y1={bottomDblLong} x2={width} y2={bottomDblLong} stroke={line} strokeWidth={lineW} />
</Svg>
);
}ezbmt-tracked/src/components/ZoneMatrix.tsx
 
import React from 'react';
import { View, Text } from 'react-native';

type Stat = { win: number; loss: number };
type Props = {
stats: Record<string, Stat>; // key: '1'..'6' | 'out'
showOut?: boolean;
title?: string;
};

export default function ZoneMatrix({ stats, showOut = true, title }: Props) {
// 顯示順序：1,2 | 5,6 | 3,4
const zones = ['1', '2', '5', '6', '3', '4'];
const outStat = stats['out'] || { win: 0, loss: 0 };

const totals = zones.map((z) => {
const st = stats[z] || { win: 0, loss: 0 };
return st.win + st.loss;
});
const maxTotal = Math.max(1, ...totals, showOut ? outStat.win + outStat.loss : 0);

const renderCell = (z: string) => {
const st = stats[z] || { win: 0, loss: 0 };
const total = st.win + st.loss;
const alpha = total ? 0.15 + 0.6 * (total / maxTotal) : 0.1;
const bg = 'rgba(76,175,80,' + alpha + ')';
const winPct = total ? (st.win / total) * 100 : 0;

return (
  <View
    key={z}
    style={{
      width: '48%',
      aspectRatio: 1.2,
      marginBottom: 8,
      borderWidth: 1,
      borderColor: '#eee',
      borderRadius: 10,
      padding: 8,
      backgroundColor: bg,
    }}
  >
    <Text style={{ fontWeight: '600', marginBottom: 4 }}>區 {z}</Text>
    <Text style={{ color: '#333' }}>總數：{total}</Text>

    <View
      style={{
        height: 10,
        backgroundColor: '#eee',
        borderRadius: 6,
        overflow: 'hidden',
        marginTop: 6,
      }}
    >
      <View
        style={{
          width: winPct + '%',
          backgroundColor: '#2196f3',
          height: '100%',
        }}
      />
    </View>

    <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginTop: 4 }}>
      <Text style={{ color: '#1976d2' }}>得：{st.win}</Text>
      <Text style={{ color: '#d32f2f' }}>失：{st.loss}</Text>
    </View>
  </View>
);
};

const outTotal = outStat.win + outStat.loss;
const outWinPct = outTotal ? (outStat.win / outTotal) * 100 : 0;

return (
<View>
{title ? <Text style={{ fontSize: 16, fontWeight: '600', marginBottom: 8 }}>{title}</Text> : null}

  <View style={{ flexDirection: 'row', flexWrap: 'wrap', justifyContent: 'space-between' }}>
    {zones.map(renderCell)}

    {showOut ? (
      <View style={{ width: '100%', marginTop: 6 }}>
        <View
          style={{
            borderWidth: 1,
            borderColor: '#eee',
            borderRadius: 10,
            padding: 10,
            backgroundColor: '#fafafa',
          }}
        >
          <Text style={{ fontWeight: '600', marginBottom: 4 }}>界外（OUT）</Text>

          <View
            style={{
              height: 10,
              backgroundColor: '#eee',
              borderRadius: 6,
              overflow: 'hidden',
              marginTop: 6,
            }}
          >
            <View
              style={{
                width: outWinPct + '%',
                backgroundColor: '#2196f3',
                height: '100%',
              }}
            />
          </View>

          <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginTop: 4 }}>
            <Text style={{ color: '#1976d2' }}>得：{outStat.win}</Text>
            <Text style={{ color: '#d32f2f' }}>失：{outStat.loss}</Text>
          </View>
        </View>
      </View>
    ) : null}
  </View>
</View>
);
}ezbmt-tracked/src/components/Heatmap.tsx
 
import React, { useMemo } from 'react';
import { View } from 'react-native';
import Svg, { Rect, Circle } from 'react-native-svg';

type Pt = { rx: number; ry: number; kind: 'win' | 'loss' };
type Props = {
width: number;
height: number;
points: Pt[]; // portrait 相對座標，允許 <0 或 >1（界外）
dotRadius?: number;
blur?: boolean; // 預留：漸層熱區（此版先畫散點）
};

export default function Heatmap({ width, height, points, dotRadius = 6 }: Props) {
// 有界裁切（只顯示場內點；界外點可選擇另外顯示）
const inside = useMemo(
() => points.filter(p => p.rx >= 0 && p.rx <= 1 && p.ry >= 0 && p.ry <= 1),
[points]
);

return (
<View style={{ width, height }}>
<Svg width={width} height={height}>
<Rect x={0} y={0} width={width} height={height} fill="transparent" />
{inside.map((p, idx) => {
const x = p.rx * width;
const y = p.ry * height;
const fill = p.kind === 'win' ? 'rgba(33,150,243,0.45)' : 'rgba(244,67,54,0.45)';
const stroke = p.kind === 'win' ? 'rgba(33,150,243,0.9)' : 'rgba(244,67,54,0.9)';
return <Circle key={idx} cx={x} cy={y} r={dotRadius} fill={fill} stroke={stroke} strokeWidth={2} />;
})}
</Svg>
</View>
);
}
ezbmt-tracked/src/components/SimpleBarChart.tsx
 
import React from 'react';
import { View, Text, LayoutChangeEvent } from 'react-native';

export type BarRow = { label: string; win: number; loss: number };

type Props = {
data: BarRow[];
maxItems?: number;
title?: string;
};

export default function SimpleBarChart({ data, maxItems = 8, title }: Props) {
const rows = data.slice(0, maxItems);
const maxVal = Math.max(1, ...rows.map(r => r.win + r.loss));

return (
<View>
{title ? <Text style={{ fontSize: 16, fontWeight: '600', marginBottom: 8 }}>{title}</Text> : null}

  {rows.map((r) => (
    <BarRowItem key={r.label} row={r} maxVal={maxVal} />
  ))}
</View>
);
}

function BarRowItem({ row, maxVal }: { row: BarRow; maxVal: number }) {
const total = row.win + row.loss;
const [trackW, setTrackW] = React.useState(0); // px width of whole track

const onLayout = (e: LayoutChangeEvent) => {
const w = e.nativeEvent.layout.width || 0;
if (w !== trackW) setTrackW(Math.max(0, Math.floor(w)));
};

// bar 寬度（以 px 計算，不用百分比字串）
const barW = trackW * (total / maxVal);
const winW = total ? barW * (row.win / total) : 0;

return (
<View style={{ marginBottom: 10 }}>
<View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
<Text>{row.label}</Text>
<Text style={{ color: '#555' }}>{total} 次</Text>
</View>

  <View
    onLayout={onLayout}
    style={{
      alignSelf: 'stretch',
      height: 14,
      backgroundColor: '#eee',
      borderRadius: 8,
      overflow: 'hidden',
    }}
  >
    <View
      style={{
        width: barW,
        height: 14,
        backgroundColor: '#ffcdd2',
      }}
    >
      <View
        style={{
          width: winW,
          height: 14,
          backgroundColor: '#90caf9',
        }}
      />
    </View>
  </View>

  <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginTop: 4 }}>
    <Text style={{ color: '#1976d2' }}>得：{row.win}</Text>
    <Text style={{ color: '#d32f2f' }}>失：{row.loss}</Text>
  </View>
</View>
);
}ezbmt-tracked/src/lib/syncDown.ts
 
import { supa } from './supabase';
import SQLite from 'react-native-sqlite-storage';
import { openDB } from '../db/sqlite'; // 若你的 openDB 在聚合層，改對應路徑

export async function syncDownOnce() {
const d = await openDB();

// 取 last sync
let since = '1970-01-01T00:00:00.000Z';
try {
const [res] = await d.executeSql('SELECT v FROM meta WHERE k=?', ['last_down_sync_at']);
if (res.rows.length) since = String(res.rows.item(0).v);
} catch {}

// 拉資料（RPC）
const [ev, mt, rl] = await Promise.all([
supa.rpc('pull_events_since', { p_since: since }),
supa.rpc('pull_matches_since', { p_since: since }),
supa.rpc('pull_rallies_since', { p_since: since }),
]);
if (ev.error) throw ev.error;
if (mt.error) throw mt.error;
if (rl.error) throw rl.error;

// 本地 upsert
const now = new Date().toISOString();

await d.executeSql('BEGIN');

for (const e of ev.data || []) {
await d.executeSql(
'REPLACE INTO events (id,name,level,venue,start_at,end_at) VALUES (?,?,?,?,?,?)',
[e.id, e.name, e.level || null, e.venue || null, e.start_at || null, e.end_at || null]
);
}

for (const m of mt.data || []) {
await d.executeSql(
'REPLACE INTO matches (id,event_id,type,court_no,rules_json,created_at) VALUES (?,?,?,?,?,?)',
[m.id, m.event_id, m.type, m.court_no || null, JSON.stringify(m.rules_json || null), m.created_at]
);
}

for (const r of rl.data || []) {
await d.executeSql(
'REPLACE INTO rallies (id,match_id,game_index,rally_no,winner_side,end_zone,meta_json,route_start_x,route_start_y,route_end_x,route_end_y,created_at) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)',
[
r.id, r.match_id, r.game_index, r.rally_no, r.winner_side, r.end_zone,
JSON.stringify(r.meta_json || null),
r.route_start_x ?? null, r.route_start_y ?? null, r.route_end_x ?? null, r.route_end_y ?? null,
r.created_at
]
);
}

await d.executeSql('REPLACE INTO meta(k,v) VALUES(?,?)', ['last_down_sync_at', now]);
await d.executeSql('COMMIT');
}

export function startSyncDownLoop() {
// 前景每 60 秒跑一次
syncDownOnce().catch(()=>{});
return setInterval(()=>syncDownOnce().catch(()=>{}), 60_000);
}
ezbmt-tracked/src/lib/storage.ts
 
import { supa, SUPABASE_URL } from './supabase'

// base64 -> Uint8Array（純 JS，不依賴外部套件）
function base64ToUint8Array(base64: string): Uint8Array {
const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
let str = base64.replace(/[^A-Za-z0-9+/=]/g, '');
const len = str.length;
let bufferLength = str.length * 0.75;
if (str[str.length - 1] === '=') bufferLength--;
if (str[str.length - 2] === '=') bufferLength--;
const bytes = new Uint8Array(bufferLength);
let p = 0;
for (let i = 0; i < len; i += 4) {
const c1 = chars.indexOf(str[i]);
const c2 = chars.indexOf(str[i + 1]);
const c3 = chars.indexOf(str[i + 2]);
const c4 = chars.indexOf(str[i + 3]);
const n = (c1 << 18) | (c2 << 12) | ((c3 & 63) << 6) | (c4 & 63);
bytes[p++] = (n >> 16) & 255;
if (str[i + 2] !== '=') bytes[p++] = (n >> 8) & 255;
if (str[i + 3] !== '=') bytes[p++] = n & 255;
}
return bytes;
}

function ensureClient() {
if (!supa) {
throw new Error('Supabase client 未初始化。請檢查 src/lib/supabase.ts 是否已 createClient。');
}
if (!(supa as any).storage) {
throw new Error('supa.storage 不可用，請確認 @supabase/supabase-js 已安裝與 polyfill 已加入。');
}
}

// 主要：從 URI 讀檔並上傳（先嘗試 fetch arrayBuffer，失敗時用 RNFS 讀 file://）
export async function uploadImageFromUri(uri: string, path: string, contentType = 'image/jpeg'): Promise<string> {
ensureClient();

let ab: ArrayBuffer | null = null;

// 1) 優先用 fetch 取得 arrayBuffer（RN 0.71+ 支援）
try {
const res = await fetch(uri);
if (res && typeof (res as any).arrayBuffer === 'function') {
ab = await (res as any).arrayBuffer();
} else if (res && typeof (res as any).blob === 'function') {
const blob = await (res as any).blob();
if (blob && typeof (blob as any).arrayBuffer === 'function') {
ab = await (blob as any).arrayBuffer();
}
}
} catch {
// 忽略，改走 RNFS
}

// 2) 若還是空，且是 file://，改用 RNFS 讀 base64 再轉 ArrayBuffer
if ((!ab || ab.byteLength === 0) && uri.startsWith('file://')) {
try {
const RNFS = require('react-native-fs');
const base64 = await RNFS.readFile(uri.replace('file://', ''), 'base64');
const u8 = base64ToUint8Array(base64);
ab = u8.buffer;
} catch (_e) {
// 留待最後檢查
}
}

if (!ab || ab.byteLength === 0) {
throw new Error('讀取圖片內容失敗（arrayBuffer 為空）。請改用 includeBase64 或確認 uri 可讀。');
}

const { data, error } = await supa.storage.from('media').upload(path, ab, { contentType, upsert: false });
if (error) throw error;
return data?.path || path;
}

// 若 image-picker 有回傳 base64，可用這個直接上傳
export async function uploadImageBase64(base64: string, path: string, contentType = 'image/jpeg'): Promise<string> {
ensureClient();
const u8 = base64ToUint8Array(base64);
const ab = u8.buffer;
const { data, error } = await supa.storage.from('media').upload(path, ab, { contentType, upsert: false });
if (error) throw error;
return data?.path || path;
}

export function getPublicUrl(path: string): string {
ensureClient();
const { data } = supa.storage.from('media').getPublicUrl(path);
return data.publicUrl;
}

export async function removeFile(path: string): Promise<void> {
ensureClient();
const { error } = await supa.storage.from('media').remove([path]);
if (error) throw error;
}

export function publicUrlToPath(url: string): string | null {
try {
const marker = '/storage/v1/object/public/media/';
const idx = url.indexOf(marker);
if (idx < 0) return null;
return url.slice(idx + marker.length);
} catch {
return null;
}
}

export async function getSignedUploadUrl(matchId: string, ext: string, contentType: string) {
const { data, error } = await supa.functions.invoke('sign-upload', {
body: { matchId, contentType, ext },
});
if (error) throw error;
return data as { path: string; signedUrl: string };
}

export async function uploadToSignedUrl(signedUrl: string, data: ArrayBuffer, contentType: string) {
const res = await fetch(signedUrl, {
method: 'PUT',
headers: { 'content-type': contentType },
body: data,
});
//if (!res.ok) throw new Error(upload failed: ${res.status});
}
ezbmt-tracked/src/lib/export.ts
 
import RNHTMLtoPDF from 'react-native-html-to-pdf';
import Share from 'react-native-share';

function esc(s: any) { return String(s == null ? '' : s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

function courtSvg(w:number,h:number, routes: Array<{ rx:number; ry:number; kind:'win'|'loss' }>): string {
  const lines = [];
  const line = '#f0e6da';
  const lw = Math.max(2, Math.round(Math.min(w, h) * 0.012));
  const midY = h/2, midX = w/2;
  const sy = h / 13.4, sx = w / 6.1;
  const tS = midY - 1.98 * sy, bS = midY + 1.98 * sy;
  const tL = 0 + 0.76 * sy, bL = h - 0.76 * sy;
  const singleLeft = (w - (5.18 * sx)) / 2, singleRight = w - singleLeft;

  function L(x1:number,y1:number,x2:number,y2:number){ lines.push(`<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${line}" stroke-width="${lw}" />`); }

  const court = [
    `<rect x="0" y="0" width="${w}" height="${h}" fill="#2e7d32" />`,
    `<rect x="0" y="0" width="${w}" height="${h}" fill="none" stroke="${line}" stroke-width="${lw}" />`,
    `<line x1="${singleLeft}" y1="0" x2="${singleLeft}" y2="${h}" stroke="${line}" stroke-width="${lw}" />`,
    `<line x1="${singleRight}" y1="0" x2="${singleRight}" y2="${h}" stroke="${line}" stroke-width="${lw}" />`,
    `<line x1="0" y1="${midY}" x2="${w}" y2="${midY}" stroke="${line}" stroke-width="${lw}" />`,
    `<line x1="0" y1="${tS}" x2="${w}" y2="${tS}" stroke="${line}" stroke-width="${lw}" />`,
    `<line x1="0" y1="${bS}" x2="${w}" y2="${bS}" stroke="${line}" stroke-width="${lw}" />`,
    `<line x1="${midX}" y1="${tS}" x2="${midX}" y2="0" stroke="${line}" stroke-width="${lw}" />`,
    `<line x1="${midX}" y1="${bS}" x2="${midX}" y2="${h}" stroke="${line}" stroke-width="${lw}" />`,
    `<line x1="0" y1="${tL}" x2="${w}" y2="${tL}" stroke="${line}" stroke-width="${lw}" />`,
    `<line x1="0" y1="${bL}" x2="${w}" y2="${bL}" stroke="${line}" stroke-width="${lw}" />`,
  ].join('\n');

  const dots = routes
    .filter(p => p.rx>=0 && p.rx<=1 && p.ry>=0 && p.ry<=1)
    .map((p) => {
      const x = Math.round(p.rx * w), y = Math.round(p.ry * h);
      const fill = p.kind === 'win' ? 'rgba(33,150,243,0.55)' : 'rgba(244,67,54,0.55)';
      const stroke = p.kind === 'win' ? 'rgba(33,150,243,0.95)' : 'rgba(244,67,54,0.95)';
      return `<circle cx="${x}" cy="${y}" r="6" fill="${fill}" stroke="${stroke}" stroke-width="2" />`;
    }).join('\n');

  return `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">${court}${lines.join('')}${dots}</svg>`;
}

function shotBarHtml(rows: Array<{ label:string; win:number; loss:number }>) {
  const max = Math.max(1, ...rows.map(r=>r.win+r.loss));
  return rows.map(r => {
    const total = r.win + r.loss;
    const widthPct = Math.round(total / max * 100);
    const winPct = total ? Math.round(r.win / total * 100) : 0;
    return `
      <div style="margin-bottom:8px">
        <div style="display:flex;justify-content:space-between;margin-bottom:2px">
          <span>${esc(r.label)}</span><span style="color:#555">${total} 次</span>
        </div>
        <div style="height:12px;background:#eee;border-radius:6px;overflow:hidden">
          <div style="width:${widthPct}%;height:100%;background:#ffcdd2">
            <div style="width:${winPct}%;height:100%;background:#90caf9"></div>
          </div>
        </div>
      </div>
    `;
  }).join('\n');
}

function routeThumbs(th: Array<{ sx:number; sy:number; ex:number; ey:number; kind:'win'|'loss' }>, cols=4, size=150) {
  const items = th.map((r,i) => {
    const color = r.kind==='win'?'#1976d2':'#d32f2f';
    return `
      <div style="width:${size}px;height:${Math.round(size*13.4/6.1)}px;border-radius:8px;overflow:hidden;background:#e8f5e9;margin:6px">
        <svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${Math.round(size*13.4/6.1)}" viewBox="0 0 ${size} ${Math.round(size*13.4/6.1)}">
          <line x1="${r.sx*size}" y1="${r.sy*Math.round(size*13.4/6.1)}" x2="${r.ex*size}" y2="${r.ey*Math.round(size*13.4/6.1)}" stroke="${color}" stroke-width="4" stroke-dasharray="8,6" opacity="0.7" />
        </svg>
      </div>
    `;
  }).join('\n');
  return `<div style="display:flex;flex-wrap:wrap">${items}</div>`;
}

export async function exportPdfReport(matchId: string, args: {
  points: Array<{ rx:number; ry:number; kind:'win'|'loss' }>;
  zoneStat: Record<string,{ win:number; loss:number }>;
  metaStat: Array<{ shot?:string; force?:string; reason?:string; count:number }>;
  shotAgg?: Array<{ label:string; win:number; loss:number }>;
  routesSample?: Array<{ sx:number; sy:number; ex:number; ey:number; kind:'win'|'loss' }>;
}) {
  const svg = courtSvg(305, 670, args.points);
  const zoneHtml = (() => {
    const keys = Object.keys(args.zoneStat);
    keys.sort();
    const rows = keys.map(k => `<tr><td>${k}</td><td>${args.zoneStat[k].win}</td><td>${args.zoneStat[k].loss}</td></tr>`).join('\n');
    return `<table><tr><th>區</th><th>得分</th><th>失分</th></tr>${rows}</table>`;
  })();
  const metaHtml = args.metaStat.map(m => `<tr><td>${esc(m.shot||'')}</td><td>${esc(m.force||'')}</td><td>${esc(m.reason||'')}</td><td>${m.count}</td></tr>`).join('\n');
  const barHtml = args.shotAgg && args.shotAgg.length ? shotBarHtml(args.shotAgg) : '';
  const thumbs = args.routesSample && args.routesSample.length ? routeThumbs(args.routesSample.slice(0,12), 4, 140) : '';

  const html =
    `<html><head><meta charset="utf-8"/><style>
      body{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;padding:16px;}
      h1{font-size:20px;margin:0 0 8px 0;} h2{font-size:16px;margin:16px 0 8px 0;}
      table{border-collapse:collapse;width:100%;} td,th{border:1px solid #ddd;padding:6px;}
    </style></head><body>
      <h1>Badminton Report</h1>
      <div style="display:flex;gap:16px;align-items:flex-start">
        <div>${svg}</div>
        <div style="flex:1">
          <h2>區域統計</h2>${zoneHtml}
          <h2 style="margin-top:12px">球種 × 主/受迫 × 原因</h2><table>
            <tr><th>球種</th><th>主/受迫</th><th>原因</th><th>次數</th></tr>${metaHtml}
          </table>
          ${barHtml ? '<h2 style="margin-top:12px">球種分布（得/失）</h2>'+barHtml : ''}
        </div>
      </div>
      ${thumbs ? '<h2>球路縮圖（前 12 球）</h2>'+thumbs : ''}
    </body></html>`;

  const file = await RNHTMLtoPDF.convert({ html, fileName: 'match-' + String(matchId) + '-' + String(Date.now()), base64: false });
  if (file && file.filePath) await Share.open({ url: 'file://' + file.filePath, type: 'application/pdf', filename: 'report.pdf', failOnCancel: false });
}
ezbmt-tracked/src/lib/exportPdf.ts
 
import { Platform } from 'react-native';
import RNFS from 'react-native-fs';
import Share, { ShareOptions } from 'react-native-share';
function getCacheDir(): string {
return RNFS.CachesDirectoryPath;
}
function buildName(matchId: string, ext: string): string {
const ts = String(Date.now());
const safeId = String(matchId).replace(/[^a-zA-Z0-9_-]/g, '-');
return 'match-' + safeId + '-' + ts + '.' + ext;
}
async function writeAndShare(path: string, mime: string, filename: string): Promise<void> {
const opts: ShareOptions = {
url: 'file://' + path,
type: mime,
filename: filename,
failOnCancel: false,
showAppsToView: true
};
try {
await Share.open(opts);
} catch (e: any) {
const msg = e && e.message ? String(e.message).toLowerCase() : String(e).toLowerCase();
if (msg.indexOf('cancel') >= 0) return;
throw e;
}
}
export async function shareCsv(matchId: string, csvText: string): Promise<void> {
const dir = getCacheDir();
const name = buildName(matchId, 'csv');
const path = dir + '/' + name;
const text = String(csvText == null ? '' : csvText);
try {
await RNFS.writeFile(path, text, 'utf8');
} catch (_e) {
const exists = await RNFS.exists(dir);
if (!exists) await RNFS.mkdir(dir);
await RNFS.writeFile(path, text, 'utf8');
}
await writeAndShare(path, 'text/csv', name);
}
export async function shareJson(matchId: string, jsonObj: any): Promise<void> {
let text = '';
try { text = JSON.stringify(jsonObj == null ? {} : jsonObj, null, 2); } catch (_e) { text = '{}'; }
const dir = getCacheDir();
const name = buildName(matchId, 'json');
const path = dir + '/' + name;
try {
await RNFS.writeFile(path, text, 'utf8');
} catch (_e) {
const exists = await RNFS.exists(dir);
if (!exists) await RNFS.mkdir(dir);
await RNFS.writeFile(path, text, 'utf8');
}
await writeAndShare(path, 'application/json', name);
}
ezbmt-tracked/src/lib/supabase.ts
 
import { createClient, type SupabaseClient } from '@supabase/supabase-js';
import AsyncStorage from '@react-native-async-storage/async-storage';
export const supa = createClient("https://uejjamgowybupzwsjctk.supabase.co", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVlamphbWdvd3lidXB6d3NqY3RrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTczOTgxMjEsImV4cCI6MjA3Mjk3NDEyMX0.MtkQ7RGDq883ZecG3OxG6-ImsnZfD4QBLZpNYW7DWy8", { auth: { persistSession: true, autoRefreshToken: true } });
/* Events */
export const SUPABASE_URL="https://uejjamgowybupzwsjctk.supabase.co";
export async function insertEvent(e: { id?: string; name: string; level?: string; venue?: string; start_at?: string; end_at?: string; }) {
const { data, error } = await supa.from('events').insert({
id: e.id, name: e.name, level: e.level ?? null, venue: e.venue ?? null,
start_at: e.start_at ?? null, end_at: e.end_at ?? null,
}).select('id').single();
if (error) throw error;
return data.id;
}
export async function listEvents(): Promise<Array<{ id: string; name: string }>> {
const { data, error } = await supa.from('events').select('id,name').order('name', { ascending: true });
if (error) throw error;
return data || [];
}

/* Matches */
export async function insertMatch(m: { id?: string; event_id: string; type: string; court_no?: string; rules_json?: string; }) {
const rules = m.rules_json ? JSON.parse(m.rules_json) : null;
const { error } = await supa.from('matches').insert({
id: m.id, event_id: m.event_id, type: m.type, court_no: m.court_no ?? null, rules_json: rules,
});
if (error) throw error;
}
export async function listMatches(eventId: string) {
const { data, error } = await supa.from('matches')
.select('id,type,court_no,rules_json,record_mode')
.eq('event_id', eventId)
.order('created_at', { ascending: false });
if (error) throw error;
return data || [];
}
export async function updateMatchRules(matchId: string, rulesJson: string) {
const { error } = await supa.from('matches').update({ rules_json: JSON.parse(rulesJson) }).eq('id', matchId);
if (error) throw error;
}
export async function setMatchRecordMode(matchId: string, mode: 'tap' | 'route') {
const { error } = await supa.from('matches').update({ record_mode: mode }).eq('id', matchId);
if (error) throw error;
}
export async function saveMatchState(matchId: string, stateJson: string) {
const { error } = await supa.from('matches').update({ state_json: JSON.parse(stateJson) }).eq('id', matchId);
if (error) throw error;
}
export async function getMatch(matchId: string) {
const { data, error } = await supa.from('matches').select('*').eq('id', matchId).single();
if (error) throw error;
return data;
}

/* Players */
export async function upsertMatchPlayers(args: {
matchId: string;
home: { idx: 0 | 1; name?: string; gender?: string; handedness?: string }[];
away: { idx: 0 | 1; name?: string; gender?: string; handedness?: string }[];
}) {
const all = [
...args.home.map(p => ({ ...p, side: 'home' })),
...args.away.map(p => ({ ...p, side: 'away' })),
];
for (const p of all) {
const { error } = await supa.from('match_players').upsert({
match_id: args.matchId, side: p.side, idx: p.idx,
name: p.name ?? null, gender: p.gender ?? null, handedness: p.handedness ?? null,
});
if (error) throw error;
}
}
export async function getMatchPlayers(matchId: string) {
const { data, error } = await supa.from('match_players')
.select('side, idx, name, gender, handedness')
.eq('match_id', matchId);
if (error) throw error;
return data || [];
}
export async function updateStartConfigs(args: {
matchId: string; startingServerTeam: 0 | 1; startingServerIndex: 0 | 1; homeRightWhenEven: 0 | 1; awayRightWhenEven: 0 | 1;
}) {
const { error } = await supa.from('matches').update({
starting_server_team: args.startingServerTeam,
starting_server_index: args.startingServerIndex,
home_right_when_even_index: args.homeRightWhenEven,
away_right_when_even_index: args.awayRightWhenEven,
}).eq('id', args.matchId);
if (error) throw error;
}

/* Rallies */
export async function insertRally(r: {
id: string; match_id: string; game_index: number; rally_no: number;
winner_side: string; end_zone: string; meta_json: string;
route_start_x?: number | null; route_start_y?: number | null;
route_end_x?: number | null; route_end_y?: number | null;
route_start_rx?: number | null; route_start_ry?: number | null;
route_end_rx?: number | null; route_end_ry?: number | null;
created_at: string;
}) {
const { error } = await supa.from('rallies').insert({
id: r.id, match_id: r.match_id, game_index: r.game_index, rally_no: r.rally_no,
winner_side: r.winner_side, end_zone: r.end_zone,
meta_json: r.meta_json ? JSON.parse(r.meta_json) : null,
route_start_x: r.route_start_x ?? null, route_start_y: r.route_start_y ?? null,
route_end_x: r.route_end_x ?? null, route_end_y: r.route_end_y ?? null,
route_start_rx: r.route_start_rx ?? null, route_start_ry: r.route_start_ry ?? null,
route_end_rx: r.route_end_rx ?? null, route_end_ry: r.route_end_ry ?? null,
created_at: r.created_at,
});
if (error) throw error;
}
export async function listRecentRallies(matchId: string, limit = 20) {
const { data, error } = await supa.from('rallies').select('*').eq('match_id', matchId).order('created_at', { ascending: false }).limit(limit);
if (error) throw error; return data || [];
}
export async function listRalliesOrdered(matchId: string) {
const { data, error } = await supa.from('rallies').select('*').eq('match_id', matchId)
.order('game_index', { ascending: true }).order('rally_no', { ascending: true });
if (error) throw error; return data || [];
}
export async function getLastRally(matchId: string) {
const { data, error } = await supa.from('rallies').select('*').eq('match_id', matchId)
.order('created_at', { ascending: false }).limit(1);
if (error) throw error;
return data && data.length ? data[0] : null;
}
export async function deleteRally(id: string) {
const { error } = await supa.from('rallies').delete().eq('id', id);
if (error) throw error;
}

/* Games summary */
export async function upsertGameSummary(args: {
matchId: string; gameIndex: number;
home: number; away: number;
winnerTeam: 0 | 1 | null;
intervalTaken: boolean; deciderSwitched: boolean;
}) {
// 以 UPSERT 模擬 SQLite 的 upsert 行為
const id = cryptoRandomId(args.matchId + '-g' + args.gameIndex);
const { error } = await supa.from('games').upsert({
id,
match_id: args.matchId,
index_no: args.gameIndex,
home_score: args.home,
away_score: args.away,
winner_team: args.winnerTeam,
interval_taken: args.intervalTaken,
decider_sides_switched: args.deciderSwitched,
}, { onConflict: 'match_id,index_no' });
if (error) throw error;
}
function cryptoRandomId(seed: string) {
// 產生穩定 id（非必要，亦可直接讓 DB 自動生成）
return seed;
}

/* Chat */
export async function insertChatMessage(args: { matchId: string; user?: string; text: string; createdAt?: string }) {
const { error } = await supa.from('chat_messages').insert({
match_id: args.matchId,
user_name: args.user ?? null,
text: args.text,
created_at: args.createdAt ?? new Date().toISOString(),
});
if (error) throw error;
}
export async function listChatMessages(matchId: string, limit = 200) {
const { data, error } = await supa.from('chat_messages').select('*').eq('match_id', matchId).order('created_at', { ascending: false }).limit(limit);
if (error) throw error; return data || [];
}

/* Media */
export async function insertMedia(m: { id?: string; owner_type: 'event'|'match'; owner_id: string; kind: 'youtube'|'photo'; url: string; description?: string }) {
const { error } = await supa.from('media').insert({
id: m.id, owner_type: m.owner_type, owner_id: m.owner_id, kind: m.kind,
url: m.url, description: m.description ?? null,
});
if (error) throw error;
}
export async function listMedia(owner_type: 'event'|'match', owner_id: string) {
const { data, error } = await supa.from('media').select('*').eq('owner_type', owner_type).eq('owner_id', owner_id).order('created_at', { ascending: false });
if (error) throw error; return data || [];
}
export async function deleteMedia(id: string) {
const { error } = await supa.from('media').delete().eq('id', id);
if (error) throw error;
}

/* Dictionaries */
export async function listDictionary(kind: 'shot_type'|'error_reason') {
const { data, error } = await supa.from('dictionaries')
.select('id,label,value,order_no').eq('kind', kind)
.order('order_no', { ascending: true }).order('label', { ascending: true });
if (error) throw error; return data || [];
}
export async function upsertDictionary(item: { id?: string; kind:'shot_type'|'error_reason'; label:string; value?:string; order_no?:number }) {
const { error } = await supa.from('dictionaries').upsert({
id: item.id, kind: item.kind, label: item.label, value: item.value ?? item.label, order_no: item.order_no ?? 0,
});
if (error) throw error;
}
export async function deleteDictionary(id: string) {
const { error } = await supa.from('dictionaries').delete().eq('id', id);
if (error) throw error;
}

/* Live/Replay 補充 */
export async function getRalliesByIds(ids: string[]): Promise<any[]> {
if (!ids || !ids.length) return [];
const { data, error } = await supa.from('rallies').select('*').in('id', ids);
if (error) throw error;
const out = data || [];
out.sort((a: any, b: any) => (a.game_index === b.game_index ? (a.rally_no - b.rally_no) : (a.game_index - b.game_index)));
return out;
}

export async function getCurrentUser() {
const { data, error } = await supa.auth.getUser();
if (error) return null;
return data.user || null;
}

ezbmt-tracked/src/lib/backend.ts
 
export type Backend = 'sqlite' | 'supabase';
export const BACKEND: Backend = 'supabase'; // 調整這行即可切換
ezbmt-tracked/src/lib/supabase_bak.ts
 
export type LiveSnapshot = {
scoreA: number; scoreB: number;
servingTeam: 0|1;
server?: { team:0|1; index:0|1; court:'R'|'L' };
receiver?: { team:0|1; index:0|1; court:'R'|'L' };
players?: Array<{ name?: string }>;
};

export const supa = null;

export async function publishLiveState(_matchId: string, _snap: LiveSnapshot) {
// no-op
}
export function subscribeLive(_matchId: string, _onState: (s: LiveSnapshot) => void) {
return { unsubscribe(){} };
}

export async function publishChat(_matchId: string, _msg: { user?: string; text: string }) {
// no-op
}
export function subscribeChat(_matchId: string, _onMsg: (m: { user?: string; text: string; created_at: string }) => void) {
return { unsubscribe(){} };
}
ezbmt-tracked/src/lib/sync.ts
 
import { listSyncQueue, removeSyncItem, bumpSyncRetry } from '../db';
import { insertRally, insertChatMessage, insertMedia } from '../db'; // supabase 版
import { supa } from './supabase';
import { getSignedUploadUrl, uploadToSignedUrl, getPublicUrl } from './storage';

let timer: any = null;

export function startSyncLoop() {
if (timer) return;
timer = setInterval(runOnce, 10_000); // 每 10 秒
runOnce().catch(()=>{});
}
export function stopSyncLoop() { if (timer) { clearInterval(timer); timer = null; } }

async function runOnce() {
const { data } = await supa.auth.getUser();
if (!data?.user) return; // 未登入不送
const batch = await listSyncQueue(30);
for (const item of batch) {
try {
const payload = JSON.parse(item.payload_json || '{}');
await pushOne(item.kind, payload);
await removeSyncItem(item.id);
} catch (_e) {
await bumpSyncRetry(item.id);
// 可選: 若 retries 超過某值則丟棄或上報
}
}
}

async function pushOne(kind: string, payload: any) {
if (kind === 'rally') {
await insertRally(payload); // payload 需符合 supa.insertRally 的欄位
} else if (kind === 'chat') {
await insertChatMessage(payload);
} else if (kind === 'media') {
// payload: { matchId, local: { base64?:string, arrayBuffer?:ArrayBuffer }, mime, ext, description? }
const { matchId, base64, mime, ext, description } = payload;
const { path, signedUrl } = await getSignedUploadUrl(matchId, ext, mime);
const buf = base64ToArrayBuffer(base64 || '');
await uploadToSignedUrl(signedUrl, buf, mime);
const publicUrl = getPublicUrl(path);
await insertMedia({ owner_type:'match', owner_id:matchId, kind:'photo', url: publicUrl, description });
}
}

function base64ToArrayBuffer(b64: string): ArrayBuffer {
const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
let str = b64.replace(/[^A-Za-z0-9+/=]/g, '');
let i = 0; let len = str.length; let bufferLength = len * 0.75;
if (str[str.length-1] === '=') bufferLength--;
if (str[str.length-2] === '=') bufferLength--;
const bytes = new Uint8Array(bufferLength);
while (i < len) {
const enc1 = chars.indexOf(str[i++]); const enc2 = chars.indexOf(str[i++]);
const enc3 = chars.indexOf(str[i++]); const enc4 = chars.indexOf(str[i++]);
const n = (enc1 << 18) | (enc2 << 12) | ((enc3 & 63) << 6) | (enc4 & 63);
bytes[(i/43)-3] = (n >> 16) & 255; if (enc3 !== 64) bytes[(i/43)-2] = (n >> 8) & 255; if (enc4 !== 64) bytes[(i/4*3)-1] = n & 255;
}
return bytes.buffer;
}

ezbmt-tracked/src/db/sqlite.ts
 
import SQLite, { SQLiteDatabase } from 'react-native-sqlite-storage';

SQLite.enablePromise(true);

let db: SQLiteDatabase | null = null;

export async function openDB() {
if (db) return db;
db = await SQLite.openDatabase({ name: 'badminton.db', location: 'default' });
await migrate(db);
return db;
}

async function migrate(d: SQLiteDatabase) {
await d.executeSql('CREATE TABLE IF NOT EXISTS meta (k TEXT PRIMARY KEY, v INTEGER)');
const [res] = await d.executeSql('SELECT v FROM meta WHERE k="schema_version"');
const cur = res.rows.length ? (res.rows.item(0).v as number) : 0;

if (cur < 1) {
const sqlEvents = [
'CREATE TABLE IF NOT EXISTS events (',
'  id TEXT PRIMARY KEY,',
'  name TEXT NOT NULL,',
'  level TEXT,',
'  venue TEXT,',
'  start_at TEXT,',
'  end_at TEXT',
')',
].join('\n');

const sqlMatches = [
  'CREATE TABLE IF NOT EXISTS matches (',
  '  id TEXT PRIMARY KEY,',
  '  event_id TEXT NOT NULL,',
  '  type TEXT NOT NULL,',
  '  court_no TEXT,',
  '  rules_json TEXT,',
  '  created_at TEXT',
  ')',
].join('\n');

const sqlRallies = [
  'CREATE TABLE IF NOT EXISTS rallies (',
  '  id TEXT PRIMARY KEY,',
  '  match_id TEXT NOT NULL,',
  '  game_index INTEGER,',
  '  rally_no INTEGER,',
  '  winner_side TEXT,',
  '  end_zone TEXT,',
  '  meta_json TEXT,',
  '  route_start_x REAL, route_start_y REAL,',
  '  route_end_x REAL,   route_end_y REAL,',
  '  created_at TEXT',
  ')',
].join('\n');

await d.executeSql(sqlEvents);
await d.executeSql(sqlMatches);
await d.executeSql(sqlRallies);
await d.executeSql('REPLACE INTO meta(k,v) VALUES("schema_version",1)');
}

if (cur < 2) {
const sqlGames = [
'CREATE TABLE IF NOT EXISTS games (',
'  id TEXT PRIMARY KEY,',
'  match_id TEXT NOT NULL,',
'  index_no INTEGER NOT NULL,',
'  home_score INTEGER NOT NULL,',
'  away_score INTEGER NOT NULL,',
'  winner_team INTEGER,',
'  interval_taken INTEGER DEFAULT 0,',
'  decider_sides_switched INTEGER DEFAULT 0,',
'  created_at TEXT,',
'  updated_at TEXT,',
'  UNIQUE (match_id, index_no)',
')',
].join('\n');
await d.executeSql(sqlGames);
try { await d.executeSql('ALTER TABLE matches ADD COLUMN state_json TEXT'); } catch (_) {}
await d.executeSql('REPLACE INTO meta(k,v) VALUES("schema_version",2)');
}

if (cur < 3) {
const sqlMatchPlayers = [
'CREATE TABLE IF NOT EXISTS match_players (',
'  match_id TEXT NOT NULL,',
'  side TEXT NOT NULL,',
'  idx INTEGER NOT NULL,',
'  name TEXT, gender TEXT, handedness TEXT,',
'  PRIMARY KEY (match_id, side, idx),',
'  FOREIGN KEY (match_id) REFERENCES matches(id)',
')',
].join('\n');

await d.executeSql(sqlMatchPlayers);
try { await d.executeSql('ALTER TABLE matches ADD COLUMN starting_server_team INTEGER'); } catch (_) {}
try { await d.executeSql('ALTER TABLE matches ADD COLUMN starting_server_index INTEGER'); } catch (_) {}
try { await d.executeSql('ALTER TABLE matches ADD COLUMN home_right_when_even_index INTEGER'); } catch (_) {}
try { await d.executeSql('ALTER TABLE matches ADD COLUMN away_right_when_even_index INTEGER'); } catch (_) {}

await d.executeSql('REPLACE INTO meta(k,v) VALUES("schema_version",3)');
}

    if (cur < 4) {
    try { await d.executeSql('ALTER TABLE matches ADD COLUMN record_mode TEXT DEFAULT "tap"'); } catch (_e) {}
    try { await d.executeSql('ALTER TABLE rallies ADD COLUMN route_start_rx REAL'); } catch (_e) {}
    try { await d.executeSql('ALTER TABLE rallies ADD COLUMN route_start_ry REAL'); } catch (_e) {}
    try { await d.executeSql('ALTER TABLE rallies ADD COLUMN route_end_rx REAL'); } catch (_e) {}
    try { await d.executeSql('ALTER TABLE rallies ADD COLUMN route_end_ry REAL'); } catch (_e) {}
    await d.executeSql('REPLACE INTO meta(k,v) VALUES("schema_version",4)');
    }

if (cur < 5) {
await d.executeSql([
'CREATE TABLE IF NOT EXISTS chat_messages (',
'  id TEXT PRIMARY KEY,',
'  match_id TEXT NOT NULL,',
'  user TEXT,',
'  text TEXT,',
'  created_at TEXT',
')'
].join('\n'));

await d.executeSql([
  'CREATE TABLE IF NOT EXISTS media (',
  '  id TEXT PRIMARY KEY,',
  '  owner_type TEXT NOT NULL,',
  '  owner_id TEXT NOT NULL,',
  '  kind TEXT NOT NULL,',
  '  url TEXT NOT NULL,',
  '  description TEXT,',
  '  created_at TEXT',
  ')'
].join('\n'));
    await d.executeSql('REPLACE INTO meta(k,v) VALUES("schema_version",5)');
    }
    
    if (cur < 6) {
    await d.executeSql([
    'CREATE TABLE IF NOT EXISTS dictionaries (',
    '  id TEXT PRIMARY KEY,',
    '  kind TEXT NOT NULL,',      // 'shot_type' | 'error_reason'
    '  label TEXT NOT NULL,',     // 顯示文字
    '  value TEXT,',              // 可選（等同 label）
    '  order_no INTEGER DEFAULT 0,',
    '  created_at TEXT',
    ')'
    ].join('\n'));

    // 預設種子資料（若需要）
    const now = new Date().toISOString();
    const seed = (id: string, kind: string, label: string, order: number) =>
    d.executeSql('INSERT OR IGNORE INTO dictionaries (id,kind,label,value,order_no,created_at) VALUES (?,?,?,?,?,?)',
    [id, kind, label, label, order, now]);

    // shot_type
    await seed('st-1','shot_type','切球',1);
    await seed('st-2','shot_type','網前',2);
    await seed('st-3','shot_type','封網',3);
    await seed('st-4','shot_type','殺球',4);
    await seed('st-5','shot_type','高遠球',5);
    await seed('st-6','shot_type','挑球及推後場',6);
    await seed('st-7','shot_type','過渡',7);
    await seed('st-8','shot_type','平抽',8);
    await seed('st-9','shot_type','發球',9);

    // error_reason
    await seed('er-1','error_reason','出界',1);
    await seed('er-2','error_reason','掛網',2);
    await seed('er-3','error_reason','質量不好',3);
    await seed('er-4','error_reason','發球失誤',4);

    await d.executeSql('REPLACE INTO meta(k,v) VALUES("schema_version",6)');
    }

    if (cur < 7) {
    // rallies 索引
    try { await d.executeSql('CREATE INDEX IF NOT EXISTS idx_rallies_match ON rallies(match_id)'); } catch (_e) {}
    try { await d.executeSql('CREATE INDEX IF NOT EXISTS idx_rallies_match_game ON rallies(match_id, game_index)'); } catch (_e) {}
    try { await d.executeSql('CREATE INDEX IF NOT EXISTS idx_rallies_match_created ON rallies(match_id, datetime(created_at))'); } catch (_e) {}

    // chat 索引
    try { await d.executeSql('CREATE INDEX IF NOT EXISTS idx_chat_match_created ON chat_messages(match_id, datetime(created_at))'); } catch (_e) {}

    await d.executeSql('REPLACE INTO meta(k,v) VALUES("schema_version",7)');
    }
    
    if (cur < 8) {
    await d.executeSql([
    'CREATE TABLE IF NOT EXISTS sync_queue (',
    '  id TEXT PRIMARY KEY,',
    '  kind TEXT NOT NULL,',        // rally | chat | media
    '  payload_json TEXT NOT NULL,',// 要推送的 JSON 字串
    '  created_at TEXT,',
    '  retries INTEGER DEFAULT 0',
    ')'
    ].join('\n'));
    await d.executeSql('REPLACE INTO meta(k,v) VALUES("schema_version",8)');
    }

    if (cur < 9) {
await d.executeSql([
'CREATE TABLE IF NOT EXISTS speed_sessions (',
'  id TEXT PRIMARY KEY,',
'  note TEXT,',
'  unit TEXT DEFAULT "kmh",', // 'kmh' | 'mph'
'  created_at TEXT',
')'
].join('\n'));
await d.executeSql([
'CREATE TABLE IF NOT EXISTS speed_points (',
'  id TEXT PRIMARY KEY,',
'  session_id TEXT NOT NULL,',
'  idx INTEGER NOT NULL,',
'  rx REAL NOT NULL,',
'  ry REAL NOT NULL,',
'  ts_ms INTEGER NOT NULL,',
'  FOREIGN KEY (session_id) REFERENCES speed_sessions(id)',
')'
].join('\n'));
try { await d.executeSql('CREATE INDEX IF NOT EXISTS idx_speed_points_session ON speed_points(session_id, idx)'); } catch (_e) {}
await d.executeSql('REPLACE INTO meta(k,v) VALUES("schema_version",9)');
}

}

/* DAO 基本 */

export async function insertEvent(e: {
  id: string; name: string; level?: string; venue?: string; start_at?: string; end_at?: string;
}) {
  const d = await openDB();
  await d.executeSql(
    'INSERT INTO events (id,name,level,venue,start_at,end_at) VALUES (?,?,?,?,?,?)',
    [e.id, e.name, e.level || null, e.venue || null, e.start_at || null, e.end_at || null]
  );
}

export async function listEvents(): Promise<Array<{ id: string; name: string }>> {
  const d = await openDB();
  const [res] = await d.executeSql('SELECT id,name FROM events ORDER BY name ASC');
  const out: any[] = [];
  for (let i = 0; i < res.rows.length; i++) out.push(res.rows.item(i));
  return out;
}

export async function insertMatch(m: {
  id: string; event_id: string; type: string; court_no?: string; rules_json?: string;
}) {
  const d = await openDB();
  await d.executeSql(
    'INSERT INTO matches (id,event_id,type,court_no,rules_json,created_at) VALUES (?,?,?,?,?,?)',
    [m.id, m.event_id, m.type, m.court_no || null, m.rules_json || null, new Date().toISOString()]
  );
}

export async function listMatches(eventId: string): Promise<Array<{ id: string; type: string; court_no: string | null; rules_json: string | null; record_mode?: string | null }>> {
  const d = await openDB();
  const [res] = await d.executeSql(
    'SELECT id,type,court_no,rules_json,record_mode FROM matches WHERE event_id=? ORDER BY datetime(created_at) DESC',
    [eventId]
  );
  const out: any[] = [];
  for (let i = 0; i < res.rows.length; i++) out.push(res.rows.item(i));
  return out;
}

export async function updateMatchRules(matchId: string, rulesJson: string) {
  const d = await openDB();
  await d.executeSql('UPDATE matches SET rules_json=? WHERE id=?', [rulesJson, matchId]);
}

export async function setMatchRecordMode(matchId: string, mode: 'tap' | 'route') {
  const d = await openDB();
  await d.executeSql('UPDATE matches SET record_mode=? WHERE id=?', [mode, matchId]);
}

export async function saveMatchState(matchId: string, stateJson: string) {
  const d = await openDB();
  await d.executeSql('UPDATE matches SET state_json=? WHERE id=?', [stateJson, matchId]);
}

/* Players */

export async function upsertMatchPlayers(args: {
  matchId: string;
  home: { idx: 0 | 1; name?: string; gender?: string; handedness?: string }[];
  away: { idx: 0 | 1; name?: string; gender?: string; handedness?: string }[];
}) {
  const d = await openDB();
  const all = [
    ...args.home.map(p => ({ ...p, side: 'home' })),
    ...args.away.map(p => ({ ...p, side: 'away' })),
  ];
  for (const p of all) {
    await d.executeSql(
      'REPLACE INTO match_players (match_id,side,idx,name,gender,handedness) VALUES (?,?,?,?,?,?)',
      [args.matchId, p.side, p.idx, p.name || null, p.gender || null, p.handedness || null]
    );
  }
}

export async function getMatchPlayers(matchId: string): Promise<Array<{ side: 'home' | 'away'; idx: 0 | 1; name: string | null; gender: string | null; handedness: string | null }>> {
  const d = await openDB();
  const [res] = await d.executeSql('SELECT side, idx, name, gender, handedness FROM match_players WHERE match_id=?', [matchId]);
  const out: any[] = [];
  for (let i = 0; i < res.rows.length; i++) out.push(res.rows.item(i));
  return out as any;
}

export async function updateStartConfigs(args: {
  matchId: string;
  startingServerTeam: 0 | 1;
  startingServerIndex: 0 | 1;
  homeRightWhenEven: 0 | 1;
  awayRightWhenEven: 0 | 1;
}) {
  const d = await openDB();
  await d.executeSql(
    'UPDATE matches SET starting_server_team=?, starting_server_index=?, home_right_when_even_index=?, away_right_when_even_index=? WHERE id=?',
    [args.startingServerTeam, args.startingServerIndex, args.homeRightWhenEven, args.awayRightWhenEven, args.matchId]
  );
}

/* Rallies */

export async function insertRally(r: {
  id: string; match_id: string; game_index: number; rally_no: number;
  winner_side: string; end_zone: string; meta_json: string;
  route_start_x?: number | null; route_start_y?: number | null;
  route_end_x?: number | null; route_end_y?: number | null;
  route_start_rx?: number | null; route_start_ry?: number | null;
  route_end_rx?: number | null; route_end_ry?: number | null;
  created_at: string;
}) {
  const d = await openDB();
  await d.executeSql(
    'INSERT INTO rallies (id,match_id,game_index,rally_no,winner_side,end_zone,meta_json,route_start_x,route_start_y,route_end_x,route_end_y,route_start_rx,route_start_ry,route_end_rx,route_end_ry,created_at) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
    [
      r.id, r.match_id, r.game_index, r.rally_no, r.winner_side, r.end_zone, r.meta_json,
      r.route_start_x ?? null, r.route_start_y ?? null, r.route_end_x ?? null, r.route_end_y ?? null,
      r.route_start_rx ?? null, r.route_start_ry ?? null, r.route_end_rx ?? null, r.route_end_ry ?? null,
      r.created_at,
    ]
  );
}

export async function listRecentRallies(matchId: string, limit = 20) {
  const d = await openDB();
  const [res] = await d.executeSql(
    'SELECT * FROM rallies WHERE match_id=? ORDER BY datetime(created_at) DESC LIMIT ?',
    [matchId, limit]
  );
  const out: any[] = [];
  for (let i = 0; i < res.rows.length; i++) out.push(res.rows.item(i));
  return out;
}

export async function listRalliesOrdered(matchId: string) {
  const d = await openDB();
  const [res] = await d.executeSql(
    'SELECT * FROM rallies WHERE match_id=? ORDER BY game_index, rally_no',
    [matchId]
  );
  const out: any[] = [];
  for (let i = 0; i < res.rows.length; i++) out.push(res.rows.item(i));
  return out;
}

export async function getLastRally(matchId: string) {
  const d = await openDB();
  const [res] = await d.executeSql(
    'SELECT * FROM rallies WHERE match_id=? ORDER BY datetime(created_at) DESC LIMIT 1',
    [matchId]
  );
  return res.rows.length ? res.rows.item(0) : null;
}

export async function deleteRally(rallyId: string) {
  const d = await openDB();
  await d.executeSql('DELETE FROM rallies WHERE id=?', [rallyId]);
}

export async function getMatch(matchId: string) {
  const d = await openDB();
  const [res] = await d.executeSql('SELECT * FROM matches WHERE id=?', [matchId]);
  return res.rows.length ? res.rows.item(0) : null;
}

export async function upsertGameSummary(args: {
  matchId: string; gameIndex: number;
  home: number; away: number;
  winnerTeam: 0 | 1 | null;
  intervalTaken: boolean; deciderSwitched: boolean;
}) {
  const d = await openDB();
  const id = args.matchId + '-g' + args.gameIndex;
  const now = new Date().toISOString();
  const [res] = await d.executeSql('SELECT id FROM games WHERE id=?', [id]);
  if (res.rows.length) {
    await d.executeSql(
      'UPDATE games SET home_score=?, away_score=?, winner_team=?, interval_taken=?, decider_sides_switched=?, updated_at=? WHERE id=?',
      [args.home, args.away, args.winnerTeam, args.intervalTaken ? 1 : 0, args.deciderSwitched ? 1 : 0, now, id]
    );
  } else {
    await d.executeSql(
      'INSERT INTO games (id,match_id,index_no,home_score,away_score,winner_team,interval_taken,decider_sides_switched,created_at,updated_at) VALUES (?,?,?,?,?,?,?,?,?,?)',
      [id, args.matchId, args.gameIndex, args.home, args.away, args.winnerTeam, args.intervalTaken ? 1 : 0, args.deciderSwitched ? 1 : 0, now, now]
    );
  }
}

export async function insertChatMessage(args: { matchId: string; user?: string; text: string; createdAt?: string }) {
const d = await openDB();
const id = Math.random().toString(36).slice(2);
const ts = args.createdAt || new Date().toISOString();
await d.executeSql(
'INSERT INTO chat_messages (id,match_id,user,text,created_at) VALUES (?,?,?,?,?)',
[id, args.matchId, args.user || null, args.text, ts]
);
}
export async function listChatMessages(matchId: string, limit = 200) {
const d = await openDB();
const [res] = await d.executeSql(
'SELECT * FROM chat_messages WHERE match_id=? ORDER BY datetime(created_at) DESC LIMIT ?',
[matchId, limit]
);
const out: any[] = []; for (let i=0;i<res.rows.length;i++) out.push(res.rows.item(i)); return out;
}

export async function insertMedia(m: { id?: string; owner_type: 'event'|'match'; owner_id: string; kind: 'youtube'|'photo'; url: string; description?: string }) {
const d = await openDB();
const id = m.id || Math.random().toString(36).slice(2);
await d.executeSql(
'INSERT INTO media (id,owner_type,owner_id,kind,url,description,created_at) VALUES (?,?,?,?,?,?,?)',
[id, m.owner_type, m.owner_id, m.kind, m.url, m.description || null, new Date().toISOString()]
);
}
export async function listMedia(owner_type: 'event'|'match', owner_id: string) {
const d = await openDB();
const [res] = await d.executeSql(
'SELECT * FROM media WHERE owner_type=? AND owner_id=? ORDER BY datetime(created_at) DESC',
[owner_type, owner_id]
);
const out: any[] = []; for (let i=0;i<res.rows.length;i++) out.push(res.rows.item(i)); return out;
}
export async function deleteMedia(id: string) {
const d = await openDB();
await d.executeSql('DELETE FROM media WHERE id=?', [id]);
}

export async function listDictionary(kind: 'shot_type'|'error_reason'): Promise<Array<{ id:string; label:string; value?:string; order_no:number }>> {
const d = await openDB();
const [res] = await d.executeSql('SELECT * FROM dictionaries WHERE kind=? ORDER BY order_no ASC, label ASC', [kind]);
const out:any[] = []; for (let i=0;i<res.rows.length;i++) out.push(res.rows.item(i));
return out;
}
export async function upsertDictionary(item: { id?: string; kind:'shot_type'|'error_reason'; label:string; value?:string; order_no?:number }) {
const d = await openDB();
const id = item.id || Math.random().toString(36).slice(2);
const now = new Date().toISOString();
await d.executeSql(
'REPLACE INTO dictionaries (id,kind,label,value,order_no,created_at) VALUES (?,?,?,?,?,?)',
[id, item.kind, item.label, item.value ?? item.label, item.order_no ?? 0, now]
);
}
export async function deleteDictionary(id: string) {
const d = await openDB();
await d.executeSql('DELETE FROM dictionaries WHERE id=?', [id]);
}

export async function getRalliesByIds(ids: string[]): Promise<any[]> {
  if (!ids || !ids.length) return [];
  const d = await openDB();
  const placeholders = ids.map(() => '?').join(',');
  const [res] = await d.executeSql(`SELECT * FROM rallies WHERE id IN (${placeholders})`, ids);
  const out: any[] = []; for (let i=0;i<res.rows.length;i++) out.push(res.rows.item(i));
  out.sort((a,b)=> (a.game_index===b.game_index ? (a.rally_no-b.rally_no) : (a.game_index-b.game_index)));
  return out;
}

export async function enqueueSync(item: { kind: 'rally'|'chat'|'media'; payload: any }) {
const d = await openDB();
const id = Math.random().toString(36).slice(2);
const ts = new Date().toISOString();
await d.executeSql(
'INSERT INTO sync_queue (id,kind,payload_json,created_at,retries) VALUES (?,?,?,?,?)',
[id, item.kind, JSON.stringify(item.payload || {}), ts, 0]
);
}
export async function listSyncQueue(limit = 50) {
const d = await openDB();
const [res] = await d.executeSql('SELECT * FROM sync_queue ORDER BY datetime(created_at) ASC LIMIT ?', [limit]);
const out:any[] = []; for (let i=0;i<res.rows.length;i++) out.push(res.rows.item(i));
return out;
}
export async function removeSyncItem(id: string) {
const d = await openDB();
await d.executeSql('DELETE FROM sync_queue WHERE id=?', [id]);
}
export async function bumpSyncRetry(id: string) {
const d = await openDB();
await d.executeSql('UPDATE sync_queue SET retries = retries + 1 WHERE id=?', [id]);
}

export async function insertSpeedSession(note?: string, unit: 'kmh'|'mph' = 'kmh') {
const d = await openDB();
const id = Math.random().toString(36).slice(2);
const now = new Date().toISOString();
await d.executeSql(
'INSERT INTO speed_sessions (id,note,unit,created_at) VALUES (?,?,?,?)',
[id, note || null, unit, now]
);
return id;
}
export async function insertSpeedPoints(sessionId: string, points: Array<{ idx:number; rx:number; ry:number; ts:number }>) {
const d = await openDB();
await d.executeSql('BEGIN');
try {
for (const p of points) {
const id = Math.random().toString(36).slice(2);
await d.executeSql(
'INSERT INTO speed_points (id,session_id,idx,rx,ry,ts_ms) VALUES (?,?,?,?,?,?)',
[id, sessionId, p.idx, p.rx, p.ry, p.ts]
);
}
await d.executeSql('COMMIT');
} catch (e) {
await d.executeSql('ROLLBACK');
throw e;
}
}
export async function listSpeedSessions(): Promise<Array<{ id:string; note?:string|null; unit:'kmh'|'mph'; created_at:string }>> {
const d = await openDB();
const [res] = await d.executeSql('SELECT * FROM speed_sessions ORDER BY datetime(created_at) DESC');
const out:any[] = [];
for (let i=0;i<res.rows.length;i++) out.push(res.rows.item(i));
return out as any;
}
export async function getSpeedSessionPoints(sessionId: string): Promise<Array<{ idx:number; rx:number; ry:number; ts_ms:number }>> {
const d = await openDB();
const [res] = await d.executeSql('SELECT idx,rx,ry,ts_ms FROM speed_points WHERE session_id=? ORDER BY idx ASC', [sessionId]);
const out:any[] = [];
for (let i=0;i<res.rows.length;i++) out.push(res.rows.item(i));
return out as any;
}
export async function deleteSpeedSession(sessionId: string) {
const d = await openDB();
await d.executeSql('BEGIN');
try {
await d.executeSql('DELETE FROM speed_points WHERE session_id=?', [sessionId]);
await d.executeSql('DELETE FROM speed_sessions WHERE id=?', [sessionId]);
await d.executeSql('COMMIT');
} catch (e) {
await d.executeSql('ROLLBACK');
throw e;
}
}

export async function hasEventMatches(eventId: string): Promise<boolean> {
  const d = await openDB();
  const [res] = await d.executeSql('SELECT COUNT(1) AS c FROM matches WHERE event_id=?', [eventId]);
  const c = res.rows.length ? Number(res.rows.item(0).c) : 0;
  return c > 0;
}
export async function deleteEvent(eventId: string): Promise<void> {
  const d = await openDB();
  await d.executeSql('DELETE FROM events WHERE id=?', [eventId]);
}

export async function hasMatchRallies(matchId: string): Promise<boolean> {
  const d = await openDB();
  const [res] = await d.executeSql('SELECT COUNT(1) AS c FROM rallies WHERE match_id=?', [matchId]);
  const c = res.rows.length ? Number(res.rows.item(0).c) : 0;
  return c > 0;
}
export async function deleteMatch(matchId: string): Promise<void> {
  const d = await openDB();
  await d.executeSql('BEGIN');
  try {
    await d.executeSql('DELETE FROM rallies WHERE match_id=?', [matchId]);
    await d.executeSql('DELETE FROM games WHERE match_id=?', [matchId]);
    await d.executeSql('DELETE FROM match_players WHERE match_id=?', [matchId]);
    await d.executeSql('DELETE FROM chat_messages WHERE match_id=?', [matchId]);
    await d.executeSql('DELETE FROM media WHERE owner_type=? AND owner_id=?', ['match', matchId]);
    await d.executeSql('DELETE FROM matches WHERE id=?', [matchId]);
    await d.executeSql('COMMIT');
  } catch (e) {
    await d.executeSql('ROLLBACK');
    throw e;
  }
}

export async function listGamesByMatch(matchId: string) {
  const d = await openDB();
  const [res] = await d.executeSql(
    'SELECT index_no,home_score,away_score,winner_team FROM games WHERE match_id=? ORDER BY index_no ASC',
    [matchId]
  );
  const out: any[] = [];
  for (let i=0;i<res.rows.length;i++) out.push(res.rows.item(i));
  return out;
}
ezbmt-tracked/src/db/index.ts
 
import { BACKEND } from '../lib/backend';

// SQLite 版本
import * as sqliteDao from './sqlite'; // 你原本的 index.ts 內容請搬到 src/db/sqlite.ts 保留
// Supabase 版本
import * as supaDao from './supa';

const dao = BACKEND === 'supabase' ? supaDao : sqliteDao;
export const openDB = (sqliteDao as any).openDB ?? (async()=>null);

export const joinEventByCode = (dao as any).joinEventByCode || (async (_code: string) => {
throw new Error('joinEventByCode not implemented for current backend');
});

export { enqueueSync, listSyncQueue, removeSyncItem, bumpSyncRetry } from './sqlite';
// 逐一 re-export（與既有函式一致）
export const insertEvent = dao.insertEvent;
export const listEvents = dao.listEvents;

// 新增：檢查及刪除場次
export const hasMatchRallies = (dao as any).hasMatchRallies;
export const deleteMatch = (dao as any).deleteMatch;

// 新增：檢查及刪除賽事
export const hasEventMatches = (dao as any).hasEventMatches;
export const deleteEvent = (dao as any).deleteEvent;

export const listGamesByMatch = (dao as any).listGamesByMatch;

export const insertMatch = dao.insertMatch;
export const listMatches = dao.listMatches;
export const updateMatchRules = dao.updateMatchRules;
export const setMatchRecordMode = dao.setMatchRecordMode;
export const saveMatchState = dao.saveMatchState;
export const getMatch = dao.getMatch;

export const upsertMatchPlayers = dao.upsertMatchPlayers;
export const getMatchPlayers = dao.getMatchPlayers;
export const updateStartConfigs = dao.updateStartConfigs;

export const insertRally = dao.insertRally;
export const listRecentRallies = dao.listRecentRallies;
export const listRalliesOrdered = dao.listRalliesOrdered;
export const getLastRally = dao.getLastRally;
export const deleteRally = dao.deleteRally;

export const upsertGameSummary = dao.upsertGameSummary;

export const insertChatMessage = dao.insertChatMessage;
export const listChatMessages = dao.listChatMessages;

export const insertMedia = dao.insertMedia;
export const listMedia = dao.listMedia;
export const deleteMedia = dao.deleteMedia;

export const listDictionary = dao.listDictionary;
export const upsertDictionary = dao.upsertDictionary;
export const deleteDictionary = dao.deleteDictionary;

export const getRalliesByIds = dao.getRalliesByIds;

export const listEventMembers = (dao as any).listEventMembers;
export const getMyEventRole = (dao as any).getMyEventRole;
export const upsertEventMember = (dao as any).upsertEventMember;
export const deleteEventMember = (dao as any).deleteEventMember;
export const getEventJoinCode = (dao as any).getEventJoinCode;
export const setEventJoinCode = (dao as any).setEventJoinCode;
export const listEventMembersBasic = (dao as any).listEventMembersBasic;
export const listMatchMembers = (dao as any).listMatchMembers;
export const upsertMatchMember = (dao as any).upsertMatchMember;
export const deleteMatchMember = (dao as any).deleteMatchMember;
export const inviteEventMemberByEmail = (dao as any).inviteEventMemberByEmail;
export const setEventOwnerRPC = (dao as any).setEventOwnerRPC;

export const insertSpeedSession = (sqliteDao as any).insertSpeedSession;
export const insertSpeedPoints = (sqliteDao as any).insertSpeedPoints;
export const listSpeedSessions = (sqliteDao as any).listSpeedSessions;
export const getSpeedSessionPoints = (sqliteDao as any).getSpeedSessionPoints;
export const deleteSpeedSession = (sqliteDao as any).deleteSpeedSession;


export async function listMyEvents() {
if (BACKEND === 'supabase' && (supaDao as any).listMyEvents) {
return supaDao.listMyEvents();
}
// 非 supabase 模式，用原本本地 events
const rows = await sqliteDao.listEvents();
return rows; // [{id,name}]
}

export async function createEventRPC(args: { name: string; level?: string; venue?: string; start_at?: string; end_at?: string; join_code?: string }) {
if (BACKEND === 'supabase' && (supaDao as any).createEventRPC) {
return supaDao.createEventRPC(args);
}
// 本地 fallback：直接插入 SQLite 事件
const id = Math.random().toString(36).slice(2);
await sqliteDao.insertEvent({ id, name: args.name });
return id;
}

export async function createMatchRPC(args: { event_id: string; type: string; courtNo?: string | null }) {
if (BACKEND === 'supabase' && (supaDao as any).createMatchRPC) {
return supaDao.createMatchRPC(args);
}
// 本地 SQLite 後援
const id = Math.random().toString(36).slice(2);
await sqliteDao.insertMatch({ id, event_id: args.event_id, type: args.type, court_no: args.courtNo ?? undefined });
return id;
}
ezbmt-tracked/src/db/supa.ts
 
import { supa, SUPABASE_URL } from '../lib/supabase';

type MemberRole = 'owner'|'coach'|'recorder'|'player'|'viewer';

function toJsonString(v: any): string | null {
try {
if (v == null) return null;
if (typeof v === 'string') return v;
return JSON.stringify(v);
} catch {
return null;
}
}

/* Join by code */
export async function joinEventByCode(code: string): Promise<void> {
const { error } = await supa.rpc('join_event_by_code', { p_code: code });
if (error) throw error;
}

/* Events */
export async function insertEvent(e: { id?: string; name: string; level?: string; venue?: string; start_at?: string; end_at?: string; }) {
const { data, error } = await supa.from('events').insert({
id: e.id, name: e.name, level: e.level ?? null, venue: e.venue ?? null, start_at: e.start_at ?? null, end_at: e.end_at ?? null
}).select('id').single();
if (error) throw error;
return data?.id as string;
}
export async function listEvents(): Promise<Array<{ id: string; name: string }>> {
const { data, error } = await supa.from('events').select('id,name').order('name',{ascending:true});
if (error) throw error;
return data || [];
}

/* Matches */
export async function insertMatch(m: { id?: string; event_id: string; type: string; court_no?: string; rules_json?: string; }) {
const rules = m.rules_json ? JSON.parse(m.rules_json) : null;
const { error } = await supa.from('matches').insert({
id: m.id, event_id: m.event_id, type: m.type, court_no: m.court_no ?? null, rules_json: rules
});
if (error) throw error;
}

export async function listMatches(eventId: string) {
const { data, error } = await supa.from('matches')
.select('id,type,court_no,rules_json,record_mode')
.eq('event_id', eventId)
.order('created_at',{ascending:false});
if (error) throw error;
return (data||[]).map((row:any)=>({ ...row, rules_json: toJsonString(row.rules_json) }));
}
export async function updateMatchRules(matchId: string, rulesJson: string) {
const { error } = await supa.from('matches').update({ rules_json: JSON.parse(rulesJson) }).eq('id', matchId);
if (error) throw error;
}
export async function setMatchRecordMode(matchId: string, mode: 'tap'|'route') {
const { error } = await supa.from('matches').update({ record_mode: mode }).eq('id', matchId);
if (error) throw error;
}
export async function saveMatchState(matchId: string, stateJson: string) {
const { error } = await supa.from('matches').update({ state_json: JSON.parse(stateJson) }).eq('id', matchId);
if (error) throw error;
}
export async function getMatch(matchId: string) {
const { data, error } = await supa.from('matches').select('*').eq('id', matchId).single();
if (error) throw error;
const row:any = data || {};
return { ...row, rules_json: toJsonString(row.rules_json), state_json: toJsonString(row.state_json) };
}

/* Players */
export async function upsertMatchPlayers(args: {
matchId: string;
home: { idx: 0 | 1; name?: string; gender?: string; handedness?: string }[];
away: { idx: 0 | 1; name?: string; gender?: string; handedness?: string }[];
}) {
const all = [...args.home.map(p=>({...p,side:'home'})), ...args.away.map(p=>({...p,side:'away'}))];
for (const p of all) {
const { error } = await supa.from('match_players').upsert({
match_id: args.matchId, side: p.side, idx: p.idx, name: p.name ?? null, gender: p.gender ?? null, handedness: p.handedness ?? null,
});
if (error) throw error;
}
}
export async function getMatchPlayers(matchId: string) {
const { data, error } = await supa.from('match_players').select('side,idx,name,gender,handedness').eq('match_id', matchId);
if (error) throw error;
return data || [];
}
export async function updateStartConfigs(args: {
matchId: string; startingServerTeam: 0|1; startingServerIndex: 0|1; homeRightWhenEven: 0|1; awayRightWhenEven: 0|1;
}) {
const { error } = await supa.from('matches').update({
starting_server_team: args.startingServerTeam,
starting_server_index: args.startingServerIndex,
home_right_when_even_index: args.homeRightWhenEven,
away_right_when_even_index: args.awayRightWhenEven,
}).eq('id', args.matchId);
if (error) throw error;
}

/* Rallies */
export async function insertRally(r: {
id?: string; match_id: string; game_index: number; rally_no: number;
winner_side: string; end_zone: string; meta_json: string;
route_start_x?: number | null; route_start_y?: number | null;
route_end_x?: number | null; route_end_y?: number | null;
route_start_rx?: number | null; route_start_ry?: number | null;
route_end_rx?: number | null; route_end_ry?: number | null;
created_at: string;
}) {
const { id: _ignore, ...row } = r as any;
const { error } = await supa.from('rallies').insert(row);
if (error) throw error;
}


export async function listRecentRallies(matchId: string, limit = 20) {
const { data, error } = await supa.from('rallies').select('*').eq('match_id', matchId).order('created_at',{ascending:false}).limit(limit);
if (error) throw error;
return (data||[]).map((row:any)=>({ ...row, meta_json: toJsonString(row.meta_json) }));
}
export async function listRalliesOrdered(matchId: string) {
const { data, error } = await supa.from('rallies').select('*').eq('match_id', matchId)
.order('game_index',{ascending:true})
.order('rally_no',{ascending:true});
if (error) throw error;
return (data||[]).map((row:any)=>({ ...row, meta_json: toJsonString(row.meta_json) }));
}
export async function getLastRally(matchId: string) {
const { data, error } = await supa.from('rallies').select('*').eq('match_id', matchId).order('created_at',{ascending:false}).limit(1);
if (error) throw error;
const row = data && data.length ? data[0] : null;
return row ? { ...row, meta_json: toJsonString(row.meta_json) } : null;
}
export async function deleteRally(id: string) {
const { error } = await supa.from('rallies').delete().eq('id', id);
if (error) throw error;
}

/* Games summary */
export async function upsertGameSummary(args: {
matchId: string; gameIndex: number;
home: number; away: number;
winnerTeam: 0 | 1 | null;
intervalTaken: boolean; deciderSwitched: boolean;
}) {
const { error } = await supa.from('games').upsert({
match_id: args.matchId,
index_no: args.gameIndex,
home_score: args.home,
away_score: args.away,
winner_team: args.winnerTeam,
interval_taken: args.intervalTaken,
decider_sides_switched: args.deciderSwitched,
}, { onConflict: 'match_id,index_no' });
if (error) throw error;
}

/* Chat */
export async function insertChatMessage(args: { matchId: string; user?: string; text: string; createdAt?: string }) {
const { error } = await supa.from('chat_messages').insert({
match_id: args.matchId, user_name: args.user ?? null, text: args.text, created_at: args.createdAt ?? new Date().toISOString()
});
if (error) throw error;
}
export async function listChatMessages(matchId: string, limit = 200) {
const { data, error } = await supa.from('chat_messages').select('*').eq('match_id', matchId).order('created_at',{ascending:false}).limit(limit);
if (error) throw error;
return (data||[]).map((row:any)=>({ ...row, user: row.user_name }));
}

/* Media */
export async function insertMedia(m: { id?: string; owner_type: 'event'|'match'; owner_id: string; kind: 'youtube'|'photo'; url: string; description?: string }) {
const { error } = await supa.from('media').insert({
id: m.id, owner_type: m.owner_type, owner_id: m.owner_id, kind: m.kind, url: m.url, description: m.description ?? null
});
if (error) throw error;
}
export async function listMedia(owner_type: 'event'|'match', owner_id: string) {
const { data, error } = await supa.from('media').select('*').eq('owner_type', owner_type).eq('owner_id', owner_id).order('created_at',{ascending:false});
if (error) throw error;
return data || [];
}
export async function deleteMedia(id: string) {
const { error } = await supa.from('media').delete().eq('id', id);
if (error) throw error;
}

/* Dictionaries */
export async function listDictionary(kind: 'shot_type'|'error_reason') {
const { data, error } = await supa.from('dictionaries').select('id,label,value,order_no').eq('kind', kind)
.order('order_no',{ascending:true}).order('label',{ascending:true});
if (error) throw error;
return data || [];
}
export async function upsertDictionary(item: { id?: string; kind:'shot_type'|'error_reason'; label:string; value?:string; order_no?:number }) {
const { error } = await supa.from('dictionaries').upsert({
id: item.id, kind: item.kind, label: item.label, value: item.value ?? item.label, order_no: item.order_no ?? 0
});
if (error) throw error;
}
export async function deleteDictionary(id: string) {
const { error } = await supa.from('dictionaries').delete().eq('id', id);
if (error) throw error;
}

/* Live/Replay 補充 */
export async function getRalliesByIds(ids: string[]): Promise<any[]> {
if (!ids || !ids.length) return [];
const { data, error } = await supa.from('rallies').select('*').in('id', ids);
if (error) throw error;
const out = (data||[]).map((row:any)=>({ ...row, meta_json: toJsonString(row.meta_json) }));
out.sort((a:any,b:any)=>(a.game_index===b.game_index ? (a.rally_no-b.rally_no) : (a.game_index-b.game_index)));
return out;
}

/* Event members */
export async function getCurrentUserId(): Promise<string|null> {
const { data } = await supa.auth.getUser();
return data?.user?.id || null;
}
/* 取得本人角色（建議有 get_my_event_role RPC；若沒有就用 list_event_members 再比對） */
export async function getMyEventRole(eventId: string) {
const { data } = await supa.rpc('get_my_event_role', { p_event_id: eventId });
return (data as MemberRole) || null;
}

/* 事件成員列表（RPC） */
export async function listEventMembers(eventId: string) {
const { data, error } = await supa.rpc('list_event_members_with_names', { p_event_id: eventId });
if (error) throw error;
// 直接是 { id,user_id,role,name }
return (data || []) as Array<{ id:string; user_id:string; role:MemberRole; name:string }>;
}

/* 新增/變更角色（RPC） */
export async function upsertEventMember(args: { eventId: string; userId: string; role: MemberRole }) {
const { error } = await supa.rpc('upsert_event_member', {
p_event_id: args.eventId,
p_user_id: args.userId,
p_role: args.role,
});
if (error) throw error;
}

/* 移除成員（RPC） */
export async function deleteEventMember(memberId: string) {
const { error } = await supa.rpc('delete_event_member', { p_member_id: memberId });
if (error) throw error;
}
export async function setEventJoinCode(eventId: string, code: string|null) {
const { error } = await supa.from('events').update({ join_code: code }).eq('id', eventId);
if (error) throw error;
}
export async function getEventJoinCode(eventId: string): Promise<string|null> {
const { data, error } = await supa.from('events').select('join_code').eq('id', eventId).single();
if (error) throw error;
return (data?.join_code as string) || null;
}

/* Match members */
// 讀取場次成員（含 name）
export async function listMatchMembers(matchId: string) {
const { data, error } = await supa.rpc('list_match_members_with_names', { p_match_id: matchId });
if (error) throw error;
return (data || []) as Array<{ id:string; user_id:string; role:'owner'|'coach'|'recorder'|'player'|'viewer'; name:string }>;
}

export async function upsertMatchMember(args: { matchId: string; userId: string; role: 'owner'|'coach'|'recorder'|'player'|'viewer' }) {
const { error } = await supa.rpc('upsert_match_member', {
p_match_id: args.matchId,
p_user_id: args.userId,
p_role: args.role,
});
if (error) throw error;
}

export async function deleteMatchMember(id: string) {
const { error } = await supa.rpc('delete_match_member', { p_member_id: id });
if (error) throw error;
}

export async function listEventMembersBasic(eventId: string): Promise<Array<{ user_id:string; name:string }>> {
const { data, error } = await supa.from('event_members').select('user_id').eq('event_id', eventId);
if (error) throw error;
const ids = (data||[]).map((r:any)=>r.user_id as string);
if (!ids.length) return [];
const { data: prof } = await supa.from('profiles').select('id,name').in('id', ids as any);
return (prof||[]).map((p:any)=>({ user_id: p.id as string, name: (p.name || (p.id as string).slice(0,8)+'…') as string }));
}

/* Edge Function: 邀請成員（Email） */
export async function inviteEventMemberByEmail(args: { eventId: string; email: string; role: 'owner'|'coach'|'recorder'|'player'|'viewer' }) {
const { data, error } = await supa.functions.invoke('invite-by-email', { body: args });
if (error) throw error;
return data ?? {};
}


// 讀「我的賽事」（RPC）
export async function listMyEvents(): Promise<Array<{ id:string; name:string }>> {
const { data, error } = await supa.rpc('list_my_events');
if (error) throw error;
return (data || []) as Array<{ id:string; name:string }>;
}

// 建立賽事（RPC）
export async function createEventRPC(args: {
name: string; level?: string; venue?: string; start_at?: string; end_at?: string; join_code?: string;
}) {
const { data, error } = await supa.rpc('create_event', {
p_name: args.name,
p_level: args.level ?? null,
p_venue: args.venue ?? null,
p_start_at: args.start_at ?? null,
p_end_at: args.end_at ?? null,
p_join_code: args.join_code ?? null,
});
if (error) throw error;
return data as string; // event_id
}
// 建立場次（RPC）
export async function createMatchRPC(args: { event_id: string; type: string; court_no?: string; rules?: any }) {
const { data, error } = await supa.rpc('create_match', {
p_event_id: args.event_id,
p_type: args.type,
p_court_no: args.court_no ?? null,
p_rules_json: args.rules ?? null,
});
if (error) throw error;
return data as string; // match_id
}

// 移交擁有者（RPC）
export async function setEventOwnerRPC(args: { eventId: string; userId: string }) {
const { error } = await supa.rpc('set_event_owner', { p_event_id: args.eventId, p_user_id: args.userId });
if (error) throw error;
}

/* 新增：刪賽事/檢查是否有場次 */
// 是否有此賽事的場次
export async function hasEventMatches(eventId: string): Promise<boolean> {
const { count, error } = await supa
.from('matches')
.select('id', { count: 'exact', head: true })
.eq('event_id', eventId);
if (error) throw error;
return (count || 0) > 0;
}

export async function deleteEvent(eventId: string): Promise<void> {
const { data, error } = await supa.rpc('delete_event_safe', { p_event_id: eventId });
if (error) throw error;
if (data && data.deleted === false) {
if (data.reason === 'HAS_MATCHES') throw new Error('HAS_MATCHES');
throw new Error('DELETE_FAILED');
}
}

/* 新增：是否有記錄、刪除場次（含相依資料） */
// 是否有此場次的記錄
export async function hasMatchRallies(matchId: string): Promise<boolean> {
// 同樣用 limit(1) 檢查是否存在
const { data, error } = await supa
.from('rallies')
.select('id')
.eq('match_id', matchId)
.limit(1);
if (error) throw error;
return (data || []).length > 0;
}
export async function deleteMatch(matchId: string): Promise<void> {
  try { await supa.from('rallies').delete().eq('match_id', matchId); } catch(_e) {}
  try { await supa.from('games').delete().eq('match_id', matchId); } catch(_e) {}
  try { await supa.from('match_players').delete().eq('match_id', matchId); } catch(_e) {}
  try { await supa.from('chat_messages').delete().eq('match_id', matchId); } catch(_e) {}
  try { await supa.from('media').delete().eq('owner_type','match').eq('owner_id', matchId); } catch(_e) {}
  try { await supa.from('match_members').delete().eq('match_id', matchId); } catch(_e) {}
  const { error } = await supa.from('matches').delete().eq('id', matchId);
  if (error) throw error;
}

export async function listGamesByMatch(matchId: string) {
  const { data, error } = await supa
    .from('games')
    .select('index_no,home_score,away_score,winner_team')
    .eq('match_id', matchId)
    .order('index_no', { ascending: true });
  if (error) throw error;
  return data || [];
}

type LiveSnapshot = {
scoreA: number; scoreB: number;
servingTeam: 0|1;
server?: { team:0|1; index:0|1; court:'R'|'L' };
receiver?: { team:0|1; index:0|1; court:'R'|'L' };
players?: Array<{ name?: string }>;
};
ezbmt-tracked/src/global.d.ts
 
declare module 'react-native-sqlite-storage';ezbmt-tracked/src/SpeedTracker.m
 
#import <VisionCamera/FrameProcessorPlugin.h>
#import <ezbmt-Swift.h>  

VISION_EXPORT_SWIFT_FRAME_PROCESSOR(SpeedTracker, SpeedTracker)
ezbmt-tracked/src/store/records.ts
 
import { create } from 'zustand';
import type { RallyRecord } from '../types';
import { insertRally, listRecentRallies } from '../db';
import { enqueueSync } from '../db';
import { BACKEND } from '../lib/backend';

type RecordsState = {
currentMatchId: string | null;
records: RallyRecord[]; // 最新在前
setCurrentMatch: (id: string | null) => void;
loadRecent: () => Promise<void>;
addRecord: (r: Omit<RallyRecord, 'id' | 'createdAt' | 'matchId'> & {
routeNorm?: { start?: { x: number; y: number }; end?: { x: number; y: number } };
}) => Promise<void>;
clearLocal: () => void;
};

export const useRecordsStore = create<RecordsState>((set, get) => ({
currentMatchId: null,
records: [],

setCurrentMatch: (id) => set({ currentMatchId: id, records: [] }),

loadRecent: async () => {
const mid = get().currentMatchId;
if (!mid) return;
const rows = await listRecentRallies(mid, 20);
const list: RallyRecord[] = rows.map((x: any) => ({
id: x.id,
matchId: x.match_id,
gameIndex: x.game_index,
rallyNo: x.rally_no,
winnerSide: x.winner_side,
endZone: (x.end_zone === 'out' ? 'out' : Number(x.end_zone)) as any,
meta: JSON.parse(x.meta_json || '{}'),
route:
x.route_start_x != null && x.route_end_x != null
? { start: { x: x.route_start_x, y: x.route_start_y }, end: { x: x.route_end_x, y: x.route_end_y } }
: undefined,
createdAt: x.created_at,
}));
set({ records: list });
},

addRecord: async (r) => {
const mid = get().currentMatchId;
if (!mid) throw new Error('請先選擇一個場次（match）');

const recId = Math.random().toString(36).slice(2);
const createdAt = new Date().toISOString();

// 1) 寫入（依 BACKEND 切換：supabase 會直寫雲端；sqlite 寫本地）
await insertRally({
  id: recId,
  match_id: mid,
  game_index: r.gameIndex,
  rally_no: r.rallyNo,
  winner_side: r.winnerSide,
  end_zone: String(r.endZone),
  meta_json: JSON.stringify(r.meta || {}),
  route_start_x: r.route?.start.x ?? null,
  route_start_y: r.route?.start.y ?? null,
  route_end_x: r.route?.end.x ?? null,
  route_end_y: r.route?.end.y ?? null,
  route_start_rx: r.routeNorm?.start?.x ?? null,
  route_start_ry: r.routeNorm?.start?.y ?? null,
  route_end_rx: r.routeNorm?.end?.x ?? null,
  route_end_ry: r.routeNorm?.end?.y ?? null,
  created_at: createdAt,
});

// 2) 本地 UI 立即更新
const rec: RallyRecord = {
  id: recId,
  matchId: mid,
  createdAt,
  gameIndex: r.gameIndex,
  rallyNo: r.rallyNo,
  winnerSide: r.winnerSide,
  endZone: r.endZone,
  meta: r.meta,
  route: r.route,
};
set((s) => ({ records: [rec, ...s.records].slice(0, 20) }));

// 3) 只在離線模式才丟到同步佇列（避免 supabase 模式重複上傳）
if (BACKEND === 'sqlite') {
  enqueueSync({
    kind: 'rally',
    payload: {
      id: recId,
      match_id: mid,
      game_index: r.gameIndex,
      rally_no: r.rallyNo,
      winner_side: r.winnerSide,
      end_zone: String(r.endZone),
      meta_json: JSON.stringify(r.meta || {}),
      route_start_x: r.route?.start.x ?? null,
      route_start_y: r.route?.start.y ?? null,
      route_end_x: r.route?.end.x ?? null,
      route_end_y: r.route?.end.y ?? null,
      route_start_rx: r.routeNorm?.start?.x ?? null,
      route_start_ry: r.routeNorm?.start?.y ?? null,
      route_end_rx: r.routeNorm?.end?.x ?? null,
      route_end_ry: r.routeNorm?.end?.y ?? null,
      created_at: createdAt,
    },
  }).catch(() => {});
}
},

clearLocal: () => set({ records: [] }),
}));ezbmt-tracked/src/store/bg.ts
 
import { create } from 'zustand';
import AsyncStorage from '@react-native-async-storage/async-storage';
import RNFS from 'react-native-fs';

type BgState = {
uri: string | null;
opacity: number; // 0..1
load: () => Promise<void>;
setOpacity: (v: number) => Promise<void>;
setFromBase64: (base64: string, ext?: string) => Promise<void>; // 寫入檔案後啟用
clear: () => Promise<void>;
};

const KEY = 'app_bg_v1';

export const useBgStore = create<BgState>((set, get) => ({
uri: null,
opacity: 0.25,

load: async () => {
try {
const s = await AsyncStorage.getItem(KEY);
if (!s) return;
const obj = JSON.parse(s || '{}') as { uri?: string; opacity?: number };
// 檢查檔案是否存在（file://）
if (obj?.uri && obj.uri.startsWith('file://')) {
const p = obj.uri.replace('file://', '');
const ok = await RNFS.exists(p);
if (!ok) {
await AsyncStorage.removeItem(KEY);
set({ uri: null, opacity: obj.opacity ?? 0.25 });
return;
}
}
set({ uri: obj?.uri || null, opacity: typeof obj?.opacity === 'number' ? obj.opacity : 0.25 });
} catch {
// ignore
}
},

setOpacity: async (v: number) => {
set({ opacity: v });
try {
const cur = get();
await AsyncStorage.setItem(KEY, JSON.stringify({ uri: cur.uri, opacity: v }));
} catch {}
},

setFromBase64: async (base64: string, ext = 'jpg') => {
try {
const dir = RNFS.DocumentDirectoryPath;
const dest = `${dir}/app_bg.${ext.toLowerCase()}`;
await RNFS.writeFile(dest, base64, 'base64');
const uri = `file://${dest}`;
set({ uri });
const cur = get();
await AsyncStorage.setItem(KEY, JSON.stringify({ uri, opacity: cur.opacity }));
} catch (e) {
throw e;
}
},

clear: async () => {
try {
const s = await AsyncStorage.getItem(KEY);
if (s) {
const obj = JSON.parse(s || '{}') as { uri?: string; opacity?: number };
if (obj?.uri?.startsWith('file://')) {
const p = obj.uri.replace('file://', '');
try { await RNFS.unlink(p); } catch {}
}
}
} catch {}
set({ uri: null });
try {
const cur = get();
await AsyncStorage.setItem(KEY, JSON.stringify({ uri: null, opacity: cur.opacity }));
} catch {}
},
}));