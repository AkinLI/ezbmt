ezbmt-tracked/App.tsx
 
import * as React from 'react';
import { StatusBar, useColorScheme, Linking } from 'react-native';
import { NavigationContainer, useNavigationContainerRef } from '@react-navigation/native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import AppNavigator from './src/AppNavigator';
import { startSyncLoop, stopSyncLoop } from './src/lib/sync';
import GlobalBackground from './src/components/GlobalBackground';
import { useBgStore } from './src/store/bg';
import { supa } from './src/lib/supabase';
import { startPresenceHeartbeat } from './src/lib/presence';
import { initPushIfAvailable } from './src/lib/push';

export const AdminCtx = React.createContext<{ isAdmin: boolean }>({ isAdmin: false });

async function fetchIsAdmin(): Promise<boolean> {
  try {
    const { data } = await supa.rpc('is_app_admin');
    return !!data;
  } catch {
    return false;
  }
}

export default function App() {
  const isDarkMode = useColorScheme() === 'dark';

  // 登入狀態：未登入不顯示背景
  const [signedIn, setSignedIn] = React.useState(false);

  // 取得目前 Route 名稱，用來決定哪些畫面要隱藏背景
  const navRef = useNavigationContainerRef();
  const [routeName, setRouteName] = React.useState<string | undefined>(undefined);

  const EXCLUDE_BG = React.useMemo(
    () =>
      new Set([
        'Record',
        'SpeedCam',
        'Analysis',
        'Replay',
        'QuickScoreboard',
      ]),
    [],
  );

  const showBg = signedIn && routeName && !EXCLUDE_BG.has(routeName);

  // 深連結處理（Email 驗證回跳）
  React.useEffect(() => {
    const handleUrl = (urlStr: string) => {
      try {
        const u = new URL(urlStr);
        const code = u.searchParams.get('code') || u.searchParams.get('token');
        if (code) {
          supa.auth.exchangeCodeForSession(code).catch(() => {});
        }
      } catch {}
    };

    Linking.getInitialURL().then((initialUrl) => {
      if (initialUrl) handleUrl(initialUrl);
    });

    const sub = Linking.addEventListener('url', ({ url }: { url: string }) => handleUrl(url));
    return () => sub.remove();
  }, []);

  // Sync + 背景 + Auth 狀態 + Presence 心跳
  React.useEffect(() => {
    startSyncLoop();
    useBgStore.getState().load().catch(() => {});

    let stopPresence: undefined | (() => void);

    (async () => {
      try {
        const { data } = await supa.auth.getUser();
        setSignedIn(!!data?.user);
        if (data?.user) {
          stopPresence = startPresenceHeartbeat(30_000);
        }
      } catch {
        setSignedIn(false);
      }
    })();

    const { data: authSub } = supa.auth.onAuthStateChange((_event, session) => {
      const on = !!session?.user;
      setSignedIn(on);
      try {
        stopPresence?.();
      } catch {}
      stopPresence = on ? startPresenceHeartbeat(30_000) : undefined;
    });

    return () => {
      stopSyncLoop();
      try {
        authSub?.subscription?.unsubscribe?.();
      } catch {}
      try {
        stopPresence?.();
      } catch {}
    };
  }, []);

  // 新增：登入後嘗試初始化推播（可選；未安裝 firebase/messaging 也會自動略過）
  React.useEffect(() => {
    if (!signedIn) return;
    initPushIfAvailable().catch(() => {});
  }, [signedIn]);

  return (
    <SafeAreaProvider>
      <StatusBar barStyle={isDarkMode ? 'light-content' : 'dark-content'} />
      <NavigationContainer
        ref={navRef}
        onReady={() => setRouteName(navRef.getCurrentRoute()?.name)}
        onStateChange={() => setRouteName(navRef.getCurrentRoute()?.name)}
      >
        <AppNavigator />
      </NavigationContainer>

      {showBg ? <GlobalBackground /> : null}
    </SafeAreaProvider>
  );
}ezbmt-tracked/app.json
 
{
  "name": "ezbmt",
  "displayName": "ezbmt"
}
ezbmt-tracked/jest.config.js
 
module.exports = {
  preset: 'react-native',
};
ezbmt-tracked/index.js
 
/**
 * @format
 */

import 'react-native-gesture-handler';
import 'react-native-url-polyfill/auto';
import 'react-native-get-random-values';
import {AppRegistry} from 'react-native';
import App from './App';
import {name as appName} from './app.json';

AppRegistry.registerComponent(appName, () => App);
ezbmt-tracked/ios/ezbmt/Images.xcassets/AppIcon.appiconset/Contents.json
 
{
  "images" : [
    {
      "filename" : "ezBmticon.jpg",
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "dark"
        }
      ],
      "filename" : "ezBmticon 1.jpg",
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "tinted"
        }
      ],
      "filename" : "ezBmticon 2.jpg",
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
ezbmt-tracked/ios/ezbmt/Images.xcassets/Contents.json
 
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
ezbmt-tracked/ios/ezbmt/AppDelegate.swift
 
import UIKit
import React
import React_RCTAppDelegate
import ReactAppDependencyProvider

@main
class AppDelegate: UIResponder, UIApplicationDelegate {
  var window: UIWindow?

  var reactNativeDelegate: ReactNativeDelegate?
  var reactNativeFactory: RCTReactNativeFactory?

  func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil
  ) -> Bool {
    let delegate = ReactNativeDelegate()
    let factory = RCTReactNativeFactory(delegate: delegate)
    delegate.dependencyProvider = RCTAppDependencyProvider()

    reactNativeDelegate = delegate
    reactNativeFactory = factory

    window = UIWindow(frame: UIScreen.main.bounds)

    factory.startReactNative(
      withModuleName: "ezbmt",
      in: window,
      launchOptions: launchOptions
    )

    return true
  }
}

class ReactNativeDelegate: RCTDefaultReactNativeFactoryDelegate {
  override func sourceURL(for bridge: RCTBridge) -> URL? {
    self.bundleURL()
  }

  override func bundleURL() -> URL? {
#if DEBUG
    RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: "index")
#else
    Bundle.main.url(forResource: "main", withExtension: "jsbundle")
#endif
  }
}
ezbmt-tracked/ios/STPlugin.swift
 
import Foundation
import AVFoundation
import VisionCamera

@objc(STPlugin)
public class STPlugin: FrameProcessorPlugin {

@objc
override public init(proxy: VisionCameraProxyHolder, options: [AnyHashable : Any]?) {
super.init(proxy: proxy, options: options)
}

// 注意：一定要覆寫「實例方法」，簽名要是 Frame / Any?（不是 IUO）
@objc
override public func callback(_ frame: Frame, withArguments arguments: [AnyHashable : Any]?) -> Any? {
let ts = frame.timestamp // VisionCamera 為毫秒
return ["x": 0.5, "y": 0.5, "ts": ts, "w": 100, "h": 100, "score": 999]
}

// 相容舊 selector（部分環境會呼叫 withArgs）
@objc(callback:withArgs:)
public func callback_legacy(_ frame: Frame, withArgs args: [AnyHashable : Any]?) -> Any? {
return callback(frame, withArguments: args)
}
}
ezbmt-tracked/ios/SpeedTracker.swift
 
import Foundation
import VisionCamera

@objc(SpeedTracker)
public class SpeedTracker: FrameProcessorPlugin {

@objc
public static func callback(_ frame: Frame!, withArguments arguments: [Any]!) -> Any! {
// 固定回傳一筆樣本，用來驗證 JS 是否能收得到
let ts = frame?.timestamp ?? 0
return [
"x": 0.5,
"y": 0.5,
"ts": ts,
"w": 100,
"h": 100,
"score": 999
]
}
}
ezbmt-tracked/ios/RNSpeedCamViewManager.m
 
#import <React/RCTViewManager.h>

@interface RCT_EXTERN_MODULE(RNSpeedCamViewManager, RCTViewManager)
RCT_EXPORT_VIEW_PROPERTY(isActive, NSNumber)
RCT_EXPORT_VIEW_PROPERTY(onSample, RCTDirectEventBlock)
RCT_EXPORT_VIEW_PROPERTY(yMin, NSNumber)
RCT_EXPORT_VIEW_PROPERTY(chromaMax, NSNumber)
RCT_EXPORT_VIEW_PROPERTY(blockSize, NSNumber)
RCT_EXPORT_VIEW_PROPERTY(roiPad, NSNumber)
@endezbmt-tracked/ios/SpeedCamView.swift
 
import Foundation
import AVFoundation
import React

@objc(SpeedCamView)
class SpeedCamView: UIView, AVCaptureVideoDataOutputSampleBufferDelegate {

// ====== RN 可調屬性 ======
@objc var isActive: NSNumber = 1 { didSet { isActive.boolValue ? start() : stop() } }
@objc var yMin: NSNumber = 140      // 亮度門檻（白色應偏亮）
@objc var chromaMax: NSNumber = 18  // 彩度偏移門檻（白色 ≈ U/V 靠近 128）
@objc var blockSize: NSNumber = 8   // 區塊邊長
@objc var roiPad: NSNumber = 64     // ROI 半徑
@objc var onSample: RCTDirectEventBlock?

// 權重與平滑（可視需要調整；不暴露到 JS 也行）
private let wMotion: Double = 1.0
private let wLuma:   Double = 0.5
private let wChroma: Double = 1.0
private let posAlpha: Double = 0.25  // 位置 EMA
private let maxMiss: Int = 8         // 連續弱訊號幀 → 回全畫面

// 相機
private let session = AVCaptureSession()
private var previewLayer: AVCaptureVideoPreviewLayer?
private let queue = DispatchQueue(label: "speedcam.capture")

// 上幀快取（Y 平面）
private var prevPtr: UnsafeMutablePointer<UInt8>?
private var prevCap: Int = 0
private var prevW = 0, prevH = 0, prevStride = 0

// ROI 狀態
private var useROI = false
private var roiX = 0, roiY = 0, roiW = 0, roiH = 0
private var miss = 0

// 位置平滑
private var emaCx: Double = 0
private var emaCy: Double = 0
private var hasEma = false

deinit { prevPtr?.deallocate() }

override init(frame: CGRect) {
super.init(frame: frame)
backgroundColor = .black
setupSession()
}
required init?(coder: NSCoder) { fatalError() }

override func layoutSubviews() {
super.layoutSubviews()
previewLayer?.frame = bounds
}

private func setupSession() {
session.beginConfiguration()
session.sessionPreset = .vga640x480

guard
  let device = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .back),
  let input = try? AVCaptureDeviceInput(device: device),
  session.canAddInput(input)
else { session.commitConfiguration(); return }

session.addInput(input)

do {
  try device.lockForConfiguration()
  device.activeVideoMinFrameDuration = CMTime(value: 1, timescale: 30)
  device.activeVideoMaxFrameDuration = CMTime(value: 1, timescale: 30)
  device.unlockForConfiguration()
} catch {}

let output = AVCaptureVideoDataOutput()
output.videoSettings = [
  kCVPixelBufferPixelFormatTypeKey as String:
    kCVPixelFormatType_420YpCbCr8BiPlanarFullRange // NV12
]
output.alwaysDiscardsLateVideoFrames = true
output.setSampleBufferDelegate(self, queue: queue)
guard session.canAddOutput(output) else { session.commitConfiguration(); return }
session.addOutput(output)

let layer = AVCaptureVideoPreviewLayer(session: session)
layer.videoGravity = .resizeAspectFill
layer.frame = bounds
self.layer.addSublayer(layer)
self.previewLayer = layer

session.commitConfiguration()
if isActive.boolValue { session.startRunning() }
}

private func start() { if !session.isRunning { session.startRunning() } }
private func stop()  { if  session.isRunning { session.stopRunning()  } }

private func ensurePrev(cap: Int) {
if cap > prevCap {
prevPtr?.deallocate()
prevPtr = UnsafeMutablePointer<UInt8>.allocate(capacity: cap)
prevCap = cap
}
}

// 主處理：Block 差分 + 顏色過濾 + ROI
private func process(pb: CVPixelBuffer, tsMs: Double) {
CVPixelBufferLockBaseAddress(pb, .readOnly)
defer { CVPixelBufferUnlockBaseAddress(pb, .readOnly) }

guard let yBaseRaw = CVPixelBufferGetBaseAddressOfPlane(pb, 0) else { return }
let yBase = yBaseRaw.assumingMemoryBound(to: UInt8.self)
guard let uvBaseRaw = CVPixelBufferGetBaseAddressOfPlane(pb, 1) else { return }
let uvBase = uvBaseRaw.assumingMemoryBound(to: UInt8.self)

let w = CVPixelBufferGetWidthOfPlane(pb, 0)
let h = CVPixelBufferGetHeightOfPlane(pb, 0)
let yStride = CVPixelBufferGetBytesPerRowOfPlane(pb, 0)
let uvStride = CVPixelBufferGetBytesPerRowOfPlane(pb, 1)
let cap = yStride * h

ensurePrev(cap: cap)

// 首幀：建立 prev
if prevPtr == nil || prevW != w || prevH != h || prevStride != yStride {
  memcpy(prevPtr!, yBase, cap)
  prevW = w; prevH = h; prevStride = yStride
  useROI = false; miss = 0; hasEma = false
  return
}

let B = max(4, Int(truncating: blockSize))       // block 邊長
let yMinV = max(0, min(255, Int(truncating: yMin)))
let cMaxV = max(0, min(255, Int(truncating: chromaMax)))
let roiPadPx = max(B, Int(truncating: roiPad))

// ROI 邊界
var sx = 0, sy = 0, ex = w - B, ey = h - B
if useROI {
  sx = max(0, roiX)
  sy = max(0, roiY)
  ex = min(w - B, roiX + roiW - B)
  ey = min(h - B, roiY + roiH - B)
}

var best = 0.0
var bx = sx, by = sy

var y = sy
while y <= ey {
  var x = sx
  while x <= ex {
    // 1) Motion: Sum |Ycurr - Yprev|
    var mSum = 0
    var lumaSum = 0
    var yy = 0
    while yy < B && (y + yy) < h {
      let pPrev = prevPtr!.advanced(by: (y + yy) * yStride + x)
      let pCurr = yBase.advanced(by: (y + yy) * yStride + x)
      var xx = 0
      while xx < B && (x + xx) < w {
        mSum += abs(Int(pCurr[xx]) - Int(pPrev[xx]))
        lumaSum += Int(pCurr[xx])
        xx += 1
      }
      yy += 1
    }
    let lAvg = lumaSum / (B * B)

    // 2) Chroma: NV12（UV 交錯，對應 2x2 的 block）
    // 用 2x2 採樣估計彩度偏移（越接近 128 越白）
    var cSum = 0
    var cCnt = 0
    var yy2 = 0
    while yy2 < B && (y + yy2) < h {
      let uvRow = (y + yy2) >> 1
      var xx2 = 0
      while xx2 < B && (x + xx2) < w {
        let uvCol = (x + xx2) >> 1
        let idx = uvRow * uvStride + uvCol * 2
        let cb = Int(uvBase[idx])
        let cr = Int(uvBase[idx + 1])
        cSum += abs(cb - 128) + abs(cr - 128)
        cCnt += 1
        xx2 += 2
      }
      yy2 += 2
    }
    let cMean = cCnt > 0 ? (cSum / cCnt) : 999

    // 3) 門檻：亮度足夠且彩度偏移小（白、亮）
    if lAvg >= yMinV && cMean <= cMaxV {
      // 4) 綜合分數：運動＋亮度＋白度
      let whiteGain = max(0.0, Double(cMaxV - cMean)) // 越白越高
      let s = Double(mSum) * wMotion + Double(lAvg) * wLuma + whiteGain * wChroma
      if s > best {
        best = s; bx = x; by = y
      }
    }
    x += B
  }
  y += B
}

// 更新 prev
memcpy(prevPtr!, yBase, cap)
prevW = w; prevH = h; prevStride = yStride

if best <= 0 {
  miss += 1
  if miss >= maxMiss { useROI = false }
  return
}
miss = 0

// ROI 更新（以最佳區塊中心為核心）
let cxPix = bx + B / 2
let cyPix = by + B / 2
let pad = roiPadPx
roiX = max(0, cxPix - pad)
roiY = max(0, cyPix - pad)
roiW = min(w - roiX, pad * 2)
roiH = min(h - roiY, pad * 2)
useROI = true

// 位置平滑（EMA）
let cx = Double(cxPix) / Double(w)
let cy = Double(cyPix) / Double(h)
if !hasEma { emaCx = cx; emaCy = cy; hasEma = true }
else {
  emaCx = posAlpha * cx + (1.0 - posAlpha) * emaCx
  emaCy = posAlpha * cy + (1.0 - posAlpha) * emaCy
}

// 回 JS（主執行緒）
if let onSample = self.onSample {
  DispatchQueue.main.async {
    onSample([
      "x": self.emaCx, "y": self.emaCy,
      "ts": tsMs,
      "w": w, "h": h,
      "score": best
    ])
  }
}
}

// AVCapture Delegate
func captureOutput(_ output: AVCaptureOutput, didOutput sampleBuffer: CMSampleBuffer, from connection: AVCaptureConnection) {
guard let pb = CMSampleBufferGetImageBuffer(sampleBuffer) else { return }
let tsMs = CMTimeGetSeconds(CMSampleBufferGetPresentationTimeStamp(sampleBuffer)) * 1000.0
process(pb: pb, tsMs: tsMs)
}
}ezbmt-tracked/ios/STPlugin.m
 
#if __has_include(<VisionCamera/FrameProcessorPlugin.h>)
#import <VisionCamera/FrameProcessorPlugin.h>
#import <VisionCamera/Frame.h>
#elif __has_include(<VisionCamera/FrameProcessor/FrameProcessorPlugin.h>)
// 某些版本在子目錄 FrameProcessor 下
#import <VisionCamera/FrameProcessor/FrameProcessorPlugin.h>
#import <VisionCamera/FrameProcessor/Frame.h>
#elif __has_include(<react-native-vision-camera/FrameProcessorPlugin.h>)
#import <react-native-vision-camera/FrameProcessorPlugin.h>
#import <react-native-vision-camera/Frame.h>
#elif __has_include(<react-native-vision-camera/FrameProcessor/FrameProcessorPlugin.h>)
#import <react-native-vision-camera/FrameProcessor/FrameProcessorPlugin.h>
#import <react-native-vision-camera/FrameProcessor/Frame.h>
#else
// 走搜尋路徑（我們已把 node_modules/…/ios/FrameProcessor 加進 Header Search Paths）
#import "FrameProcessorPlugin.h"
#import "Frame.h"
#endif

#import "ezbmt-Swift.h"

// Swift 類與 JS 名稱都叫 STPlugin
VISION_EXPORT_SWIFT_FRAME_PROCESSOR(STPlugin, STPlugin)
ezbmt-tracked/ios/RNSpeedCamViewManager.swift
 
import Foundation
import React

@objc(RNSpeedCamViewManager)
class RNSpeedCamViewManager: RCTViewManager {
override static func requiresMainQueueSetup() -> Bool { true }
override func view() -> UIView! { SpeedCamView() }
}ezbmt-tracked/ios/SpeedTracker.m
 
#import <VisionCamera/FrameProcessorPlugin.h>
#import <VisionCamera/Frame.h>
#import "ezbmt-Swift.h"

// 兩個參數都用同一個名字 "SpeedTracker"
VISION_EXPORT_SWIFT_FRAME_PROCESSOR(SpeedTracker, SpeedTracker)
ezbmt-tracked/ios/Podfile
 
# Resolve react_native_pods.rb with node to allow for hoisting
require Pod::Executable.execute_command('node', ['-p',
  'require.resolve(
    "react-native/scripts/react_native_pods.rb",
    {paths: [process.argv[1]]},
  )', __dir__]).strip

platform :ios, min_ios_version_supported
prepare_react_native_project!

linkage = ENV['USE_FRAMEWORKS']
if linkage
Pod::UI.puts "Configuring Pod with #{linkage}ally linked Frameworks".green
use_frameworks! :linkage => linkage.to_sym
else
use_frameworks! :linkage => :static
end

target 'ezbmt' do
config = use_native_modules!

use_react_native!(
:path => config[:reactNativePath],
# An absolute path to your application root.
:app_path => "#{Pod::Config.instance.installation_root}/.."
# :hermes_enabled => true, # 預設為 true，如需暫時關閉可設 false
)

post_install do |installer|
# React Native 預設後處理
react_native_post_install(
installer,
config[:reactNativePath],
:mac_catalyst_enabled => false
)

# 關閉 Xcode 15 的 User Script Sandboxing（解 rsync sandbox 錯誤）
installer.pods_project.targets.each do |t|
  t.build_configurations.each do |bc|
    bc.build_settings['ENABLE_USER_SCRIPT_SANDBOXING'] = 'NO'
  end
end
installer.pods_project.save

installer.aggregate_targets.each do |agg|
  agg.user_project.native_targets.each do |t|
    t.build_configurations.each do |bc|
      bc.build_settings['ENABLE_USER_SCRIPT_SANDBOXING'] = 'NO'
    end
  end
  agg.user_project.save
end

# 讓 VisionCamera 以 module 方式匯入（避免 modulemap 類型錯誤）
vc = installer.pods_project.targets.find { |t| t.name == 'VisionCamera' }
if vc
  vc.build_configurations.each do |bc|
    bc.build_settings['DEFINES_MODULE'] = 'YES'
    bc.build_settings['CLANG_ENABLE_MODULES'] = 'YES'
  end
end
end end
ezbmt-tracked/supabase/functions/invite-by-email/index.ts
 
// @ts-nocheck
/// <reference lib="deno.ns" />
/// <reference lib="dom" />

import { serve } from 'https://deno.land/std@0.224.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

type MemberRole = 'owner' | 'coach' | 'recorder' | 'player' | 'viewer'

function json(body: unknown, status = 200) {
return new Response(JSON.stringify(body), {
status,
headers: { 'content-type': 'application/json' },
})
}

serve(async (req: Request) => {
try {
// 支援兩組命名：建議使用 PROJECT_URL/ANON_KEY/SERVICE_ROLE_KEY；若有設 SUPABASE_* 也可讀取
const SUPABASE_URL =
Deno.env.get('PROJECT_URL') ?? Deno.env.get('SUPABASE_URL')
const ANON_KEY =
Deno.env.get('ANON_KEY') ?? Deno.env.get('SUPABASE_ANON_KEY')
const SERVICE_KEY =
Deno.env.get('SERVICE_ROLE_KEY') ?? Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')

if (!SUPABASE_URL || !ANON_KEY || !SERVICE_KEY) {
  return json(
    { error: 'Missing env: PROJECT_URL/ANON_KEY/SERVICE_ROLE_KEY' },
    500,
  )
}

// 解析參數
const body = await req.json().catch(() => ({}))
const { eventId, email, role } = body as {
  eventId?: string
  email?: string
  role?: MemberRole
}
if (!eventId || !email || !role) {
  return json({ error: 'missing params' }, 400)
}

// 需要使用者 JWT（前端 invoke 或 fetch 時帶 Authorization: Bearer <access_token>）
const authHeader = req.headers.get('Authorization') || ''
const jwt = authHeader.startsWith('Bearer ')
  ? authHeader.slice(7)
  : null
if (!jwt) return json({ error: 'unauthorized' }, 401)

// 使用者身分（權限檢查：必須為該事件 owner/coach）
const userClient = createClient(SUPABASE_URL, ANON_KEY, {
  global: { headers: { Authorization: `Bearer ${jwt}` } },
})
const { data: me } = await userClient.auth.getUser()
const uid = me?.user?.id
if (!uid) return json({ error: 'unauthorized' }, 401)

const { data: can, error: roleErr } = await userClient
  .from('event_members')
  .select('role')
  .eq('event_id', eventId)
  .eq('user_id', uid)
  .maybeSingle()
if (roleErr) return json({ error: roleErr.message }, 500)
if (!can || !['owner', 'coach'].includes(String(can.role))) {
  return json({ error: 'forbidden' }, 403)
}

// Admin client（繞過 RLS）
const admin = createClient(SUPABASE_URL, SERVICE_KEY)

// 取得/建立被邀請者 userId：邀請 -> 尋找 -> 建立
let targetId: string | null = null
const lowerEmail = String(email).toLowerCase()

// A) 嘗試寄出邀請（若未設定 SMTP 可能會失敗）
try {
  const { data: invited } = await admin.auth.admin.inviteUserByEmail(lowerEmail)
  if (invited?.user?.id) targetId = invited.user.id
} catch {
  // ignore，改走 B/C
}

// B) 已註冊？用 listUsers 找 email
if (!targetId) {
  const { data: list, error: listErr } = await admin.auth.admin.listUsers({
    page: 1,
    perPage: 1000,
  })
  if (listErr) return json({ error: listErr.message }, 500)
  const found = (list?.users || []).find(
    (u: any) => String(u.email || '').toLowerCase() === lowerEmail,
  )
  if (found) targetId = found.id
}

// C) 還沒有？直接建立帳號（不寄信）
if (!targetId) {
  const { data: created, error: cErr } = await admin.auth.admin.createUser({
    email: lowerEmail,
    email_confirm: false,
  })
  if (cErr) return json({ error: cErr.message }, 400)
  targetId = created.user?.id || null
}

if (!targetId) return json({ error: 'user not found' }, 404)

// upsert 事件成員
const { error: upErr } = await admin
  .from('event_members')
  .upsert(
    { event_id: eventId, user_id: targetId, role },
    { onConflict: 'event_id,user_id' },
  )
if (upErr) return json({ error: upErr.message }, 400)

// 記錄/累加邀請歷史（invite_contacts）
try {
  const { data: ex } = await admin
    .from('invite_contacts')
    .select('total_count')
    .eq('owner_id', uid)
    .eq('email', lowerEmail)
    .maybeSingle()

  if (ex) {
    await admin
      .from('invite_contacts')
      .update({
        last_role: role,
        total_count: (ex.total_count || 0) + 1,
        last_invited_at: new Date().toISOString(),
      })
      .eq('owner_id', uid)
      .eq('email', lowerEmail)
  } else {
    await admin.from('invite_contacts').insert({
      owner_id: uid,
      email: lowerEmail,
      last_role: role,
      total_count: 1,
      last_invited_at: new Date().toISOString(),
    })
  }
} catch {
  // 歷史寫入失敗不影響主流程
}

return json({ ok: true, userId: targetId }, 200)
} catch (e) {
const msg = (e as any)?.message || String(e)
return json({ error: msg }, 500)
}
})ezbmt-tracked/supabase/functions/invite-club-by-email/index.ts
 
// @ts-nocheck
/// <reference lib="deno.ns" />
import { serve } from 'https://deno.land/std@0.224.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

type ClubRole = 'owner'|'admin'|'scheduler'|'scorer'|'member'

function json(body: unknown, status = 200) {
return new Response(JSON.stringify(body), { status, headers: { 'content-type':'application/json' } })
}

serve(async (req: Request) => {
try {
const SUPABASE_URL = Deno.env.get('PROJECT_URL') ?? Deno.env.get('SUPABASE_URL')
const ANON_KEY = Deno.env.get('ANON_KEY') ?? Deno.env.get('SUPABASE_ANON_KEY')
const SERVICE_KEY = Deno.env.get('SERVICE_ROLE_KEY') ?? Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')
if (!SUPABASE_URL || !ANON_KEY || !SERVICE_KEY) return json({ error:'Missing env' }, 500)

const body = await req.json().catch(()=> ({}))
const { clubId, email, role } = body as { clubId?: string; email?: string; role?: ClubRole }
if (!clubId || !email || !role) return json({ error:'missing params' }, 400)

const authHeader = req.headers.get('Authorization') || ''
const jwt = authHeader.startsWith('Bearer ') ? authHeader.slice(7) : null
if (!jwt) return json({ error:'unauthorized' }, 401)

// 使用者身分與權限檢查：需為 owner/admin
const userClient = createClient(SUPABASE_URL, ANON_KEY, { global:{ headers:{ Authorization:`Bearer ${jwt}` }} })
const { data: me } = await userClient.auth.getUser()
const uid = me?.user?.id
if (!uid) return json({ error:'unauthorized' }, 401)

const { data: can, error: ce } = await userClient
  .from('club_members')
  .select('role')
  .eq('club_id', clubId)
  .eq('user_id', uid)
  .maybeSingle()
if (ce) return json({ error: ce.message }, 500)
if (!can || !['owner','admin'].includes(String(can.role))) return json({ error:'forbidden' }, 403)

// Admin client
const admin = createClient(SUPABASE_URL, SERVICE_KEY)

let targetId: string | null = null
const lowerEmail = String(email).toLowerCase()

// A) 邀請
try {
  const { data: invited } = await admin.auth.admin.inviteUserByEmail(lowerEmail)
  if (invited?.user?.id) targetId = invited.user.id
} catch {}

// B) 找既有
if (!targetId) {
  const { data: list } = await admin.auth.admin.listUsers({ page:1, perPage:1000 })
  const found = (list?.users||[]).find((u:any) => String(u.email||'').toLowerCase() === lowerEmail)
  if (found) targetId = found.id
}

// C) 未有則建立
if (!targetId) {
  const { data: created, error: ce2 } = await admin.auth.admin.createUser({ email: lowerEmail, email_confirm: false })
  if (ce2) return json({ error: ce2.message }, 400)
  targetId = created.user?.id || null
}
if (!targetId) return json({ error:'user not found' }, 404)

// upsert club_members
const { error: upErr } = await admin
  .from('club_members')
  .upsert({ club_id: clubId, user_id: targetId, role }, { onConflict: 'club_id,user_id' })
if (upErr) return json({ error: upErr.message }, 400)

// 記錄邀請歷史（可選）
try {
  const { data: ex } = await admin
    .from('invite_contacts')
    .select('total_count')
    .eq('owner_id', uid).eq('email', lowerEmail).maybeSingle()
  if (ex) {
    await admin.from('invite_contacts')
      .update({ last_role: role, total_count: (ex.total_count||0)+1, last_invited_at: new Date().toISOString() })
      .eq('owner_id', uid).eq('email', lowerEmail)
  } else {
    await admin.from('invite_contacts')
      .insert({ owner_id: uid, email: lowerEmail, last_role: role, total_count: 1, last_invited_at: new Date().toISOString() })
  }
} catch {}

return json({ ok:true, userId: targetId })
} catch (e) { return json({ error: String((e as any)?.message || e) }, 500) } })ezbmt-tracked/metro.config.js
 
const { getDefaultConfig, mergeConfig } = require('@react-native/metro-config');

/**
 * Metro configuration
 * https://reactnative.dev/docs/metro
 *
 * @type {import('@react-native/metro-config').MetroConfig}
 */
const config = {};

module.exports = mergeConfig(getDefaultConfig(__dirname), config);
ezbmt-tracked/babel.config.js
 
module.exports = {
presets: ['module:@react-native/babel-preset'],
plugins: [
'react-native-reanimated/plugin',
'react-native-worklets-core/plugin',
],
};ezbmt-tracked/__tests__/App.test.tsx
 
/**
 * @format
 */

import React from 'react';
import ReactTestRenderer from 'react-test-renderer';
import App from '../App';

test('renders correctly', async () => {
  await ReactTestRenderer.act(() => {
    ReactTestRenderer.create(<App />);
  });
});
ezbmt-tracked/package.json
 
{
  "name": "ezbmt",
  "version": "0.0.1",
  "private": true,
  "scripts": {
    "android": "react-native run-android",
    "ios": "react-native run-ios",
    "lint": "eslint .",
    "start": "react-native start",
    "test": "jest",
    "gen:icons": "node scripts/gen-icons.js"
  },
  "dependencies": {
    "@react-native-async-storage/async-storage": "^2.2.0",
    "@react-native-picker/picker": "^2.11.2",
    "@react-native/new-app-screen": "0.81.1",
    "@react-navigation/native": "^7.1.17",
    "@react-navigation/native-stack": "^7.3.26",
    "@supabase/supabase-js": "^2.57.4",
    "cd": "^0.3.3",
    "date-fns": "^4.1.0",
    "ios": "^0.0.1",
    "react": "19.1.0",
    "react-hook-form": "^7.62.0",
    "react-native": "0.81.1",
    "react-native-badminton-speed": "file:../react-native-badminton-speed",
    "react-native-bootsplash": "^6.3.11",
    "react-native-fs": "^2.20.0",
    "react-native-geolocation-service": "^5.3.1",
    "react-native-gesture-handler": "^2.28.0",
    "react-native-get-random-values": "^1.11.0",
    "react-native-html-to-pdf": "^1.3.0",
    "react-native-image-picker": "^8.2.1",
    "react-native-keep-awake": "^4.0.0",
    "react-native-map": "^0.0.1",
    "react-native-maps": "^1.26.9",
    "react-native-orientation-locker": "^1.7.0",
    "react-native-reanimated": "^4.1.0",
    "react-native-safe-area-context": "^5.6.1",
    "react-native-screens": "^4.16.0",
    "react-native-share": "^12.2.0",
    "react-native-sqlite-storage": "^6.0.1",
    "react-native-svg": "^15.13.0",
    "react-native-url-polyfill": "^2.0.0",
    "react-native-vision-camera": "^4.7.2",
    "react-native-webrtc": "^124.0.6",
    "react-native-webview": "^13.16.0",
    "react-native-worklets": "^0.5.1",
    "react-native-worklets-core": "^1.6.2",
    "react-native-youtube-iframe": "^2.4.1",
    "uuid": "^13.0.0",
    "zod": "^4.1.5",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@babel/preset-env": "^7.25.3",
    "@babel/runtime": "^7.25.0",
    "@react-native-community/cli": "20.0.0",
    "@react-native-community/cli-platform-android": "20.0.0",
    "@react-native-community/cli-platform-ios": "20.0.0",
    "@react-native/babel-preset": "0.81.1",
    "@react-native/eslint-config": "0.81.1",
    "@react-native/metro-config": "0.81.1",
    "@react-native/typescript-config": "0.81.1",
    "@types/jest": "^29.5.13",
    "@types/react": "^19.1.0",
    "@types/react-test-renderer": "^19.1.0",
    "@types/uuid": "^10.0.0",
    "eslint": "^8.19.0",
    "jest": "^29.6.3",
    "prettier": "2.8.8",
    "react-test-renderer": "19.1.0",
    "sharp": "^0.34.3",
    "typescript": "^5.8.3"
  },
  "engines": {
    "node": ">=20"
  }
}
ezbmt-tracked/.prettierrc.js
 
module.exports = {
  arrowParens: 'avoid',
  singleQuote: true,
  trailingComma: 'all',
};
ezbmt-tracked/scripts/gen-icons.js
 
/* scripts/gen-icons.js */
const fs = require('fs');
const path = require('path');
const sharp = require('sharp');

const SRC = path.resolve(__dirname, '../assets/appicon.svg');

// iOS AppIcon 尺寸（pt × scale）
const ios = [
{ size: 20,  scales: [2,3] },
{ size: 29,  scales: [2,3] },
{ size: 40,  scales: [2,3] },
{ size: 60,  scales: [2,3] },
{ size: 1024, scales: [1], marketing: true },
];

// Android mipmap（px）
const android = [
{ dir: 'mipmap-mdpi',    size: 48 },
{ dir: 'mipmap-hdpi',    size: 72 },
{ dir: 'mipmap-xhdpi',   size: 96 },
{ dir: 'mipmap-xxhdpi',  size: 144 },
{ dir: 'mipmap-xxxhdpi', size: 192 },
];

(async () => {
// iOS
const iosDir = path.resolve(__dirname, '../ios/ezbmt/Images.xcassets/AppIcon.appiconset');
if (!fs.existsSync(iosDir)) fs.mkdirSync(iosDir, { recursive: true });
const contents = { images: [], info: { version: 1, author: 'xcode' } };

for (const row of ios) {
if (row.marketing) {
const out = path.join(iosDir, 'ios-marketing-1024.png');
await sharp(SRC).resize(1024, 1024).png().toFile(out);
contents.images.push({ idiom: 'ios-marketing', size: '1024x1024', scale: '1x', filename: 'ios-marketing-1024.png' });
continue;
}
for (const s of row.scales) {
const px = row.size * s;
const name = `icon-${row.size}pt@${s}x.png`;
const out = path.join(iosDir, name);
await sharp(SRC).resize(px, px).png().toFile(out);
contents.images.push({ idiom: 'iphone', size: `${row.size}x${row.size}`, scale: `${s}x`, filename: name });
}
}
fs.writeFileSync(path.join(iosDir, 'Contents.json'), JSON.stringify(contents, null, 2));

// Android
const resDir = path.resolve(__dirname, '../android/app/src/main/res');
for (const a of android) {
const dir = path.join(resDir, a.dir);
if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
await sharp(SRC).resize(a.size, a.size).png().toFile(path.join(dir, 'ic_launcher.png'));
await sharp(SRC).resize(a.size, a.size).png().toFile(path.join(dir, 'ic_launcher_round.png'));
}
console.log('✓ Icons generated for iOS/Android');
})();ezbmt-tracked/.eslintrc.js
 
module.exports = {
  root: true,
  extends: '@react-native',
};
ezbmt-tracked/tsconfig.json
 

{ "extends": "@react-native/typescript-config"
 , 
 "compilerOptions": { "skipLibCheck": true, "typeRoots": ["./src/@types", "./node_modules/@types"] }
 , "include": ["src//*.ts", "src//*.tsx"], "exclude": ["/node_modules", "/Pods"] }
ezbmt-tracked/src/club/pairing.ts
 
export type PlayerLite = {
id: string;
name: string;
level?: number | null;
gender?: 'M'|'F'|'U'|null;
};

export type AttendeeLite = PlayerLite & {
active?: boolean;
};

export type Pair = [PlayerLite, PlayerLite];
export type Team = { players: PlayerLite[]; avgLevel?: number; tags?: string[] };

export type MatchPlan = {
court_no: number;
team_a: Team;
team_b: Team;
};

export type Constraints = {
courts: number;
teamSize: 1 | 2;                 // 單打/雙打
partnerCooldown: number;         // 最近多少輪不可再搭（或重罰）
opponentWindow: number;          // 最近多少輪避免對上（重罰）
maxLevelDiffPerPair: number;     // 同隊的等級差上限（硬限制）
preferMixedGender?: boolean;     // 混合優先
restCooldown: number;            // 新增：上/下場冷卻輪（距離 < 此輪數的玩家優先休息）
};

export type History = {
recentPairs: Map<string, number>;
recentOpponents: Map<string, number>;
lastPlayedRound: Map<string, number>;
lastIndex: number; // 已存在 rounds 的最大 index_no
};

export type PairingResult = {
matches: Array<{ teamA: Team; teamB: Team }>;
waiting: PlayerLite[];
};

function key2(a: string, b: string) { return a < b ? `${a}|${b}` : `${b}|${a}`; }
function pairKey(team: PlayerLite[]) {
const ids = team.map(p => p.id).sort();
return ids.join('&');
}
function avgLevel(ps: PlayerLite[]) {
const list = ps.map(p => Number(p.level ?? 0)).filter(v => Number.isFinite(v));
if (!list.length) return undefined;
const sum = list.reduce((a,b)=>a+b,0);
return Math.round((sum / list.length) * 10) / 10;
}

/** 從 rounds（含 matches）建立最近歷史，並回傳 lastIndex */
export function buildHistoryFromRounds(
rounds: Array<{ index_no: number; matches: Array<{ team_a:any; team_b:any }> }>,
recentWindow = 3
): History {
const recentPairs = new Map<string, number>();
const recentOpponents = new Map<string, number>();
const lastPlayedRound = new Map<string, number>();

const lastIndex = rounds.length ? Math.max(...rounds.map(r => r.index_no || 0)) : 0;
const startIndex = Math.max(0, lastIndex - recentWindow + 1);

for (const r of rounds) {
const idx = Number(r.index_no || 0);
const dist = lastIndex - idx + 1; // 1=最近一輪
for (const m of r.matches || []) {
const A = ((m.team_a?.players as any[]) || []).map(x => ({ id:String(x.id), name:String(x.name||x.id) }));
const B = ((m.team_b?.players as any[]) || []).map(x => ({ id:String(x.id), name:String(x.name||x.id) }));

  // 更新每人最後上場輪
  [...A, ...B].forEach(p => lastPlayedRound.set(p.id, idx));

  if (idx >= startIndex) {
    if (A.length >= 2) {
      for (let i=0;i<A.length;i++) for (let j=i+1;j<A.length;j++) {
        const k = key2(A[i].id, A[j].id);
        if (!recentPairs.has(k)) recentPairs.set(k, dist);
        else recentPairs.set(k, Math.min(recentPairs.get(k)!, dist));
      }
    }
    if (B.length >= 2) {
      for (let i=0;i<B.length;i++) for (let j=i+1;j<B.length;j++) {
        const k = key2(B[i].id, B[j].id);
        if (!recentPairs.has(k)) recentPairs.set(k, dist);
        else recentPairs.set(k, Math.min(recentPairs.get(k)!, dist));
      }
    }
    const kA = pairKey(A), kB = pairKey(B);
    if (kA && kB) {
      const k = `${kA}|${kB}`;
      if (!recentOpponents.has(k)) recentOpponents.set(k, dist);
      else recentOpponents.set(k, Math.min(recentOpponents.get(k)!, dist));
    }
  }
}
}

return { recentPairs, recentOpponents, lastPlayedRound, lastIndex };
}

/** 配對分數（越高越好） */
function scorePair(a: PlayerLite, b: PlayerLite, cons: Constraints, hist: History): number {
// 硬限制：等級差
const dLevel = Math.abs((a.level ?? 0) - (b.level ?? 0));
if (cons.teamSize === 2 && cons.maxLevelDiffPerPair > 0 && dLevel > cons.maxLevelDiffPerPair) {
return -Infinity;
}

let s = 100;

// 等級差懲罰
const alpha = 5;
s -= alpha * dLevel;

// 近期搭檔懲罰
const k = key2(a.id, b.id);
const dist = hist.recentPairs.get(k); // 1=上一輪
if (dist != null) {
if (dist <= cons.partnerCooldown) s -= 80;
else s -= Math.max(0, 30 - 5 * dist);
}

// 性別偏好（簡單示例）
if (cons.preferMixedGender) {
if ((a.gender && b.gender) && a.gender !== 'U' && b.gender !== 'U') {
if (a.gender !== b.gender) s += 8; else s -= 6;
}
}

return s;
}

/** 依分數由高到低，貪婪挑 pair（在外層已做過休息名單的過濾/回退） */
function greedyMakePairs(candidates: PlayerLite[], cons: Constraints, hist: History): { pairs: Pair[]; waiting: PlayerLite[] } {
if (cons.teamSize === 1) {
const list = [...candidates];
const pairs: Pair[] = [];
while (list.length >= 2) pairs.push([list.shift()!, list.shift()!]);
return { pairs, waiting: list };
}

// doubles
const edges: Array<{ a: PlayerLite; b: PlayerLite; score: number }> = [];
for (let i=0;i<candidates.length;i++) {
for (let j=i+1;j<candidates.length;j++) {
const a = candidates[i], b = candidates[j];
const score = scorePair(a, b, cons, hist);
if (score > -Infinity) edges.push({ a, b, score });
}
}
edges.sort((x,y)=> y.score - x.score);

const used = new Set<string>();
const pairs: Pair[] = [];
for (const e of edges) {
if (used.has(e.a.id) || used.has(e.b.id)) continue;
pairs.push([e.a, e.b]);
used.add(e.a.id); used.add(e.b.id);
}
const waiting = candidates.filter(p => !used.has(p.id));
return { pairs, waiting };
}

/** 兩兩 pair 組成對戰 */
function assembleMatches(pairs: Pair[], cons: Constraints, hist: History): { matches: Array<{ teamA: Team; teamB: Team }>; waitingPairs: Pair[] } {
const teams: Team[] = pairs.map(p => ({ players: [p[0], p[1]], avgLevel: avgLevel([p[0], p[1]]) }));

type Edge = { i: number; j: number; cost: number };
const edges: Edge[] = [];
for (let i=0;i<teams.length;i++) {
for (let j=i+1;j<teams.length;j++) {
const tA = teams[i], tB = teams[j];
const diff = Math.abs((tA.avgLevel ?? 0) - (tB.avgLevel ?? 0));

  const kA = pairKey(tA.players), kB = pairKey(tB.players);
  let oppPenalty = 0;
  const dist = hist.recentOpponents.get(`${kA}|${kB}`) ?? hist.recentOpponents.get(`${kB}|${kA}`);
  if (dist != null && dist <= cons.opponentWindow) {
    oppPenalty = 10 * (cons.opponentWindow - dist + 1);
  }

  const cost = diff + oppPenalty;
  edges.push({ i, j, cost });
}
}
edges.sort((a,b)=> a.cost - b.cost);

const used = new Set<number>();
const matches: Array<{ teamA: Team; teamB: Team }> = [];
for (const e of edges) {
if (used.has(e.i) || used.has(e.j)) continue;
if (matches.length >= cons.courts) break;
matches.push({ teamA: teams[e.i], teamB: teams[e.j] });
used.add(e.i); used.add(e.j);
}

const waitingPairs: Pair[] = [];
for (let i=0;i<teams.length;i++) {
if (!used.has(i)) {
const ps = teams[i].players;
const p: Pair = ps.length >= 2 ? [ps[0], ps[1]] : [ps[0], ps[0]];
waitingPairs.push(p);
}
}
return { matches, waitingPairs };
}

/** 產生一輪（含「上/下場冷卻」） */
export function pairRound(
attendees: AttendeeLite[],
cons: Constraints,
prevRounds: Array<{ index_no:number; matches: Array<{ team_a:any; team_b:any }> }>
): PairingResult {
const active = attendees.slice();
const hist = buildHistoryFromRounds(prevRounds, Math.max(cons.partnerCooldown, cons.opponentWindow, 3));

// 計算下一輪 index
const lastIndex = hist.lastIndex || 0;
const nextIndex = lastIndex + 1;

// 先做「可上場名單」過濾：距離 < restCooldown 的玩家優先休息
let pool = active;
if (cons.restCooldown > 0) {
const eligible = active.filter(p => {
const last = hist.lastPlayedRound.get(p.id);
if (last == null) return true; // 從未上過
const dist = nextIndex - last; // 距離上一次上場的輪差
return dist >= cons.restCooldown;
});

// 人數足夠就用 eligible，不足則回退用全部（避免卡住）
const needBase = cons.teamSize === 1 ? 2 : 4; // 至少能組成一場
pool = eligible.length >= needBase ? eligible : active;
}

// 接著與既有演算法相同
let matches: Array<{ teamA: Team; teamB: Team }> = [];

if (cons.teamSize === 1) {
const list = [...pool];
const singlesPairs: Pair[] = [];
while (list.length >= 2) singlesPairs.push([list.shift()!, list.shift()!]);

const tmp: Array<{ teamA: Team; teamB: Team }> = [];
const pairList = [...singlesPairs];
while (pairList.length >= 2 && tmp.length < cons.courts) {
  const pA = pairList.shift()!;
  const pB = pairList.shift()!;
  tmp.push({
    teamA: { players: [pA[0]], avgLevel: avgLevel([pA[0]]) },
    teamB: { players: [pB[0]], avgLevel: avgLevel([pB[0]]) }
  });
}
matches = tmp;
const waitSingles = pairList.flatMap(p => p);
return { matches, waiting: [...waitSingles, ...active.filter(x=>!pool.includes(x))] };
}

const { pairs, waiting } = greedyMakePairs(pool, cons, hist);
const { matches: m2, waitingPairs } = assembleMatches(pairs, cons, hist);
matches = m2.slice(0, cons.courts);

const waitingPlayers: PlayerLite[] = [...waiting, ...active.filter(x=>!pool.includes(x))];
waitingPairs.forEach(p => { waitingPlayers.push(p[0], p[1]); });

return { matches, waiting: waitingPlayers };
}

ezbmt-tracked/src/@types:react-native-sqlite-storage/index.d.ts
 
declare module 'react-native-sqlite-storage' {
export type SQLResultSetRow = { [key: string]: any };

export type SQLResultSet = {
rows: {
length: number;
item: (index: number) => SQLResultSetRow;
};
insertId?: number;
rowsAffected?: number;
};

export interface SQLiteDatabase {
executeSql: (sqlStatement: string, args?: any[]) => Promise<[SQLResultSet]>;
close: () => Promise<void>;
}

// default export 物件
const SQLiteDefault: {
enablePromise: (enable: boolean) => void;
openDatabase: (
config:
| { name: string; location?: 'default' | 'Library' | 'Documents' }
| string
) => Promise<SQLiteDatabase>;
};

// 額外提供命名空間（讓 SQLite.SQLiteDatabase 也可用）
export as namespace SQLite;
export { SQLiteDatabase };
export default SQLiteDefault;
}


ezbmt-tracked/src/native/SpeedCamNative.tsx
 
import React from 'react';
import { requireNativeComponent, type ViewProps, type NativeSyntheticEvent } from 'react-native';

export type NativeSample = { x: number; y: number; ts: number; w: number; h: number; score: number };

type Props = ViewProps & {
isActive?: boolean;
onSample?: (e: NativeSyntheticEvent<NativeSample>) => void;
yMin?: number;
chromaMax?: number;
blockSize?: number;
roiPad?: number;
};

const RNSpeedCamView = requireNativeComponent<Props>('RNSpeedCamView');
export default RNSpeedCamView;ezbmt-tracked/src/AppNavigator.tsx
 
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import EventsScreen from './screens/EventsScreen';
import MatchesScreen from './screens/MatchesScreen';
import PlayerSetupScreen from './screens/PlayerSetupScreen';
import RecordScreen from './screens/RecordScreen';
import AnalysisScreen from './screens/AnalysisScreen';
import LiveScreen from './screens/LiveScreen';
import ChatScreen from './screens/ChatScreen';
import MediaScreen from './screens/MediaScreen';
import SettingsScreen from './screens/SettingsScreen';
import ReplayScreen from './screens/ReplayScreen';
import AuthScreen from './screens/AuthScreen';
import { BACKEND } from './lib/backend';
import JoinEventScreen from './screens/JoinEventScreen';
import ProfileScreen from './screens/ProfileScreen';
import EventMembersScreen from './screens/EventMembersScreen';
import MatchMembersScreen from './screens/MatchMembersScreen';
import SpeedCam from './screens/SpeedCamScreen';
import HomeScreen from './screens/HomeScreen';
import ClubHomeScreen from './screens/ClubHomeScreen';
import ClubsScreen from './screens/ClubsScreen';
import ClubDashboardScreen from './screens/ClubDashboardScreen';
import BuddiesScreen from './screens/BuddiesScreen';
import SessionsScreen from './screens/SessionsScreen';
import SessionCheckInScreen from './screens/SessionCheckInScreen';
import SessionPairingScreen from './screens/SessionPairingScreen';
import ClubScoreboardScreen from './screens/ClubScoreboardScreen';
import ClubChatScreen from './screens/ClubChatScreen';
import ClubMediaScreen from './screens/ClubMediaScreen';
import PairingScreen from './screens/PairingScreen';
import ClubBoardScreen from './screens/ClubBoardScreen';
import ClubStatsScreen from './screens/ClubStatsScreen';
import ClubMembersScreen from './screens/ClubMembersScreen'; 
import QuickScoreboardScreen from './screens/QuickScoreboardScreen';
import AdminModerationScreen from './screens/AdminModerationScreen'; 
import WebCamScreen from './screens/WebCamScreen';
import WebCamViewerScreen from './screens/WebCamViewerScreen';
import ClubAudienceBoardScreen from './screens/ClubAudienceBoardScreen';
import SessionSignupsScreen from './screens/SessionSignupsScreen';

const Stack = createNativeStackNavigator();

export default function AppNavigator() {
const headerDark = React.useMemo(() => ({
headerStyle: { backgroundColor: '#111' },   // 標題列底色
headerTitleStyle: { color: '#fff' },        // 標題文字
headerTintColor: '#fff',                    // 返回箭頭/右上角按鈕顏色
headerShadowVisible: false,                 // 移除底部陰影（更貼近深色）
// 若 iOS 想做霧面可用：headerBlurEffect: 'systemChromeMaterialDark'
}), []);
return (
<Stack.Navigator
initialRouteName="Events"
screenOptions={{ headerBackTitle: '', ...headerDark }}
>
{BACKEND === 'supabase' && (
<Stack.Screen name="Auth" component={AuthScreen} options={{ title: '登入' }} />
)}
<Stack.Screen name="Home" component={HomeScreen} options={{ title: '首頁', headerBackVisible: false }} />
<Stack.Screen name="ClubHome" component={ClubHomeScreen} options={{ title: '社團管理' }} />
<Stack.Screen name="JoinEvent" component={JoinEventScreen} options={{ title: '加入事件' }} />
<Stack.Screen name="Profile" component={ProfileScreen} options={{ title: '個人' }} />
<Stack.Screen name="EventMembers" component={EventMembersScreen} options={{ title: '事件成員' }} />
<Stack.Screen name="MatchMembers" component={MatchMembersScreen} options={{ title: '場次成員' }} />
<Stack.Screen name="Events" component={EventsScreen} options={{ title: '賽事' }} />
<Stack.Screen name="Matches" component={MatchesScreen} options={{ title: '場次' }} />
<Stack.Screen name="PlayerSetup" component={PlayerSetupScreen} options={{ title: '球員與起始設定' }} />
<Stack.Screen name="Record" component={RecordScreen} options={{ title: '記錄' }} />
<Stack.Screen name="Analysis" component={AnalysisScreen} options={{ title: '分析' }} />
<Stack.Screen name="Live" component={LiveScreen} options={{ title: '即時分數' }} />
<Stack.Screen name="Chat" component={ChatScreen} options={{ title: '聊天室' }} />
<Stack.Screen name="Media" component={MediaScreen} options={{ title: '媒體' }} />
<Stack.Screen name="Settings" component={SettingsScreen} options={{ title: '設定' }} />
<Stack.Screen name="Replay" component={ReplayScreen} options={{ title: '路徑回放' }} />
<Stack.Screen name="SpeedCam" component={SpeedCam} options={{ title: '測速' }} />
<Stack.Screen name="Clubs" component={ClubsScreen} options={{ title: '我的社團' }} />
<Stack.Screen name="ClubDashboard" component={ClubDashboardScreen} options={{ title: '社團主頁' }} />
<Stack.Screen name="Buddies" component={BuddiesScreen} options={{ title: '球友名單' }} />
<Stack.Screen name="Sessions" component={SessionsScreen} options={{ title: '場次' }} />
<Stack.Screen name="SessionCheckIn" component={SessionCheckInScreen} options={{ title: '報到名單' }} />
<Stack.Screen name="SessionPairing" component={SessionPairingScreen} options={{ title: '排點' }} />
<Stack.Screen name="ClubScoreboard" component={ClubScoreboardScreen} options={{ title: '計分板' }} />
<Stack.Screen name="ClubChat" component={ClubChatScreen} options={{ title: '社團聊天室' }} />
<Stack.Screen name="ClubMedia" component={ClubMediaScreen} options={{ title: '社團媒體' }} />
<Stack.Screen name="ClubPairing" component={PairingScreen} options={{ title: '社團排點' }} />
<Stack.Screen name="ClubBoard" component={ClubBoardScreen} options={{ title: '看板' }} />
<Stack.Screen name="ClubStats" component={ClubStatsScreen} options={{ title: '社團統計' }} />
 <Stack.Screen name="ClubMembers" component={ClubMembersScreen} options={{ title: '社團成員' }} />
 <Stack.Screen name="QuickScoreboard" component={QuickScoreboardScreen} options={{ title: '快速計分板' }} />
 {/* 新增：最大管理者的社群管理 */}
<Stack.Screen name="AdminModeration" component={AdminModerationScreen} options={{ title: '社群管理（管理者）' }} />
<Stack.Screen name="WebCam" component={WebCamScreen} options={{ title: 'WEB CAM' }} />
<Stack.Screen name="WebCamViewer" component={WebCamViewerScreen} options={{ title: '觀看 CAM' }} />
<Stack.Screen name="ClubBoardAudience" component={ClubAudienceBoardScreen} options={{ title: '看板（唯讀）' }} />
<Stack.Screen name="SessionSignups" component={SessionSignupsScreen} options={{ title: '報名/候補名單' }} />
</Stack.Navigator>
);
}ezbmt-tracked/src/@types:react-native-keep_awake/index.d.ts
 
declare module 'react-native-keep-awake' {
const KeepAwake: {
activate(): void;
deactivate(): void;
};
export default KeepAwake;
}ezbmt-tracked/src/tests/serve.test.ts
 
import assert from 'assert';
import {
createMatch,
getRotationSnapshot,
nextRally,
} from '../serve';

function makeMatch() {
return createMatch({
teams: [
{ players: [{ id: 'A0' }, { id: 'A1' }], startRightIndex: 0 },
{ players: [{ id: 'B0' }, { id: 'B1' }], startRightIndex: 0 },
],
startingServerTeam: 0,
startingServerPlayerIndex: 0,
rules: { bestOf: 3, pointsToWin: 21, winBy: 2, cap: 30 },
});
}

// Test 1: same server continues on wins, court alternates
{
const m = makeMatch();
let snap = getRotationSnapshot(m);
assert.equal(snap.servingTeam, 0);
assert.equal(snap.server.team, 0);
assert.equal(snap.server.index, 0);
assert.equal(snap.server.court, 'R'); // 0-0 right court

nextRally(m, 0); // A wins, 1-0
snap = getRotationSnapshot(m);
assert.equal(snap.server.team, 0);
assert.equal(snap.server.index, 0);
assert.equal(snap.server.court, 'L'); // alternates

nextRally(m, 0); // 2-0
snap = getRotationSnapshot(m);
assert.equal(snap.server.court, 'R');

nextRally(m, 0); // 3-0
snap = getRotationSnapshot(m);
assert.equal(snap.server.court, 'L');
}

// Test 2: receiving side wins => service changes; new server = right-court player of that side
{
const m = makeMatch();
nextRally(m, 0); // 1-0 (A serves continues)
nextRally(m, 1); // 1-1 (B wins while receiving) => B serves next
const snap = getRotationSnapshot(m);
// B score=1 (odd) with startRightIndex=0 => right index = 1
assert.equal(snap.servingTeam, 1);
assert.equal(snap.server.team, 1);
assert.equal(snap.server.index, 1);
assert.equal(snap.server.court, 'R');
// Receiver should be A right court (A score=1 => right=A1)
assert.equal(snap.receiver.team, 0);
assert.equal(snap.receiver.index, 1);
}

// Test 3: deuce to cap
{
const m = createMatch({
teams: [
{ players: [{ id: 'A0' }, { id: 'A1' }] },
{ players: [{ id: 'B0' }, { id: 'B1' }] },
],
rules: { pointsToWin: 21, winBy: 2, cap: 30, bestOf: 1 },
});

// Drive to 29-29
let a = 0, b = 0;
while (a < 29 || b < 29) {
if (a <= b) { nextRally(m, 0); a++; } else { nextRally(m, 1); b++; }
}
let snap = getRotationSnapshot(m);
assert.deepEqual(snap.score, [29, 29]);

// Next rally decides at cap 30
nextRally(m, 0);
snap = getRotationSnapshot(m);
// Game over, but state advanced to next game only if bestOf>1; here bestOf=1, we stay with 1 game finished.
assert.equal(m.games[0].winner, 0);
}

// Test 4: best-of-3 match completion
{
const m = makeMatch();

// Game1: A wins 21-0
for (let i = 0; i < 21; i++) nextRally(m, 0);
assert.equal(m.games[0].winner, 0);

// Game2: B wins 21-0
for (let i = 0; i < 21; i++) nextRally(m, 1);
assert.equal(m.games[1].winner, 1);

// Game3: A wins 21-0 => match over
for (let i = 0; i < 21; i++) nextRally(m, 0);
assert.equal(m.games[2].winner, 0);
}
ezbmt-tracked/src/logic/serve.ts
 
export type TeamId = 0 | 1;
export type PairIndex = 0 | 1;
export type Court = 'R' | 'L';

export interface PlayerMeta {
id: string;
name?: string;
gender?: 'M' | 'F' | 'U';
handedness?: 'L' | 'R' | 'U';
}

export interface TeamConfig {
players: [PlayerMeta, PlayerMeta];
startRightIndex?: PairIndex;
}

export interface RuleConfig {
bestOf?: 1 | 3 | 5;
pointsToWin?: number;
winBy?: number;
cap?: number | null;
technicalTimeoutAt?: number | null;
changeEndsInDeciderAt?: number | null;
}

export interface MatchConfig {
teams: [TeamConfig, TeamConfig];
startingServerTeam?: TeamId;
startingServerPlayerIndex?: PairIndex;
rules?: RuleConfig;
metadata?: { category?: 'MD' | 'WD' | 'XD' | 'CUSTOM' };
}

export interface GameScore {
points: [number, number];
winner?: TeamId;
intervalTaken?: boolean;
deciderSidesSwitched?: boolean;
}

export interface MatchState {
teams: [Required<TeamConfig>, Required<TeamConfig>];
rules: Required<RuleConfig>;
metadata?: MatchConfig['metadata'];

currentGameIndex: number;
games: GameScore[];

// 目前發球方與發球員索引（以 teams[servingTeam].players 的索引）
servingTeam: TeamId;
serverPlayerIndex: PairIndex;

// 新增：目前兩隊「在右區」的是誰（0/1）
posRight: [PairIndex, PairIndex];

_version?: number;
}

/* defaults */
const DEFAULT_RULES: Required<RuleConfig> = {
bestOf: 3,
pointsToWin: 21,
winBy: 2,
cap: 30,
technicalTimeoutAt: 11,
changeEndsInDeciderAt: 11,
};

function opp(i: PairIndex): PairIndex { return i === 0 ? 1 : 0; }
function inferStartRight(team: TeamConfig, cat?: 'MD' | 'WD' | 'XD' | 'CUSTOM'): PairIndex {
if (team.startRightIndex !== undefined) return team.startRightIndex;
if (cat === 'XD') {
const m = team.players.findIndex(p => p.gender === 'M');
if (m === 0 || m === 1) return m as PairIndex;
}
return 0;
}

export function createMatch(cfg: MatchConfig): MatchState {
const category = cfg.metadata?.category ?? 'CUSTOM';
const teams: [Required<TeamConfig>, Required<TeamConfig>] = [
{ players: cfg.teams[0].players, startRightIndex: inferStartRight(cfg.teams[0], category) },
{ players: cfg.teams[1].players, startRightIndex: inferStartRight(cfg.teams[1], category) },
];
const rules = { ...DEFAULT_RULES, ...(cfg.rules || {}) };
if (rules.bestOf % 2 === 0) throw new Error('bestOf must be odd (1/3/5)');

const srvTeam = cfg.startingServerTeam ?? 0;
const srvIdxSeed = cfg.startingServerPlayerIndex ?? teams[srvTeam].startRightIndex!;
if (srvIdxSeed !== teams[srvTeam].startRightIndex) teams[srvTeam].startRightIndex = srvIdxSeed;

// 初始右區人員
const posRight: [PairIndex, PairIndex] = [teams[0].startRightIndex!, teams[1].startRightIndex!];

// 開局時（0:0）皆在右發，serverPlayerIndex 依發球方目前「右區」者
const serverPlayerIndex = posRight[srvTeam];

return {
teams,
rules,
metadata: cfg.metadata,
currentGameIndex: 0,
games: [{ points: [0, 0] }],
servingTeam: srvTeam,
serverPlayerIndex,
posRight,
_version: 2,
};
}

export function getCurrentPoints(s: MatchState): [number, number] {
return s.games[s.currentGameIndex].points;
}

export function getNeedGamesToWin(s: MatchState): number {
return Math.floor(s.rules.bestOf / 2) + 1;
}

export function isGameOver(s: MatchState): boolean {
const [a, b] = getCurrentPoints(s);
const { pointsToWin, winBy, cap } = s.rules;
const mx = Math.max(a, b), mn = Math.min(a, b);
if (cap != null && mx >= cap) return true;
if (mx >= pointsToWin && (mx - mn) >= winBy) return true;
return false;
}

export function isMatchOver(s: MatchState): boolean {
const wonA = s.games.filter(g => g.winner === 0).length;
const wonB = s.games.filter(g => g.winner === 1).length;
return (wonA >= getNeedGamesToWin(s) || wonB >= getNeedGamesToWin(s));
}

export interface PlayerRef { team: TeamId; index: PairIndex; }
export interface RotationSnapshot {
score: [number, number];
servingTeam: TeamId;
server: PlayerRef & { court: Court };
receiver: PlayerRef & { court: Court };
teamPositions: [
{ right: PairIndex; left: PairIndex },
{ right: PairIndex; left: PairIndex },
];
}

/**

由當前 posRight 決定站位；server/receiver 由「發球者是否站右」判定。 */ export function getRotationSnapshot(s: MatchState): RotationSnapshot { const [a, b] = getCurrentPoints(s); const prA = s.posRight?.[0] ?? s.teams[0].startRightIndex!; const prB = s.posRight?.[1] ?? s.teams[1].startRightIndex!; const plA = opp(prA), plB = opp(prB);
const srvTeam = s.servingTeam;
const srvRightIdx = srvTeam === 0 ? prA : prB;
const serverCourt: Court = (s.serverPlayerIndex === srvRightIdx) ? 'R' : 'L';

const recTeam = (srvTeam === 0 ? 1 : 0) as TeamId;
const recRightIdx = recTeam === 0 ? prA : prB;
const receiverIndex = (serverCourt === 'R') ? recRightIdx : opp(recRightIdx);

return {
score: [a, b],
servingTeam: srvTeam,
server: { team: srvTeam, index: s.serverPlayerIndex, court: serverCourt },
receiver: { team: recTeam, index: receiverIndex, court: serverCourt },
teamPositions: [{ right: prA, left: plA }, { right: prB, left: plB }],
};
}

function markInterval(g: GameScore, pts: [number, number], rules: Required<RuleConfig>) {
if (g.intervalTaken || rules.technicalTimeoutAt == null) return;
const tt = rules.technicalTimeoutAt;
if (pts[0] >= tt || pts[1] >= tt) g.intervalTaken = true;
}
function markDeciderSwitch(g: GameScore, s: MatchState) {
if (g.deciderSidesSwitched) return;
const last = s.rules.bestOf - 1;
if (s.currentGameIndex !== last) return;
const at = s.rules.changeEndsInDeciderAt;
if (at == null) return;
const [a, b] = g.points;
if (a >= at || b >= at) g.deciderSidesSwitched = true;
}

/**

新規則：
連續得分：僅發球方換邊（posRight 互換），續發。
轉折（得→失或失→得）：兩邊都不換邊，改由對方發球。
發球區：
主場發球：看「得分」(pts[0]) 偶數右、奇數左。
客場發球：看「失分」= 客場得分 (pts[1]) 偶數右、奇數左。 */ export function nextRally(s: MatchState, rallyWinner: TeamId): MatchState { if (isMatchOver(s)) return s;
// 相容舊狀態：沒有 posRight 時初始化
if (!s.posRight) s.posRight = [s.teams[0].startRightIndex!, s.teams[1].startRightIndex!];

const g = s.games[s.currentGameIndex];
const pts = g.points.slice() as [number, number];

// 先加分
pts[rallyWinner] += 1;
g.points = pts;

if (rallyWinner === s.servingTeam) {
// 連續得分：發球方換邊，續發
s.posRight[rallyWinner] = opp(s.posRight[rallyWinner]);
// 發球區依規則 2/3
const court: Court = (rallyWinner === 0)
? (pts[0] % 2 === 0 ? 'R' : 'L') // 主場看得分
: (pts[1] % 2 === 0 ? 'R' : 'L'); // 客場看失分=客場得分
s.serverPlayerIndex = (court === 'R') ? s.posRight[rallyWinner] : opp(s.posRight[rallyWinner]);
} else {
// 轉折：不換邊；改由對方發
s.servingTeam = rallyWinner;
// 發球區依規則 2/3
const court: Court = (rallyWinner === 0)
? (pts[0] % 2 === 0 ? 'R' : 'L')
: (pts[1] % 2 === 0 ? 'R' : 'L');
s.serverPlayerIndex = (court === 'R') ? s.posRight[rallyWinner] : opp(s.posRight[rallyWinner]);
}

// 技術暫停 / 決勝局換邊旗標（僅作提示，不影響站位）
markInterval(g, pts, s.rules);
markDeciderSwitch(g, s);

if (isGameOver(s)) {
g.winner = (pts[0] > pts[1]) ? 0 : 1;

const wonA = s.games.filter(x => x.winner === 0).length;
const wonB = s.games.filter(x => x.winner === 1).length;

if (wonA < getNeedGamesToWin(s) && wonB < getNeedGamesToWin(s)) {
  // 新局：上一局勝方先發；站位復位到 startRightIndex
  const opening = g.winner!;
  s.currentGameIndex += 1;
  s.games.push({ points: [0, 0] });
  s.posRight = [s.teams[0].startRightIndex!, s.teams[1].startRightIndex!];
  s.servingTeam = opening;
  // 0:0 皆在右區發球
  s.serverPlayerIndex = s.posRight[opening];
}
}

s._version = (s._version ?? 0) + 1;
return s;
}

export function getUiSnapshot(s: MatchState) {
const rot = getRotationSnapshot(s);
const [a, b] = rot.score;
return {
scoreA: a, scoreB: b,
servingTeam: rot.servingTeam,
server: rot.server,
receiver: rot.receiver,
positions: { teamA: rot.teamPositions[0], teamB: rot.teamPositions[1] },
players: [
s.teams[0].players[0], s.teams[0].players[1],
s.teams[1].players[0], s.teams[1].players[1],
],
};
}

export function serialize(s: MatchState): string { return JSON.stringify(s); }
export function deserialize(json: string): MatchState {
const s = JSON.parse(json) as MatchState;
// 回溯：沒有 posRight 的舊狀態補上目前起始右區
if (!(s as any).posRight) {
(s as any).posRight = [s.teams[0].startRightIndex!, s.teams[1].startRightIndex!];
}
return s;
}

/* Validation: 檢查 UI 指定的 server/receiver 是否與當前應有對角一致 */
export interface ServeValidationResult {
ok: boolean;
expectedServer: { team: TeamId; index: PairIndex; court: Court };
expectedReceiver: { team: TeamId; index: PairIndex; court: Court };
errors: string[];
}

export function validateServeSelection(
s: MatchState,
chosen: { server?: { team: TeamId; index: PairIndex }, receiver?: { team: TeamId; index: PairIndex } }
): ServeValidationResult {
const snap = getRotationSnapshot(s);
const errors: string[] = [];
if (chosen.server && (chosen.server.team !== snap.server.team || chosen.server.index !== snap.server.index)) {
errors.push('WRONG_SERVER');
}
if (chosen.receiver && (chosen.receiver.team !== snap.receiver.team || chosen.receiver.index !== snap.receiver.index)) {
errors.push('WRONG_RECEIVER');
}
return {
ok: errors.length === 0,
expectedServer: snap.server,
expectedReceiver: snap.receiver,
errors,
};
}ezbmt-tracked/src/supabase/functions/invite-by-email/index.ts
 
// @ts-nocheck
/// <reference lib="deno.ns" />
/// <reference lib="dom" />

import { serve } from 'https://deno.land/std@0.224.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

type MemberRole = 'owner'|'coach'|'recorder'|'player'|'viewer'

serve(async (req: Request) => {
try {
// 用你在 Dashboard/CLI 設的 Secrets 名稱（不要用 SUPABASE_ 前綴）
const SUPABASE_URL = Deno.env.get('PROJECT_URL')
const ANON_KEY = Deno.env.get('ANON_KEY')
const SERVICE_KEY = Deno.env.get('SERVICE_ROLE_KEY')

if (!SUPABASE_URL || !ANON_KEY || !SERVICE_KEY) {
  return json({ error: 'Missing env: PROJECT_URL/ANON_KEY/SERVICE_ROLE_KEY' }, 500)
}

const body = await req.json().catch(() => ({}))
const { eventId, email, role } = body as { eventId?: string; email?: string; role?: MemberRole }
if (!eventId || !email || !role) return json({ error: 'missing params' }, 400)

// 需要使用者 JWT（前端 invoke 會自動帶 Authorization）
const authHeader = req.headers.get('Authorization') || ''
const jwt = authHeader.startsWith('Bearer ') ? authHeader.slice(7) : null
if (!jwt) return json({ error: 'unauthorized' }, 401)

// 用使用者身分檢查是否為該事件 owner/coach
const userClient = createClient(SUPABASE_URL, ANON_KEY, { global: { headers: { Authorization: `Bearer ${jwt}` }}})
const { data: me } = await userClient.auth.getUser()
const uid = me?.user?.id
if (!uid) return json({ error: 'unauthorized' }, 401)

const { data: can, error: roleErr } = await userClient
  .from('event_members')
  .select('role')
  .eq('event_id', eventId)
  .eq('user_id', uid)
  .maybeSingle()
if (roleErr) return json({ error: roleErr.message }, 500)
if (!can || !['owner','coach'].includes(String(can.role))) return json({ error: 'forbidden' }, 403)

// Admin client
const admin = createClient(SUPABASE_URL, SERVICE_KEY)

// 萬用：先邀請 -> 找現有 -> 建立
let targetId: string | null = null

// A) 邀請（未設 SMTP 可能失敗）
try {
  const { data: invited } = await admin.auth.admin.inviteUserByEmail(email)
  if (invited?.user?.id) targetId = invited.user.id
} catch {}

// B) 已註冊？listUsers 找 email
if (!targetId) {
  const { data: list, error: le } = await admin.auth.admin.listUsers({ page: 1, perPage: 1000 })
  if (le) return json({ error: le.message }, 500)
  const found = (list?.users || []).find((u: any) => String(u.email || '').toLowerCase() === String(email).toLowerCase())
  if (found) targetId = found.id
}

// C) 還沒有？createUser（不寄信）
if (!targetId) {
  const { data: created, error: ce } = await admin.auth.admin.createUser({ email, email_confirm: false })
  if (ce) return json({ error: ce.message }, 400)
  targetId = created.user?.id || null
}

if (!targetId) return json({ error: 'user not found' }, 404)

// upsert 事件成員
const { error: upErr } = await admin
  .from('event_members')
  .upsert({ event_id: eventId, user_id: targetId, role }, { onConflict: 'event_id,user_id' })
if (upErr) return json({ error: upErr.message }, 400)

return json({ ok: true, userId: targetId }, 200)
} catch (e) {
const msg = (e as any)?.message || String(e)
return json({ error: msg }, 500)
}
})

function json(obj: unknown, status = 200) {
return new Response(JSON.stringify(obj), { status, headers: { 'content-type': 'application/json' } })
}ezbmt-tracked/src/supabase/functions/sign-upload/index.ts
 
import { serve } from 'https://deno.land/std@0.224.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

serve(async (req) => {
try {
const url = Deno.env.get('SUPABASE_URL')!
const anonKey = Deno.env.get('SUPABASE_ANON_KEY')!

const body = await req.json().catch(()=>({}))
const { matchId, contentType, ext } = body as { matchId?: string; contentType?: string; ext?: string }
if (!matchId || !contentType || !ext) return new Response('missing params', { status: 400 })

const authHeader = req.headers.get('Authorization') || ''
const jwt = authHeader.startsWith('Bearer ') ? authHeader.slice(7) : null
if (!jwt) return new Response('unauthorized', { status: 401 })

const client = createClient(url, anonKey, { global: { headers: { Authorization: `Bearer ${jwt}` } } })

// 驗證：當前使用者需為事件成員且角色為 owner/coach/recorder 才能上傳
const { data: m, error: mErr } = await client.from('matches').select('event_id').eq('id', matchId).single()
if (mErr || !m?.event_id) return new Response('match not found', { status: 404 })
const { data: em, error: emErr } = await client
  .from('event_members').select('role').eq('event_id', m.event_id).eq('user_id', (await client.auth.getUser()).data.user?.id).single()
if (emErr || !em || !['owner','coach','recorder'].includes(String(em.role))) return new Response('forbidden', { status: 403 })

// 產生路徑與簽名上傳 URL
const path = `match/${matchId}/${Date.now()}-${Math.floor(Math.random()*1e7)}.${ext}`
const { data, error } = await client.storage.from('media').createSignedUploadUrl(path)
if (error) return new Response(error.message, { status: 400 })

return new Response(JSON.stringify({ path, signedUrl: data.signedUrl }), { status: 200, headers: { 'content-type':'application/json' } })
} catch (e) {
return new Response(String(e?.message || e), { status: 500 })
}
})
ezbmt-tracked/src/supabase/functions/send_notify/index.ts
 
import { serve } from 'https://deno.land/std@0.224.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

type Payload = {
kind: 'event'|'match';
targetId: string; // event_id or match_id
title: string;
body: string;
data?: Record<string,string>;
};

serve(async (req) => {
try {
const SUPABASE_URL = Deno.env.get('SUPABASE_URL')!;
const ANON_KEY = Deno.env.get('SUPABASE_ANON_KEY')!;
const FCM_KEY = Deno.env.get('FCM_SERVER_KEY')!;
const client = createClient(SUPABASE_URL, ANON_KEY, { global: { headers: { Authorization: req.headers.get('Authorization') || '' }}});

const payload = await req.json() as Payload;
if (!payload?.targetId) return new Response('bad request', { status: 400 });

// 查所有訂閱者的 token
const { data: subs, error: se } = await client
  .from('push_subscriptions')
  .select('user_id')
  .eq('kind', payload.kind).eq('target_id', payload.targetId);
if (se) throw se;
const uids = Array.from(new Set((subs||[]).map(s => s.user_id)));

if (!uids.length) return new Response(JSON.stringify({ sent:0 }), { status:200, headers: {'content-type':'application/json'} });

const { data: tokens, error: te } = await client
  .from('device_tokens')
  .select('token')
  .in('user_id', uids as any);
if (te) throw te;

const regs = Array.from(new Set((tokens||[]).map(t => t.token))).slice(0, 900); // FCM建議每次 < 1000
if (!regs.length) return new Response(JSON.stringify({ sent:0 }), { status:200, headers:{'content-type':'application/json'}});

// 發送（FCM HTTP v1/Legacy）
const res = await fetch('https://fcm.googleapis.com/fcm/send', {
  method:'POST',
  headers: { 'Content-Type':'application/json', 'Authorization': `key=${FCM_KEY}` },
  body: JSON.stringify({
    registration_ids: regs,
    notification: { title: payload.title, body: payload.body },
    data: payload.data || {},
    priority: 'high',
  }),
});
const txt = await res.text();
return new Response(txt, { status: 200, headers: {'content-type':'application/json'} });
} catch (e) {
return new Response(String(e?.message||e), { status: 500 });
}
});
ezbmt-tracked/src/screens/ClubsScreen.tsx
 
import React from 'react';
import { View, Text, FlatList, TextInput, Pressable, Alert } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { listClubs, createClub, getMyClubRoles } from '../db';

const C = { bg:'#111', card:'#222', text:'#fff', sub:'#bbb', border:'#333', primary:'#1976d2' };

export default function ClubsScreen() {
const nav = useNavigation<any>();
const [items, setItems] = React.useState<Array<{ id:string; name:string; description?:string|null }>>([]);
const [name, setName] = React.useState('');
const [desc, setDesc] = React.useState('');
const [roles, setRoles] = React.useState<Record<string,string>>({});

const load = React.useCallback(async () => {
try {
const rows = await listClubs();
setItems(rows);
const map = await getMyClubRoles((rows || []).map((r: { id: string }) => r.id));
setRoles(map);
} catch (e:any) { Alert.alert('載入失敗', String(e?.message||e)); }
}, []);
React.useEffect(()=>{ load(); }, [load]);

const add = async () => {
const nm = name.trim();
if (!nm) return;
try { await createClub({ name: nm, description: desc.trim()||undefined }); setName(''); setDesc(''); load(); }
catch(e:any){ Alert.alert('新增失敗', String(e?.message||e)); }
};

const renderItem = ({ item }: { item:{ id:string; name:string; description?:string|null } }) => {
const role = roles[item.id] || '';
return (
<Pressable
onPress={()=>nav.navigate('ClubDashboard', { clubId: item.id })}
style={{ padding:12, borderWidth:1, borderColor:C.border, backgroundColor:C.card, borderRadius:10, marginBottom:10 }}
>
<Text style={{ color:C.text, fontSize:16, fontWeight:'600' }}>{item.name}</Text>
{!!item.description && <Text style={{ color:C.sub, marginTop:4 }} numberOfLines={2}>{item.description}</Text>}
{!!role && <Text style={{ color:'#90caf9', marginTop:6 }}>我的角色：{role}</Text>}
<Text style={{ color:'#888', marginTop:4 }}>點擊進入社團主頁</Text>
</Pressable>
);
};

return (
<View style={{ flex:1, backgroundColor:C.bg, padding:12 }}>
<FlatList
data={items}
keyExtractor={i=>i.id}
renderItem={renderItem}
ListHeaderComponent={(
<View style={{ marginBottom:12 }}>
<Text style={{ color:C.text, fontSize:16, fontWeight:'700', marginBottom:8 }}>我的社團</Text>
<View style={{ borderWidth:1, borderColor:C.border, borderRadius:10, padding:10 }}>
<Text style={{ color:C.text, fontWeight:'600', marginBottom:6 }}>新增社團</Text>
<TextInput value={name} onChangeText={setName} placeholder="社團名稱" placeholderTextColor="#888"
style={{ borderWidth:1, borderColor:'#444', borderRadius:8, paddingHorizontal:10, paddingVertical:8, color:C.text, marginBottom:8 }} />
<TextInput value={desc} onChangeText={setDesc} placeholder="簡介（可空）" placeholderTextColor="#888"
style={{ borderWidth:1, borderColor:'#444', borderRadius:8, paddingHorizontal:10, paddingVertical:8, color:C.text, marginBottom:8 }} />
<Pressable onPress={add} style={{ backgroundColor:C.primary, borderRadius:8, paddingVertical:10, alignItems:'center' }}>
<Text style={{ color:'#fff' }}>建立</Text>
</Pressable>
</View>
</View>
)}
/>
</View>
);
}ezbmt-tracked/src/screens/EventMembersScreen.tsx
 
import React from 'react';
import {
View,
Text,
FlatList,
Pressable,
Alert,
TextInput,
KeyboardAvoidingView,
Platform,
} from 'react-native';
import { useRoute, useNavigation } from '@react-navigation/native';
import { useHeaderHeight } from '@react-navigation/elements';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import {
listEventMembers,
getMyEventRole,
upsertEventMember,
deleteEventMember,
getEventJoinCode,
setEventJoinCode,
inviteEventMemberByEmail,
setEventOwnerRPC,
} from '../db';
import { supa } from '../lib/supabase';

type MemberRole = 'owner'|'coach'|'recorder'|'player'|'viewer';

const ROLES: Array<{ key: MemberRole; label: string }> = [
{ key: 'owner',    label: '擁有者' },
{ key: 'coach',    label: '教練'   },
{ key: 'recorder', label: '記錄'   },
{ key: 'player',   label: '選手'   },
{ key: 'viewer',   label: '觀看'   },
];

const C = {
bg: '#111',
card: '#222',
border: '#333',
field: '#111',
fieldBorder: '#444',
text: '#fff',
sub: '#ddd',
hint: '#888',
chipOn: '#90caf9',
chipOff: '#555',
};

export default function EventMembersScreen() {
const route = useRoute<any>();
const navigation = useNavigation<any>();
const eventId: string | undefined = route.params?.eventId;

const headerHeight = useHeaderHeight();
const insets = useSafeAreaInsets();

const [mine, setMine] = React.useState<MemberRole | null>(null);
const [items, setItems] = React.useState<Array<{ id:string; user_id:string; role:MemberRole; name:string|null; email?: string|null }>>([]);
const [code, setCode] = React.useState<string>('');
const [editingCode, setEditingCode] = React.useState(false);
const [loading, setLoading] = React.useState(true);

// 邀請
const [inviteEmail, setInviteEmail] = React.useState('');
const [inviteRole, setInviteRole] = React.useState<MemberRole>('viewer');

// 曾邀請聯絡人（來自 invite_contacts）
const [contacts, setContacts] = React.useState<Array<{ email: string; last_role: MemberRole; total_count?: number; last_invited_at?: string }>>([]);
const [contactsOpen, setContactsOpen] = React.useState(false);
const [contactsLimit, setContactsLimit] = React.useState(12);

const canManage = mine === 'owner' || mine === 'coach';
const ownersCount = React.useMemo(() => items.filter(m => m.role === 'owner').length, [items]);

// eventId 缺失保護
if (!eventId) {
return (
<View style={{ flex:1, backgroundColor: C.bg, alignItems:'center', justifyContent:'center', padding:16 }}>
<Text style={{ color: C.text, fontSize: 16, marginBottom: 8 }}>未提供事件 ID，無法載入成員</Text>
<Pressable
onPress={() => navigation.goBack()}
style={{ paddingVertical:8, paddingHorizontal:12, backgroundColor:'#455a64', borderRadius:8 }}
>
<Text style={{ color:'#fff' }}>返回</Text>
</Pressable>
</View>
);
}

const loadContacts = React.useCallback(async () => {
try {
const { data, error } = await supa
.from('invite_contacts')
.select('email,last_role,total_count,last_invited_at')
.order('last_invited_at', { ascending: false })
.limit(100);
if (error) throw error;
setContacts((data || []) as any);
} catch {
setContacts([]);
}
}, []);

const load = React.useCallback(async () => {
setLoading(true);
try {
const [role, members, joinCode] = await Promise.all([
getMyEventRole(eventId),
listEventMembers(eventId),
getEventJoinCode(eventId),
]);
setMine(role);
setItems((members as any).map((m: any) => ({
id: m.id,
user_id: m.user_id,
role: m.role,
name: m.name ?? null,
email: m.email ?? null,
})));
setCode(joinCode || '');
await loadContacts();
} catch (e: any) {
Alert.alert('載入失敗', String(e?.message || e));
} finally {
setLoading(false);
}
}, [eventId, loadContacts]);

React.useEffect(() => { load(); }, [load]);

async function changeRole(memberId: string, userId: string, newRole: MemberRole) {
const isTargetOwner = items.find(m => m.id === memberId)?.role === 'owner';
if (isTargetOwner && newRole !== 'owner' && ownersCount <= 1) {
Alert.alert('無法變更', '事件至少需保留 1 位擁有者');
return;
}
try {
await upsertEventMember({ eventId, userId, role: newRole });
load();
} catch (e:any) { Alert.alert('變更失敗', String(e?.message || e)); }
}

async function removeMember(memberId: string) {
const target = items.find(m => m.id === memberId);
if (!target) return;
if (target.role === 'owner' && ownersCount <= 1) {
Alert.alert('無法移除', '事件至少需保留 1 位擁有者');
return;
}
try { await deleteEventMember(memberId); load(); }
catch (e:any) { Alert.alert('移除失敗', String(e?.message || e)); }
}

async function saveJoinCode() {
try { await setEventJoinCode(eventId, code.trim() || null); setEditingCode(false); Alert.alert('成功','加入代碼已更新'); }
catch (e:any) { Alert.alert('失敗', String(e?.message||e)); }
}
function genCode() {
const s = Math.random().toString(36).slice(2, 8).toUpperCase();
setCode(s); setEditingCode(true);
}

const renderItem = ({ item }: { item: { id:string; user_id:string; role:MemberRole; name:string|null; email?:string|null } }) => {
const displayName =
(item.name && item.name.trim()) ||
(item.email && item.email.trim()) ||
'未命名';
return (
<View style={{ padding:10, borderWidth:1, borderColor: C.border, backgroundColor: C.card, borderRadius:8, marginBottom:8 }}>
<Text style={{ fontWeight:'600', marginBottom:6, color: C.text }}>{displayName}</Text>
<View style={{ flexDirection:'row', flexWrap:'wrap', alignItems:'center' }}>
{ROLES.map(r => {
const selected = item.role === r.key;
const disabled = !canManage || (item.role === 'owner' && r.key !== 'owner' && ownersCount <= 1);
return (
<Pressable
key={r.key}
onPress={() => !disabled && changeRole(item.id, item.user_id, r.key)}
style={{
paddingVertical:6, paddingHorizontal:10, borderRadius:14,
borderWidth:1, borderColor: selected ? C.chipOn : C.chipOff,
backgroundColor: selected ? 'rgba(144,202,249,0.15)' : C.card,
marginRight:8, marginBottom:8, opacity: disabled ? 0.5 : 1
}}
>
<Text style={{ color: C.text }}>{r.label}</Text>
</Pressable>
);
})}

      {mine === 'owner' && item.role !== 'owner' && (
        <Pressable
          onPress={async()=>{
            try { await setEventOwnerRPC({ eventId, userId: item.user_id }); load(); }
            catch(e:any){ Alert.alert('失敗', String(e?.message || e)); }
          }}
          style={{ paddingVertical:6, paddingHorizontal:10, backgroundColor:'#0277bd', borderRadius:8, marginLeft:8 }}
        >
          <Text style={{ color:'#fff' }}>設為擁有者</Text>
        </Pressable>
      )}

      {canManage && (
        <Pressable
          onPress={() => removeMember(item.id)}
          style={{ paddingVertical:6, paddingHorizontal:10, backgroundColor:'#d32f2f', borderRadius:8, marginLeft:8 }}
        >
          <Text style={{ color:'#fff' }}>移除</Text>
        </Pressable>
      )}
    </View>
  </View>
);
};

const ListHeader = (
<View style={{ borderWidth:1, borderColor:C.border, backgroundColor:C.card, borderRadius:8, padding:10, marginBottom:10 }}>
<Text style={{ fontWeight:'600', marginBottom:6, color: C.text }}>加入代碼</Text>
{editingCode ? (
<View>
<TextInput
value={code}
onChangeText={setCode}
autoCapitalize="characters"
placeholder="如：AB12CD"
placeholderTextColor={C.hint}
style={{ borderWidth:1, borderColor:C.fieldBorder, borderRadius:8, paddingHorizontal:10, paddingVertical:8, marginBottom:8, color: C.text, backgroundColor: C.field }}
/>
<View style={{ flexDirection:'row' }}>
<Pressable onPress={saveJoinCode} style={{ paddingVertical:8, paddingHorizontal:12, backgroundColor:'#1976d2', borderRadius:8, marginRight:8 }}>
<Text style={{ color:'#fff' }}>儲存</Text>
</Pressable>
<Pressable onPress={()=>{ setEditingCode(false); load(); }} style={{ paddingVertical:8, paddingHorizontal:12 }}>
<Text style={{ color: C.text }}>取消</Text>
</Pressable>
</View>
</View>
) : (
<View style={{ flexDirection:'row', alignItems:'center', flexWrap:'wrap' }}>
<Text style={{ fontSize:16, marginRight:8, color: C.text }}>{code || '未設定'}</Text>
{(mine === 'owner' || mine === 'coach') && (
<>
<Pressable onPress={()=>setEditingCode(true)} style={{ paddingVertical:6, paddingHorizontal:10, backgroundColor:'#455a64', borderRadius:8, marginRight:8 }}>
<Text style={{ color:'#fff' }}>編輯</Text>
</Pressable>
<Pressable onPress={genCode} style={{ paddingVertical:6, paddingHorizontal:10, backgroundColor:'#00897b', borderRadius:8 }}>
<Text style={{ color:'#fff' }}>重新產生</Text>
</Pressable>
</>
)}
</View>
)}
</View>
);

const ListFooter = (
<View style={{ borderTopWidth:1, borderColor:C.border, paddingTop:10, marginTop:10, paddingBottom: (insets.bottom || 12) + 12 }}>
<Text style={{ fontWeight:'600', marginBottom:6, color: C.text }}>邀請成員（Email）</Text>

  {/* 曾邀請過（可收合） */}
  {contacts && contacts.length > 0 && (
    <View style={{ marginBottom: 8, borderWidth:1, borderColor:C.border, backgroundColor:C.card, borderRadius:8, paddingHorizontal:10, paddingTop:8 }}>
      <Pressable
        onPress={() => setContactsOpen(o => !o)}
        style={{ flexDirection:'row', alignItems:'center', justifyContent:'space-between', paddingVertical:6 }}
      >
        <Text style={{ color: C.sub, fontWeight:'600' }}>
          曾邀請過（{contacts.length}）
        </Text>
        <Text style={{ color:'#90caf9' }}>{contactsOpen ? '收起' : '展開'}</Text>
      </Pressable>

      {contactsOpen && (
        <>
          <View style={{ flexDirection:'row', flexWrap:'wrap', marginTop:4 }}>
            {contacts.slice(0, contactsLimit).map((c) => (
              <Pressable
                key={c.email}
                onPress={() => { setInviteEmail(c.email); setInviteRole(c.last_role); }}
                style={{
                  paddingVertical:6, paddingHorizontal:10, borderRadius:14,
                  borderWidth:1, borderColor:'#555',
                  backgroundColor: '#1f1f1f',
                  marginRight:8, marginBottom:8
                }}
              >
                <Text style={{ color:'#fff' }}>
                  {c.email} {c.last_role ? `· ${c.last_role}` : ''}
                </Text>
              </Pressable>
            ))}
          </View>
          {/* 顯示全部 / 收斂 */}
          {contacts.length > contactsLimit ? (
            <Pressable
              onPress={() => setContactsLimit(contacts.length)}
              style={{ alignSelf:'flex-end', paddingVertical:6, paddingHorizontal:8 }}
            >
              <Text style={{ color:'#90caf9' }}>顯示全部</Text>
            </Pressable>
          ) : contacts.length > 12 ? (
            <Pressable
              onPress={() => setContactsLimit(12)}
              style={{ alignSelf:'flex-end', paddingVertical:6, paddingHorizontal:8 }}
            >
              <Text style={{ color:'#90caf9' }}>只顯示 12 筆</Text>
            </Pressable>
          ) : null}
        </>
      )}
    </View>
  )}

  <TextInput
    value={inviteEmail}
    onChangeText={setInviteEmail}
    placeholder="example@mail.com"
    placeholderTextColor={C.hint}
    autoCapitalize="none"
    keyboardType="email-address"
    style={{ borderWidth:1, borderColor:C.fieldBorder, borderRadius:8, paddingHorizontal:10, paddingVertical:8, marginBottom:8, color: C.text, backgroundColor: C.field }}
  />
  <View style={{ flexDirection:'row', flexWrap:'wrap', marginBottom:8 }}>
    {(['viewer','recorder','coach','player','owner'] as const).map(r => (
      <Pressable
        key={r}
        onPress={()=>setInviteRole(r)}
        style={{ paddingVertical:6, paddingHorizontal:10, borderRadius:14, borderWidth:1, borderColor: inviteRole===r? C.chipOn:'#555', backgroundColor: inviteRole===r?'rgba(144,202,249,0.15)':C.card, marginRight:8, marginBottom:8 }}
      >
        <Text style={{ color: C.text }}>{r}</Text>
      </Pressable>
    ))}
  </View>
  <Pressable
    onPress={async()=>{
      try {
        await inviteEventMemberByEmail({ eventId, email: inviteEmail.trim(), role: inviteRole });
        Alert.alert('成功','邀請已送出');
        setInviteEmail('');
        // 刷新歷史聯絡人
        try { await loadContacts(); } catch {}
        // 重新載入成員
        try { await load(); } catch {}
      } catch(e:any){ Alert.alert('失敗', String(e?.message || e)); }
    }}
    style={{ backgroundColor:'#1976d2', paddingVertical:10, borderRadius:8, alignItems:'center' }}
  >
    <Text style={{ color:'#fff' }}>送出邀請</Text>
  </Pressable>
</View>
);

return (
<KeyboardAvoidingView
style={{ flex:1, backgroundColor: C.bg }}
behavior={Platform.OS === 'ios' ? 'padding' : undefined}
keyboardVerticalOffset={headerHeight}
>
<FlatList
data={items}
keyExtractor={(i)=>i.id}
renderItem={renderItem}
ListHeaderComponent={ListHeader}
ListFooterComponent={ListFooter}
contentContainerStyle={{ padding:12 }}
keyboardShouldPersistTaps="handled"
/>
</KeyboardAvoidingView>
);
}ezbmt-tracked/src/screens/AdminModerationScreen.tsx
 
import React from 'react';
import {
  View,
  Text,
  Pressable,
  TextInput,
  FlatList,
  Alert,
  ActivityIndicator,
  Image,
  Linking,
  Modal,
  ScrollView,
  Platform,
  PermissionsAndroid,
} from 'react-native';
import { supa } from '../lib/supabase';
import { publicUrlToPath, removeFile } from '../lib/storage';

const C = {
  bg: '#111',
  card: '#1e1e1e',
  border: '#333',
  text: '#fff',
  sub: '#bbb',
  btn: '#1976d2',
  warn: '#d32f2f',
  chip: '#90caf9',
};

type ChatRow = { id: string; user?: string | null; text: string; created_at: string; match_id?: string };
type ClubChatRow = { id: string; user?: string | null; text: string; created_at: string; club_id?: string };
type MediaRow = {
  id: string;
  owner_type: 'event' | 'match' | 'club' | string;
  owner_id: string;
  kind: 'youtube' | 'photo' | string;
  url: string;
  description?: string | null;
  created_at: string;
};

type ActiveUser = {
  id: string;
  name?: string | null;
  email?: string | null;
  updated_at: string;
  lat?: number | null;
  lng?: number | null;
};

function getYouTubeId(url: string): string | null {
  try {
    const u = new URL(url);
    const host = u.hostname.toLowerCase();
    if (host.includes('youtu.be')) {
      const path = u.pathname.replace(/^\/+/, '');
      return path || null;
    }
    if (host.includes('youtube.com')) {
      const v = u.searchParams.get('v');
      if (v) return v;
      const m = u.pathname.match(/\/(embed|shorts)\/([A-Za-z0-9_-]{6,})/);
      if (m && m[2]) return m[2];
    }
  } catch {}
  return null;
}

function minutesAgo(mins: number): string {
  const d = new Date(Date.now() - mins * 60 * 1000);
  return d.toISOString();
}

export default function AdminModerationScreen() {
  const [admin, setAdmin] = React.useState<boolean | null>(null);
  const [tab, setTab] = React.useState<'chat' | 'club_chat' | 'media'>('chat');

  const [q, setQ] = React.useState('');
  const [loading, setLoading] = React.useState(true);

  const [chats, setChats] = React.useState<ChatRow[]>([]);
  const [clubChats, setClubChats] = React.useState<ClubChatRow[]>([]);
  const [media, setMedia] = React.useState<MediaRow[]>([]);

  // 使用中使用者（Sheet）
  const [activeSheetOpen, setActiveSheetOpen] = React.useState(false);
  const [activeTab, setActiveTab] = React.useState<'list' | 'map'>('list'); // Sheet 內的分頁
  const [loadingActive, setLoadingActive] = React.useState(false);
  const [activeUsers, setActiveUsers] = React.useState<ActiveUser[]>([]);
  const [activePage, setActivePage] = React.useState(1);
  const PAGE_SIZE = 50;

  // 地圖載入（可選，未安裝會 fallback）
  let MapView: any = null;
  try {
    MapView = require('react-native-maps').default;
  } catch {
    MapView = null;
  }
  const [myLoc, setMyLoc] = React.useState<{ lat: number; lng: number } | null>(null);

  React.useEffect(() => {
    let active = true;
    (async () => {
      try {
        const { data, error } = await supa.rpc('is_app_admin');
        if (!active) return;
        setAdmin(!error && !!data);
      } catch {
        if (!active) setAdmin(false);
      } finally {
        setLoading(false);
      }
    })();
    return () => {
      active = false;
    };
  }, []);

  const loadChats = React.useCallback(async () => {
    const { data, error } = await supa
      .from('chat_messages')
      .select('id,match_id,user_name,text,created_at')
      .order('created_at', { ascending: false })
      .limit(300);
    if (error) throw error;
    setChats(
      (data || []).map((r: any) => ({
        id: r.id,
        user: r.user_name || null,
        text: r.text || '',
        created_at: r.created_at || new Date().toISOString(),
        match_id: r.match_id || undefined,
      })),
    );
  }, []);

  const loadClubChats = React.useCallback(async () => {
    const { data, error } = await supa
      .from('club_chats')
      .select('id,club_id,user_name,text,created_at')
      .order('created_at', { ascending: false })
      .limit(300);
    if (error) throw error;
    setClubChats(
      (data || []).map((r: any) => ({
        id: r.id,
        user: r.user_name || null,
        text: r.text || '',
        created_at: r.created_at || new Date().toISOString(),
        club_id: r.club_id || undefined,
      })),
    );
  }, []);

  const loadMedia = React.useCallback(async () => {
    const { data, error } = await supa
      .from('media')
      .select('id,owner_type,owner_id,kind,url,description,created_at')
      .order('created_at', { ascending: false })
      .limit(300);
    if (error) throw error;
    setMedia((data || []) as any);
  }, []);

  // 撈 presence 10 分鐘內活躍（帶回 name/email）
  const loadActive = React.useCallback(async () => {
    setLoadingActive(true);
    setActivePage(1);
    try {
      const since = minutesAgo(10);
      const { data, error } = await supa
        .from('user_presence')
        .select('user_id,last_seen_at,lat,lng')
        .gte('last_seen_at', since)
        .order('last_seen_at', { ascending: false })
        .limit(500);
      if (error) throw error;

      const uids = Array.from(new Set((data || []).map((r: any) => String(r.user_id))));
      let meta: Record<string, { name?: string | null; email?: string | null }> = {};
      if (uids.length) {
        const { data: prof } = await supa.from('profiles').select('id,name,email').in('id', uids as any);
        (prof || []).forEach((p: any) => {
          meta[p.id] = {
            name: p?.name || null,
            email: p?.email || null,
          };
        });
      }
      const rows: ActiveUser[] = (data || []).map((r: any) => {
        const m = meta[String(r.user_id)] || {};
        return {
          id: String(r.user_id),
          name: m.name || null,
          email: m.email || null,
          updated_at: String(r.last_seen_at || new Date().toISOString()),
          lat: typeof r.lat === 'number' ? r.lat : null,
          lng: typeof r.lng === 'number' ? r.lng : null,
        };
      });
      setActiveUsers(rows);
    } catch {
      setActiveUsers([]);
    } finally {
      setLoadingActive(false);
    }
  }, []);

  // 取管理者目前位置（用於地圖中心）
  const getMyLocation = React.useCallback(async () => {
    try {
      if (Platform.OS === 'android') {
        try {
          const ok = await PermissionsAndroid.request(PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION);
          if (ok !== PermissionsAndroid.RESULTS.GRANTED) return;
        } catch {}
      }
      const geo = (navigator as any)?.geolocation;
      if (!geo || typeof geo.getCurrentPosition !== 'function') return;
      await new Promise<void>((resolve) => {
        geo.getCurrentPosition(
          (pos: any) => {
            const c = pos?.coords || {};
            if (typeof c.latitude === 'number' && typeof c.longitude === 'number') {
              setMyLoc({ lat: c.latitude, lng: c.longitude });
            }
            resolve();
          },
          () => resolve(),
          { enableHighAccuracy: true, maximumAge: 3000, timeout: 4000 },
        );
      });
    } catch {}
  }, []);

  const reloadAll = React.useCallback(async () => {
    try {
      setLoading(true);
      await Promise.all([loadChats(), loadClubChats(), loadMedia(), loadActive()]);
    } catch (e: any) {
      Alert.alert('載入失敗', String(e?.message || e));
    } finally {
      setLoading(false);
    }
  }, [loadChats, loadClubChats, loadMedia, loadActive]);

  React.useEffect(() => {
    if (admin) reloadAll();
  }, [admin, reloadAll]);

  const confirm = (msg: string, fn: () => void) => {
    Alert.alert('確認', msg, [
      { text: '取消', style: 'cancel' },
      { text: '確定', style: 'destructive', onPress: fn },
    ]);
  };

  const delChat = async (id: string) => {
    try {
      await supa.from('chat_messages').delete().eq('id', id);
      await loadChats();
    } catch (e: any) {
      Alert.alert('刪除失敗', String(e?.message || e));
    }
  };
  const delClubChat = async (id: string) => {
    try {
      await supa.from('club_chats').delete().eq('id', id);
      await loadClubChats();
    } catch (e: any) {
      Alert.alert('刪除失敗', String(e?.message || e));
    }
  };
  const delMedia = async (row: MediaRow) => {
    try {
      if (row.kind === 'photo') {
        const path = publicUrlToPath(row.url);
        if (path) {
          try {
            await removeFile(path);
          } catch {}
        }
      }
      await supa.from('media').delete().eq('id', row.id);
      await loadMedia();
    } catch (e: any) {
      Alert.alert('刪除失敗', String(e?.message || e));
    }
  };

  const kw = q.trim().toLowerCase();
  const fChats = chats.filter(
    (r) =>
      !kw ||
      (r.text || '').toLowerCase().includes(kw) ||
      (r.user || '').toLowerCase().includes(kw) ||
      (r.match_id || '').toLowerCase().includes(kw),
  );
  const fClubChats = clubChats.filter(
    (r) =>
      !kw ||
      (r.text || '').toLowerCase().includes(kw) ||
      (r.user || '').toLowerCase().includes(kw) ||
      (r.club_id || '').toLowerCase().includes(kw),
  );
  const fMedia = media.filter(
    (r) =>
      !kw ||
      (r.url || '').toLowerCase().includes(kw) ||
      (r.description || '').toLowerCase().includes(kw) ||
      (r.owner_id || '').toLowerCase().includes(kw) ||
      (r.owner_type || '').toLowerCase().includes(kw),
  );

  if (admin === null || loading) {
    return (
      <View style={{ flex: 1, backgroundColor: C.bg, alignItems: 'center', justifyContent: 'center' }}>
        <ActivityIndicator color="#90caf9" />
      </View>
    );
  }
  if (!admin) {
    return (
      <View style={{ flex: 1, backgroundColor: C.bg, alignItems: 'center', justifyContent: 'center', padding: 16 }}>
        <Text style={{ color: '#fff' }}>沒有權限</Text>
      </View>
    );
  }

  const Chip = ({ text, active, onPress }: { text: string; active?: boolean; onPress: () => void }) => (
    <Pressable
      onPress={onPress}
      style={{
        paddingVertical: 6,
        paddingHorizontal: 10,
        borderRadius: 14,
        borderWidth: 1,
        borderColor: active ? C.chip : '#555',
        backgroundColor: active ? 'rgba(144,202,249,0.15)' : C.card,
        marginRight: 8,
        marginBottom: 8,
      }}
    >
      <Text style={{ color: '#fff' }}>{text}</Text>
    </Pressable>
  );

  const Section = ({ children }: any) => (
    <View style={{ marginTop: 10, backgroundColor: C.card, borderWidth: 1, borderColor: C.border, borderRadius: 10, padding: 10 }}>
      {children}
    </View>
  );

  const Row = ({ left, right }: { left: any; right?: any }) => (
    <View
      style={{
        borderBottomWidth: 1,
        borderColor: '#2b2b2b',
        paddingVertical: 8,
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
      }}
    >
      <View style={{ flex: 1, paddingRight: 8 }}>{left}</View>
      {right}
    </View>
  );

  const renderChat = ({ item }: { item: ChatRow }) => (
    <Row
      left={
        <View>
          <Text style={{ color: '#90caf9' }}>{item.user || '匿名'} · Match {item.match_id || '-'}</Text>
          <Text style={{ color: '#ccc', marginTop: 2 }}>{new Date(item.created_at).toLocaleString()}</Text>
          <Text style={{ color: '#fff', marginTop: 6 }}>{item.text}</Text>
        </View>
      }
      right={
        <Pressable
          onPress={() => confirm('刪除此訊息？', () => delChat(item.id))}
          style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: C.warn, borderRadius: 8 }}
        >
          <Text style={{ color: '#fff' }}>刪除</Text>
        </Pressable>
      }
    />
  );

  const renderClubChat = ({ item }: { item: ClubChatRow }) => (
    <Row
      left={
        <View>
          <Text style={{ color: '#90caf9' }}>{item.user || '匿名'} · Club {item.club_id || '-'}</Text>
          <Text style={{ color: '#ccc', marginTop: 2 }}>{new Date(item.created_at).toLocaleString()}</Text>
          <Text style={{ color: '#fff', marginTop: 6 }}>{item.text}</Text>
        </View>
      }
      right={
        <Pressable
          onPress={() => confirm('刪除此訊息？', () => delClubChat(item.id))}
          style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: C.warn, borderRadius: 8 }}
        >
          <Text style={{ color: '#fff' }}>刪除</Text>
        </Pressable>
      }
    />
  );

  const renderMedia = ({ item }: { item: MediaRow }) => {
    const isYouTube = item.kind === 'youtube';
    const ytId = isYouTube ? getYouTubeId(item.url) : null;
    const thumb = ytId ? `https://img.youtube.com/vi/${ytId}/hqdefault.jpg` : null;

    return (
      <Row
        left={
          <View>
            <Text style={{ color: '#90caf9' }}>
              {item.owner_type}/{item.owner_id}
            </Text>
            <Text style={{ color: '#ccc', marginTop: 2 }}>{new Date(item.created_at).toLocaleString()}</Text>
            <Text style={{ color: '#fff', marginTop: 6 }}>
              {isYouTube ? 'YouTube' : '照片'} · {item.url}
            </Text>
            {!!item.description && <Text style={{ color: '#ddd', marginTop: 4 }}>{item.description}</Text>}

            {/* 預覽：YouTube 顯示縮圖；照片顯示實圖 */}
            {isYouTube && thumb ? (
              <Pressable
                onPress={() => {
                  try {
                    Linking.openURL(item.url);
                  } catch {}
                }}
                style={{ marginTop: 8, borderRadius: 8, overflow: 'hidden', backgroundColor: '#000', width: 220 }}
              >
                <Image source={{ uri: thumb }} style={{ width: 220, height: 124 }} resizeMode="cover" />
              </Pressable>
            ) : (
              !isYouTube && (
                <View style={{ marginTop: 8 }}>
                  <Image
                    source={{ uri: item.url }}
                    style={{ width: 220, height: 140, borderRadius: 8, backgroundColor: '#333' }}
                    resizeMode="cover"
                  />
                </View>
              )
            )}
          </View>
        }
        right={
          <Pressable
            onPress={() => confirm('刪除此媒體？（照片將同時刪除雲端檔案）', () => delMedia(item))}
            style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: C.warn, borderRadius: 8 }}
          >
            <Text style={{ color: '#fff' }}>刪除</Text>
          </Pressable>
        }
      />
    );
  };

  // presence 分頁
  const totalPages = Math.max(1, Math.ceil(activeUsers.length / PAGE_SIZE));
  const page = Math.min(Math.max(1, activePage), totalPages);
  const startIdx = (page - 1) * PAGE_SIZE;
  const pageRows = activeUsers.slice(startIdx, startIdx + PAGE_SIZE);

  const PageBtn = ({ title, onPress, disabled }: { title: string; onPress: () => void; disabled?: boolean }) => (
    <Pressable
      onPress={onPress}
      disabled={disabled}
      style={{
        paddingVertical: 8,
        paddingHorizontal: 12,
        backgroundColor: disabled ? '#555' : C.btn,
        borderRadius: 8,
        marginLeft: 6,
      }}
    >
      <Text style={{ color: '#fff' }}>{title}</Text>
    </Pressable>
  );

  // 地圖 region
  const computeRegion = () => {
    const coords = activeUsers
      .filter((u) => typeof u.lat === 'number' && typeof u.lng === 'number')
      .map((u) => ({ latitude: u.lat as number, longitude: u.lng as number }));
    if (myLoc) coords.push({ latitude: myLoc.lat, longitude: myLoc.lng });
    if (!coords.length) {
      return {
        latitude: 25.034, // 台北101 附近
        longitude: 121.5645,
        latitudeDelta: 0.2,
        longitudeDelta: 0.2,
      };
    }
    // 簡單計算中心
    const lat = coords.reduce((a, c) => a + c.latitude, 0) / coords.length;
    const lng = coords.reduce((a, c) => a + c.longitude, 0) / coords.length;
    return {
      latitude: lat,
      longitude: lng,
      latitudeDelta: 0.2,
      longitudeDelta: 0.2,
    };
  };

  return (
    <View style={{ flex: 1, backgroundColor: C.bg, padding: 12 }}>
      <Text style={{ color: C.text, fontSize: 16, fontWeight: '800', marginBottom: 10 }}>社群管理（最大管理者）</Text>

      <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 8, flexWrap: 'wrap' }}>
        <Chip text="賽事聊天室" active={tab === 'chat'} onPress={() => setTab('chat')} />
        <Chip text="社團聊天室" active={tab === 'club_chat'} onPress={() => setTab('club_chat')} />
        <Chip text="媒體" active={tab === 'media'} onPress={() => setTab('media')} />

        {/* 使用中使用者（開啟 Sheet） */}
        <Pressable
          onPress={() => {
            setActiveSheetOpen(true);
            setActiveTab('list');
            if (activeUsers.length === 0) loadActive().catch(() => {});
          }}
          style={{
            paddingVertical: 8,
            paddingHorizontal: 12,
            backgroundColor: '#6d4c41',
            borderRadius: 8,
            marginLeft: 8,
          }}
        >
          <Text style={{ color: '#fff' }}>On Line</Text>
        </Pressable>

        <Pressable
          onPress={reloadAll}
          style={{
            paddingVertical: 8,
            paddingHorizontal: 12,
            backgroundColor: C.btn,
            borderRadius: 8,
            marginLeft: 'auto',
          }}
        >
          <Text style={{ color: '#fff' }}>重整</Text>
        </Pressable>
      </View>

      <TextInput
        value={q}
        onChangeText={setQ}
        placeholder="搜尋（內容/使用者/擁有者ID/連結）"
        placeholderTextColor="#888"
        style={{
          borderWidth: 1,
          borderColor: '#444',
          borderRadius: 8,
          paddingHorizontal: 10,
          paddingVertical: 8,
          color: '#fff',
          backgroundColor: '#111',
          marginBottom: 8,
        }}
      />

      {tab === 'chat' && (
        <Section>
          {loading ? (
            <View style={{ padding: 16, alignItems: 'center' }}>
              <ActivityIndicator color="#90caf9" />
            </View>
          ) : (
            <FlatList data={fChats} keyExtractor={(i) => i.id} renderItem={renderChat} />
          )}
        </Section>
      )}

      {tab === 'club_chat' && (
        <Section>
          {loading ? (
            <View style={{ padding: 16, alignItems: 'center' }}>
              <ActivityIndicator color="#90caf9" />
            </View>
          ) : (
            <FlatList data={fClubChats} keyExtractor={(i) => i.id} renderItem={renderClubChat} />
          )}
        </Section>
      )}

      {tab === 'media' && (
        <Section>
          {loading ? (
            <View style={{ padding: 16, alignItems: 'center' }}>
              <ActivityIndicator color="#90caf9" />
            </View>
          ) : (
            <FlatList data={fMedia} keyExtractor={(i) => i.id} renderItem={renderMedia} />
          )}
        </Section>
      )}

      {/* 使用中使用者 Sheet（列表 / 地圖） */}
      <Modal
        visible={activeSheetOpen}
        transparent
        animationType="slide"
        onRequestClose={() => setActiveSheetOpen(false)}
      >
        <View style={{ flex: 1, backgroundColor: 'rgba(0,0,0,0.35)', justifyContent: 'flex-end' }}>
          <View
            style={{
              backgroundColor: '#1e1e1e',
              borderTopLeftRadius: 16,
              borderTopRightRadius: 16,
              padding: 12,
              maxHeight: '80%',
            }}
          >
            {/* Sheet Header */}
            <View style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between' }}>
              <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                <Chip text="列表" active={activeTab === 'list'} onPress={() => setActiveTab('list')} />
                <Chip
                  text="地圖"
                  active={activeTab === 'map'}
                  onPress={async () => {
                    setActiveTab('map');
                    if (!myLoc) await getMyLocation();
                  }}
                />
              </View>
              <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                <Pressable
                  onPress={() => loadActive()}
                  style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: C.btn, borderRadius: 8, marginRight: 8 }}
                >
                  <Text style={{ color: '#fff' }}>{loadingActive ? '更新中…' : '重新整理'}</Text>
                </Pressable>
                <Pressable onPress={() => setActiveSheetOpen(false)} style={{ paddingVertical: 6, paddingHorizontal: 10 }}>
                  <Text style={{ color: '#90caf9' }}>關閉</Text>
                </Pressable>
              </View>
            </View>

            {/* Body */}
            {activeTab === 'list' ? (
              <>
                {loadingActive ? (
                  <View style={{ paddingVertical: 20, alignItems: 'center' }}>
                    <ActivityIndicator color="#90caf9" />
                  </View>
                ) : activeUsers.length === 0 ? (
                  <Text style={{ color: '#ccc', marginTop: 8 }}>目前沒有活躍中的使用者。</Text>
                ) : (
                  <>
                    <ScrollView style={{ maxHeight: '70%' }} contentContainerStyle={{ paddingBottom: 10 }}>
                      {pageRows.map((u) => {
                        const main = (u.name && u.name.trim()) || (u.email && u.email.trim()) || (u.id.slice(0, 8) + '…');
                        return (
                          <View
                            key={u.id}
                            style={{
                              paddingVertical: 8,
                              borderBottomWidth: 1,
                              borderColor: '#2b2b2b',
                            }}
                          >
                            <Text style={{ color: '#fff', fontWeight: '600' }}>{main}</Text>
                            {!!u.email && <Text style={{ color: '#bbb', marginTop: 2 }}>{u.email}</Text>}
                            <Text style={{ color: '#888', marginTop: 2 }}>
                              最近活躍：{new Date(u.updated_at).toLocaleString()}
                            </Text>
                            <Text style={{ color: '#555', marginTop: 2 }}>ID: {u.id}</Text>
                            {typeof u.lat === 'number' && typeof u.lng === 'number' && (
                              <Text style={{ color: '#888', marginTop: 2 }}>
                                位置：{u.lat.toFixed(5)}, {u.lng.toFixed(5)}
                              </Text>
                            )}
                          </View>
                        );
                      })}
                    </ScrollView>

                    {/* 分頁控制 */}
                    <View style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'flex-end', marginTop: 8 }}>
                      <Text style={{ color: '#bbb', marginRight: 8 }}>
                        第 {page} / {totalPages} 頁（每頁 {PAGE_SIZE} 人）
                      </Text>
                      <PageBtn title="上一頁" onPress={() => setActivePage((p) => Math.max(1, p - 1))} disabled={page <= 1} />
                      <PageBtn
                        title="下一頁"
                        onPress={() => setActivePage((p) => Math.min(totalPages, p + 1))}
                        disabled={page >= totalPages}
                      />
                    </View>
                  </>
                )}
              </>
            ) : (
              // 地圖頁籤
              <View style={{ height: 360, marginTop: 8 }}>
                {!MapView ? (
                  <Text style={{ color: '#ccc' }}>
                    尚未安裝 react-native-maps，無法顯示地圖。請先安裝套件後再試。
                  </Text>
                ) : loadingActive ? (
                  <View style={{ paddingVertical: 20, alignItems: 'center' }}>
                    <ActivityIndicator color="#90caf9" />
                  </View>
                ) : (
                  <MapView style={{ flex: 1, borderRadius: 10 }} initialRegion={computeRegion()} showsUserLocation={true} followsUserLocation={true}>
                    {/* 我的位置（藍點由 showsUserLocation 顯示） */}
                    {activeUsers
                      .filter((u) => typeof u.lat === 'number' && typeof u.lng === 'number')
                      .map((u) => {
                        const main = (u.name && u.name.trim()) || (u.email && u.email.trim()) || (u.id.slice(0, 8) + '…');
                        return (
                          <MapView.Marker
                            key={u.id}
                            coordinate={{ latitude: u.lat as number, longitude: u.lng as number }}
                            title={main}
                            description={`最近活躍：${new Date(u.updated_at).toLocaleString()}`}
                          />
                        );
                      })}
                  </MapView>
                )}
              </View>
            )}
          </View>
        </View>
      </Modal>
    </View>
  );
}ezbmt-tracked/src/screens/SessionCheckInScreen.tsx
 
import React from 'react';
import { View, Text, FlatList, TextInput, Pressable, Alert } from 'react-native';
import { useRoute } from '@react-navigation/native';
import { listBuddies, listSessionAttendees, upsertSessionAttendee, removeSessionAttendee } from '../db';

const C = { bg:'#111', card:'#222', text:'#fff', sub:'#bbb', border:'#333', primary:'#1976d2', warn:'#d32f2f' };

export default function SessionCheckInScreen() {
const route = useRoute<any>();
const clubId = route.params?.clubId as string;
const sessionId = route.params?.sessionId as string;

const [buddies, setBuddies] = React.useState<Array<{ id:string; name:string; level:number }>>([]);
const [attendees, setAttendees] = React.useState<Array<{ id:string; buddy_id:string; display_name:string }>>([]);
const [search, setSearch] = React.useState('');

const load = React.useCallback(async ()=>{
try {
const [bs, as] = await Promise.all([listBuddies(clubId), listSessionAttendees(sessionId)]);
setBuddies(bs);

  const list = (as || []).map((r:any)=> ({
    id: String(r.id),
    buddy_id: String(r.buddy_id || ''),
    display_name: String(r.display_name || r.name || ''),
  }));
  setAttendees(list);
} catch(e:any){ Alert.alert('載入失敗', String(e?.message||e)); }
}, [clubId, sessionId]);

React.useEffect(()=>{ load(); }, [load]);

const add = async (buddyId:string)=>{
try {
// 不要傳 checked_in；你的表沒有此欄，因此只傳必要欄位
await upsertSessionAttendee({ session_id: sessionId, buddy_id: buddyId } as any);
load();
} catch(e:any){ Alert.alert('加入失敗', String(e?.message||e)); }
};

const remove = async (attId:string)=>{
try { await removeSessionAttendee(attId); load(); }
catch(e:any){ Alert.alert('移除失敗', String(e?.message||e)); }
};

const picked = new Set(attendees.map(a=>a.buddy_id));
const filtered = buddies.filter(b=> !picked.has(b.id) && (search.trim()? b.name.toLowerCase().includes(search.trim().toLowerCase()) : true));

const AttRow = ({ item }: any) => (
<View style={{ padding:10, borderWidth:1, borderColor:C.border, backgroundColor:C.card, borderRadius:8, marginBottom:8, flexDirection:'row', justifyContent:'space-between', alignItems:'center' }}>
<Text style={{ color:C.text }}>{item.display_name}</Text>
<Pressable onPress={()=>remove(item.id)} style={{ backgroundColor:C.warn, paddingVertical:6, paddingHorizontal:10, borderRadius:8 }}>
<Text style={{ color:'#fff' }}>移除</Text>
</Pressable>
</View>
);

const BuddyRow = ({ item }: any) => (
<View style={{ padding:10, borderWidth:1, borderColor:C.border, backgroundColor:C.card, borderRadius:8, marginBottom:8, flexDirection:'row', justifyContent:'space-between', alignItems:'center' }}>
<View>
<Text style={{ color:C.text, fontWeight:'600' }}>{item.name}（Lv {item.level}）</Text>
</View>
<Pressable onPress={()=>add(item.id)} style={{ backgroundColor:C.primary, paddingVertical:6, paddingHorizontal:10, borderRadius:8 }}>
<Text style={{ color:'#fff' }}>加入</Text>
</Pressable>
</View>
);

return (
<View style={{ flex:1, backgroundColor:C.bg, padding:12 }}>
<Text style={{ color:C.text, fontSize:16, fontWeight:'700', marginBottom:8 }}>已報到</Text>
<FlatList
data={attendees}
keyExtractor={i=>i.id}
renderItem={AttRow}
ListEmptyComponent={<Text style={{ color:C.sub, marginBottom:8 }}>目前無報到名單</Text>}
ListFooterComponent={
<View style={{ marginTop:12 }}>
<Text style={{ color:C.text, fontSize:16, fontWeight:'700', marginBottom:8 }}>從球友名單加入</Text>
<TextInput value={search} onChangeText={setSearch} placeholder="搜尋姓名" placeholderTextColor="#888"
style={{ borderWidth:1, borderColor:'#444', borderRadius:8, paddingHorizontal:10, paddingVertical:8, color:C.text, marginBottom:8 }} />
<FlatList
data={filtered}
keyExtractor={i=>i.id}
renderItem={BuddyRow}
/>
</View>
}
/>
</View>
);
}ezbmt-tracked/src/screens/SpeedCamScreen_origin.tsx
 
import React from 'react';
import { View, Text, Pressable, Alert, Dimensions } from 'react-native';
import {
Camera,
useCameraDevice,
useFrameProcessor,
VisionCameraProxy,
type FrameProcessorPlugin,
} from 'react-native-vision-camera';
import { runOnJS } from 'react-native-reanimated';
import { insertSpeedSession, insertSpeedPoints } from '../db';

type Sample = { x: number; y: number; ts: number; score: number; w?: number; h?: number };
type Pt = { x: number; y: number };

export default function SpeedCamScreen() {
const device = useCameraDevice('back');

// 權限
const [hasPerm, setHasPerm] = React.useState(false);
React.useEffect(() => {
(async () => {
const cam = await Camera.requestCameraPermission();
setHasPerm(cam === 'granted');
})();
}, []);

// 即時速度（m/s）
const [speedMs, setSpeedMs] = React.useState(0);
const updateSpeed = React.useCallback((msInst: number) => {
setSpeedMs(prev => (prev === 0 ? msInst : prev * 0.7 + msInst * 0.3));
}, []);

// 上一筆樣本
const lastRef = React.useRef<Sample | null>(null);

// 校正
const [calibMode, setCalibMode] = React.useState(false);
const [calibA, setCalibA] = React.useState<Pt | null>(null);
const [calibB, setCalibB] = React.useState<Pt | null>(null);
const [metersPerUnit, setMetersPerUnit] = React.useState<number | null>(null);

// 視圖與幀尺寸
const [viewSize, setViewSize] = React.useState({
w: Dimensions.get('window').width,
h: Dimensions.get('window').height * 0.7,
});
const frameSizeRef = React.useRef<{ w: number; h: number } | null>(null);

// 錄製
const [recording, setRecording] = React.useState(false);
const recordBufRef = React.useRef<Array<{ idx: number; x: number; y: number; ts: number }>>([]);

// 取得原生 Frame Processor Plugin
const speedPlugin = React.useMemo<FrameProcessorPlugin | undefined>(() => {
try {
const proxy: any = VisionCameraProxy as any;
const getter = proxy?.getFrameProcessorPlugin ?? proxy?.initFrameProcessorPlugin;
const p = typeof getter === 'function' ? getter('STPlugin') : undefined;
console.log('STPlugin type:', typeof p);
return p;
} catch {
return undefined;
}
}, []);

// 座標轉幀 normalized（0..1），含 aspectFill 修正
const toFrameNorm = React.useCallback(
(vx: number, vy: number): Pt | null => {
const fs = frameSizeRef.current;
if (!fs) return null;
const VW = viewSize.w, VH = viewSize.h;
const FW = fs.w, FH = fs.h;
if (!VW || !VH || !FW || !FH) return null;

  const scale = Math.max(VW / FW, VH / FH);
  const dispW = FW * scale, dispH = FH * scale;
  const offX = (dispW - VW) / 2;
  const offY = (dispH - VH) / 2;

  const fx = (vx + offX) / scale;
  const fy = (vy + offY) / scale;
  return { x: Math.min(1, Math.max(0, fx / FW)), y: Math.min(1, Math.max(0, fy / FH)) };
},
[viewSize],
);

// 校正點擊
const onTapOverlay = (evt: any) => {
if (!calibMode) return;
const { locationX, locationY } = evt.nativeEvent;
const p = toFrameNorm(locationX, locationY);
if (!p) { Alert.alert('等待相機幀尺寸…'); return; }
if (!calibA) setCalibA(p);
else if (!calibB) setCalibB(p);
else { setCalibA(p); setCalibB(null); }
};

const applyCalib = (knownMeters: number) => {
if (!calibA || !calibB) { Alert.alert('請在畫面上點兩點'); return; }
const du = Math.hypot(calibB.x - calibA.x, calibB.y - calibA.y);
if (du < 1e-4) { Alert.alert('兩點太近'); return; }
setMetersPerUnit(knownMeters / du);
setCalibMode(false);
};

// 錄製控制
const startRecord = () => {
recordBufRef.current = [];
setRecording(true);
};
const stopRecordAndSave = async () => {
setRecording(false);
const rows = recordBufRef.current.slice();
if (rows.length < 2) { Alert.alert('提示', '資料不足，未儲存'); return; }
try {
const sid = await insertSpeedSession('camera', 'kmh');
await insertSpeedPoints(
sid,
rows.map((r, i) => ({ idx: i, rx: r.x, ry: r.y, ts: Math.round(r.ts) })), // ts 已為 ms
);
Alert.alert('已儲存', `共 ${rows.length} 筆！`);
} catch (e: any) {
Alert.alert('儲存失敗', String(e?.message || e));
}
};

// JS 端樣本處理
const onSampleCalc = React.useCallback(
(s: Sample) => {
// 記錄幀尺寸
if (typeof s.w === 'number' && typeof s.h === 'number' && s.w > 0 && s.h > 0) {
frameSizeRef.current = { w: s.w, h: s.h };
}

  const last = lastRef.current;
  if (last && metersPerUnit != null) {
    // 重要：timestamp 為毫秒 → 轉秒
    const dtSec = (s.ts - last.ts) / 1000;
    if (dtSec > 0) {
      const du = Math.hypot(s.x - last.x, s.y - last.y);
      const meters = du * metersPerUnit;
      const mps = meters / dtSec;
      updateSpeed(mps);
    }
  }
  lastRef.current = s;

  if (recording) {
    const buf = recordBufRef.current;
    buf.push({ idx: buf.length, x: s.x, y: s.y, ts: s.ts });
  }
},
[metersPerUnit, recording, updateSpeed],
);

// frameProcessor（以毫秒節流）
const frameProcessor = useFrameProcessor(
(frame) => {
'worklet';

  // ~30 FPS 節流（ms）
  // @ts-ignore
  const last = globalThis.__lastFP || 0;
  const dtMs = frame.timestamp - last; // VisionCamera 為 ms
  if (dtMs < 33) return;
  // @ts-ignore
  globalThis.__lastFP = frame.timestamp;

  // 取得插件
  // @ts-ignore
  const p = speedPlugin as any;
  if (!p) return;

  // 兩種呼叫方式
  // @ts-ignore
  const res = p.call ? p.call(frame, {}) : p(frame, {});
  if (!res) return;

  const s = {
    x: res.x as number,
    y: res.y as number,
    ts: res.ts as number,   // ms
    score: res.score as number,
    w: res.w as number,
    h: res.h as number,
  };

  // 門檻先放低
  if (s.score < 3) return;

  runOnJS(onSampleCalc)(s);
},
[onSampleCalc, speedPlugin],
);

if (!device)
return <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}><Text>找不到可用相機</Text></View>;
if (!hasPerm)
return <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}><Text>尚未取得相機權限</Text></View>;

const kmh = speedMs * 3.6;

return (
<View style={{ flex: 1 }}>
<Camera
style={{ flex: 1 }}
device={device}
isActive
pixelFormat="yuv"
frameProcessor={frameProcessor}
/>

  {/* 透明點擊層（校正） */}
  <View
    onLayout={(e) => {
      const { width, height } = e.nativeEvent.layout;
      setViewSize({ w: width, h: height });
    }}
    onStartShouldSetResponder={() => true}
    onResponderRelease={onTapOverlay}
    pointerEvents="box-only"
    style={{ position: 'absolute', left: 0, right: 0, top: 0, bottom: 0 }}
  />

  {/* UI 面板 */}
  <View style={{ position: 'absolute', left: 10, right: 10, bottom: 10, backgroundColor: 'rgba(0,0,0,0.55)', borderRadius: 12, padding: 12 }}>
    <Text style={{ color: '#fff', fontSize: 18, fontWeight: '700' }}>{kmh.toFixed(1)} km/h ({speedMs.toFixed(2)} m/s)</Text>
    <Text style={{ color: '#fff', marginTop: 4 }}>
      校正：{metersPerUnit ? `${metersPerUnit.toFixed(3)} m / normalized-unit` : '尚未校正'}
    </Text>

    <View style={{ flexDirection: 'row', marginTop: 8, flexWrap: 'wrap' }}>
      <Pressable onPress={() => { setCalibMode((v) => !v); setCalibA(null); setCalibB(null); }}
        style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#1976d2', borderRadius: 8, marginRight: 8, marginBottom: 8 }}>
        <Text style={{ color: '#fff' }}>{calibMode ? '退出校正' : '校正模式'}</Text>
      </Pressable>

      {calibMode && (
        <>
          <Pressable onPress={() => applyCalib(6.1)}
            style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#2e7d32', borderRadius: 8, marginRight: 8, marginBottom: 8 }}>
            <Text style={{ color: '#fff' }}>雙打寬 6.1m</Text>
          </Pressable>
          <Pressable onPress={() => applyCalib(5.18)}
            style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#00796b', borderRadius: 8, marginRight: 8, marginBottom: 8 }}>
            <Text style={{ color: '#fff' }}>單打寬 5.18m</Text>
          </Pressable>
        </>
      )}

      <Pressable onPress={() => { setMetersPerUnit(null); setCalibA(null); setCalibB(null); }}
        style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#9e9e9e', borderRadius: 8, marginRight: 8, marginBottom: 8 }}>
        <Text style={{ color: '#fff' }}>清除校正</Text>
      </Pressable>

      {!recording ? (
        <Pressable onPress={startRecord}
          style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#e53935', borderRadius: 8, marginLeft: 8 }}>
          <Text style={{ color: '#fff' }}>開始錄製</Text>
        </Pressable>
      ) : (
        <Pressable onPress={stopRecordAndSave}
          style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#8e24aa', borderRadius: 8, marginLeft: 8 }}>
          <Text style={{ color: '#fff' }}>停止並儲存</Text>
        </Pressable>
      )}
    </View>

    {calibMode && (
      <Text style={{ color: '#fff', marginTop: 6 }}>
        校正說明：在預覽畫面上點兩點（例如球場左右邊線），再點選 6.1m 或 5.18m。
      </Text>
    )}
  </View>
</View>
);
}ezbmt-tracked/src/screens/SpeedCamScreen.tsx
 
import React from 'react';
import {
  View,
  Text,
  Pressable,
  Alert,
  Dimensions,
  NativeSyntheticEvent,
  LayoutChangeEvent,
  ScrollView,
} from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import Svg, { Polyline, Circle } from 'react-native-svg';
import RNSpeedCamView, { type NativeSample } from '../native/SpeedCamNative';
import { insertSpeedSession, insertSpeedPoints } from '../db';

type Pt = { x: number; y: number };
type Unit = 'kmh' | 'mph';

// ---------- RotBox：將內容順時針旋轉 90°（橫向顯示） ----------
function RotBox({
  children,
  style,
  offset = { x: 0, y: 0 },
}: {
  children: React.ReactNode;
  style?: any;
  offset?: { x: number; y: number };
}) {
  const [box, setBox] = React.useState({ w: 0, h: 0 });
  return (
    <View
      onLayout={(e) =>
        setBox({
          w: e.nativeEvent.layout.width,
          h: e.nativeEvent.layout.height,
        })
      }
      style={[
        style,
        {
          transform: [
            { translateX: box.h + offset.x },
            { translateY: offset.y },
            { rotate: '90deg' },
          ],
        },
      ]}
    >
      {children}
    </View>
  );
}

// -------------- Homography（四點透視變換）工具 --------------
function solveLinearSystem(A: number[][], b: number[]): number[] {
  const n = A.length;
  const M = A.map((row, i) => [...row, b[i]]);
  for (let i = 0; i < n; i++) {
    let maxRow = i;
    for (let r = i + 1; r < n; r++)
      if (Math.abs(M[r][i]) > Math.abs(M[maxRow][i])) maxRow = r;
    if (Math.abs(M[maxRow][i]) < 1e-12) throw new Error('Singular matrix');
    if (maxRow !== i) {
      const t = M[i];
      M[i] = M[maxRow];
      M[maxRow] = t;
    }
    const piv = M[i][i];
    for (let c = i; c <= n; c++) M[i][c] /= piv;
    for (let r = 0; r < n; r++) {
      if (r === i) continue;
      const f = M[r][i];
      for (let c = i; c <= n; c++) M[r][c] -= f * M[i][c];
    }
  }
  return M.map((row) => row[n]);
}
function computeHomography(
  src: Array<{ x: number; y: number }>,
  dst: Array<{ X: number; Y: number }>,
): number[] {
  const A: number[][] = [];
  const b: number[] = [];
  for (let i = 0; i < 4; i++) {
    const { x, y } = src[i];
    const { X, Y } = dst[i];
    A.push([x, y, 1, 0, 0, 0, -X * x, -X * y]);
    b.push(X);
    A.push([0, 0, 0, x, y, 1, -Y * x, -Y * y]);
    b.push(Y);
  }
  const h = solveLinearSystem(A, b);
  return [...h, 1];
}
function applyHomography(
  H: number[],
  x: number,
  y: number,
): { X: number; Y: number } | null {
  const d = H[6] * x + H[7] * y + 1;
  if (Math.abs(d) < 1e-12) return null;
  const X = (H[0] * x + H[1] * y + H[2]) / d;
  const Y = (H[3] * x + H[4] * y + H[5]) / d;
  return { X, Y };
}

// ---------------- 座標映射（關鍵修正） ----------------
type MapVars = {
  VW: number; VH: number; // view size
  FW: number; FH: number; // frame size (from sample)
  scale: number;
  offX: number;
  offY: number;
  rotated: boolean; // 幀為橫向且 View 為直向 → 需要 90° 補償
};

// 計算 aspectFill 對應的 scale/off 並偵測是否要旋轉補償
function getMapVars(view: { w: number; h: number }, frame: { w: number; h: number } | null): MapVars | null {
  if (!frame) return null;
  const VW = view.w, VH = view.h;
  const FW = frame.w, FH = frame.h;
  if (!(VW && VH && FW && FH)) return null;

  // 預設：我們的預覽是 resizeAspectFill
  const scale = Math.max(VW / FW, VH / FH);
  const dispW = FW * scale;
  const dispH = FH * scale;
  const offX = (dispW - VW) / 2;
  const offY = (dispH - VH) / 2;

  // 旋轉補償：若幀為橫向、View 為直向 → 多半是 90 度
  const frameLandscape = FW > FH;
  const viewPortrait = VH > VW;
  const rotated = frameLandscape && viewPortrait;

  return { VW, VH, FW, FH, scale, offX, offY, rotated };
}

// View → Frame normalized
function viewToFrameNorm(vx: number, vy: number, mv: MapVars): Pt {
  // 先轉到「縮放後影像座標」
  const ix = (vx + mv.offX) / mv.scale; // in frame px
  const iy = (vy + mv.offY) / mv.scale;

  // 轉 normalized（未旋轉）
  let fx = ix / mv.FW;
  let fy = iy / mv.FH;

  // 如需補償旋轉（View portrait / Frame landscape）
  if (mv.rotated) {
    // 逆時針 ↔ 順時針的實務差異在不同機型上會不同
    // 這裡採用：畫面已被旋到直向，反推回 frame：view(x,y) → frame(u,v)
    // 以「向右 90°」來還原： fx' = fy, fy' = 1 - fx
    const rx = fy;
    const ry = 1 - fx;
    fx = rx; fy = ry;
  }

  // clamp
  fx = Math.min(1, Math.max(0, fx));
  fy = Math.min(1, Math.max(0, fy));
  return { x: fx, y: fy };
}

// Frame normalized → View（反變換）
function frameNormToView(fx: number, fy: number, mv: MapVars): { x: number; y: number } {
  // 還原旋轉對映
  let fxRaw = fx;
  let fyRaw = fy;
  if (mv.rotated) {
    // 反向於上式： fx' = 1 - fy, fy' = fx
    const ix = 1 - fyRaw;
    const iy = fxRaw;
    fxRaw = ix;
    fyRaw = iy;
  }

  // 轉到縮放後影像座標（px）
  const ix = fxRaw * mv.FW;
  const iy = fyRaw * mv.FH;

  // 轉回到 View（扣掉裁切 + 乘回 scale）
  const vx = ix * mv.scale - mv.offX;
  const vy = iy * mv.scale - mv.offY;
  return { x: vx, y: vy };
}

// ------------------------------------------------------------
const PREF_KEY = 'speedcam:prefs:v1';

export default function SpeedCamScreen() {
  // 權限（Info.plist 已有）
  const [hasPerm] = React.useState(true);

  // 即時速度（m/s）
  const [speedMs, setSpeedMs] = React.useState(0);

  // 單位/平滑/最大值暫留（預設值）
  const [unit, setUnit] = React.useState<Unit>('kmh'); // kmh/mph
  const [alpha, setAlpha] = React.useState(0.3);        // 0.05~0.6
  const [holdMs, setHoldMs] = React.useState(800);      // 0~2000 ms

  // 平均速度（簡單 EMA）
  const [avgMs, setAvgMs] = React.useState(0);
  const maxHoldRef = React.useRef<{ v: number; until: number }>({
    v: 0,
    until: 0,
  });

  const msToUnit = React.useCallback(
    (mps: number) => (unit === 'kmh' ? mps * 3.6 : mps * 2.2369362921),
    [unit],
  );

  const updateSpeed = React.useCallback(
    (msInst: number) => {
      const a = Math.min(0.99, Math.max(0.01, alpha));
      setSpeedMs((prev) => (prev === 0 ? msInst : prev * (1 - a) + msInst * a));
      setAvgMs((prev) => (prev === 0 ? msInst : prev * 0.98 + msInst * 0.02));
    },
    [alpha],
  );

  // 上一筆樣本
  const lastRef = React.useRef<NativeSample | null>(null);

  // View 尺寸（透明層）
  const [viewSize, setViewSize] = React.useState({
    w: Dimensions.get('window').width,
    h: Dimensions.get('window').height * 0.7,
  });

  // Frame 尺寸（由 sample 提供）
  const frameSizeRef = React.useRef<{ w: number; h: number } | null>(null);

  // 設定面板：可收納
  const [panelOpen, setPanelOpen] = React.useState(true);

  // 速度門檻（固定使用 km/h 表示）
  const [minKmh, setMinKmh] = React.useState(200); // 50~300
  const [maxKmh, setMaxKmh] = React.useState(500); // 200~600

  // 二點寬度校正
  const [calib2On, setCalib2On] = React.useState(false);
  const [calibA, setCalibA] = React.useState<Pt | null>(null); // frame normalized
  const [calibB, setCalibB] = React.useState<Pt | null>(null);
  const [metersPerUnit, setMetersPerUnit] = React.useState<number | null>(null);

  // 四點校正（優先）
  const [calib4On, setCalib4On] = React.useState(false);
  const [courtMode, setCourtMode] = React.useState<'doubles' | 'singles'>(
    'doubles',
  );
  const [corners, setCorners] = React.useState<Pt[]>([]); // frame normalized
  const [H, setH] = React.useState<number[] | null>(null);

  // 原生過濾/追蹤門檻（亮度/彩度/區塊/ROI）
  const [yMinNum, setYMinNum] = React.useState(150); // 100~220
  const [cMaxNum, setCMaxNum] = React.useState(20);  // 5~40
  const [blkNum, setBlkNum] = React.useState(8);     // 4~16
  const [roiNum, setRoiNum] = React.useState(64);    // 32~128（>= block）

  // 錄製
  const [recording, setRecording] = React.useState(false);
  const recordBufRef = React.useRef<
    Array<{ idx: number; x: number; y: number; ts: number }>
  >([]);

  // 追蹤軌跡（最近 1.5 秒）frame normalized
  const trailRef = React.useRef<Array<{ x: number; y: number; ts: number }>>(
    [],
  );

  // 偏好載入
  React.useEffect(() => {
    (async () => {
      try {
        const s = await AsyncStorage.getItem(PREF_KEY);
        if (!s) return;
        const p = JSON.parse(s);
        if (p.unit) setUnit(p.unit);
        if (typeof p.minKmh === 'number') setMinKmh(p.minKmh);
        if (typeof p.maxKmh === 'number') setMaxKmh(p.maxKmh);
        if (typeof p.alpha === 'number') setAlpha(p.alpha);
        if (typeof p.holdMs === 'number') setHoldMs(p.holdMs);
        if (typeof p.yMinNum === 'number') setYMinNum(p.yMinNum);
        if (typeof p.cMaxNum === 'number') setCMaxNum(p.cMaxNum);
        if (typeof p.blkNum === 'number') setBlkNum(p.blkNum);
        if (typeof p.roiNum === 'number') setRoiNum(p.roiNum);
      } catch {}
    })();
  }, []);

  // 偏好保存（簡易節流）
  React.useEffect(() => {
    const t = setTimeout(() => {
      const payload = {
        unit,
        minKmh,
        maxKmh,
        alpha,
        holdMs,
        yMinNum,
        cMaxNum,
        blkNum,
        roiNum,
      };
      AsyncStorage.setItem(PREF_KEY, JSON.stringify(payload)).catch(() => {});
    }, 250);
    return () => clearTimeout(t);
  }, [unit, minKmh, maxKmh, alpha, holdMs, yMinNum, cMaxNum, blkNum, roiNum]);

  // 點選（四點/兩點）使用映射：View → FrameNormalized
  const onTapOverlay = (evt: any) => {
    const mv = getMapVars(viewSize, frameSizeRef.current);
    if (!mv) {
      Alert.alert('等待相機幀尺寸…');
      return;
    }
    const { locationX, locationY } = evt.nativeEvent;
    const p = viewToFrameNorm(locationX, locationY, mv);

    if (calib4On) {
      const next = [...corners, p];
      if (next.length < 4) {
        setCorners(next);
      } else {
        const fs = frameSizeRef.current!;
        const srcPx = next.map((pt) => ({ x: pt.x * fs.w, y: pt.y * fs.h }));
        const L = 13.4;
        const W = courtMode === 'doubles' ? 6.1 : 5.18;
        try {
          const h = computeHomography(srcPx, [
            { X: 0, Y: 0 },
            { X: W, Y: 0 },
            { X: W, Y: L },
            { X: 0, Y: L },
          ]);
          setH(h);
          setCorners(next);
          setCalib4On(false);
          Alert.alert('完成', '四點校正已建立');
        } catch {
          Alert.alert('失敗', '無法建立透視變換，請重試（確認四點順序與不共線）');
          setCorners([]);
          setH(null);
        }
      }
      return;
    }

    if (calib2On) {
      if (!calibA) setCalibA(p);
      else if (!calibB) setCalibB(p);
      else {
        setCalibA(p);
        setCalibB(null);
      }
    }
  };

  const applyCalib2 = (knownMeters: number) => {
    if (!calibA || !calibB) {
      Alert.alert('請先點兩點');
      return;
    }
    const du = Math.hypot(calibB.x - calibA.x, calibB.y - calibA.y);
    if (du < 1e-4) {
      Alert.alert('兩點太近');
      return;
    }
    setMetersPerUnit(knownMeters / du);
    setCalib2On(false);
  };

  const clearAllCalib = () => {
    setMetersPerUnit(null);
    setCalibA(null);
    setCalibB(null);
    setH(null);
    setCorners([]);
    setCalib4On(false);
  };

  const startRecord = () => {
    recordBufRef.current = [];
    setRecording(true);
  };
  const stopRecordAndSave = async () => {
    setRecording(false);
    const rows = recordBufRef.current.slice();
    if (rows.length < 2) {
      Alert.alert('提示', '資料不足，未儲存');
      return;
    }
    try {
      const sid = await insertSpeedSession('camera', 'kmh');
      await insertSpeedPoints(
        sid,
        rows.map((r, i) => ({
          idx: i,
          rx: r.x,
          ry: r.y,
          ts: Math.round(r.ts),
        })),
      );
      Alert.alert('已儲存', `共 ${rows.length} 筆！`);
    } catch (e: any) {
      Alert.alert('儲存失敗', String(e?.message || e));
    }
  };

  const onSample = React.useCallback(
    (e: NativeSyntheticEvent<NativeSample>) => {
      const s = e.nativeEvent;
      if (s.w && s.h) frameSizeRef.current = { w: s.w, h: s.h };

      const last = lastRef.current;
      if (!last) {
        lastRef.current = s;
        return;
      }

      const dtSec = (s.ts - last.ts) / 1000;
      if (dtSec <= 0.005 || dtSec > 0.5) {
        lastRef.current = s;
        return;
      }

      let mps: number | null = null;
      if (H && frameSizeRef.current) {
        const fs = frameSizeRef.current;
        const a = applyHomography(H, last.x * fs.w, last.y * fs.h);
        const b = applyHomography(H, s.x * fs.w, s.y * fs.h);
        if (a && b) {
          const meters = Math.hypot(b.X - a.X, b.Y - a.Y);
          mps = meters / dtSec;
        }
      } else if (metersPerUnit != null) {
        const du = Math.hypot(s.x - last.x, s.y - last.y);
        const meters = du * metersPerUnit;
        mps = meters / dtSec;
      }

      if (mps != null && Number.isFinite(mps) && mps > 0) {
        const minMps = minKmh / 3.6;
        const maxMps = maxKmh / 3.6;
        if (mps >= minMps && mps <= maxMps) {
          updateSpeed(mps);

          const now = s.ts;
          const disp = msToUnit(mps);
          const curMax = maxHoldRef.current;
          const expired = now > curMax.until;
          if (expired || disp > msToUnit(curMax.v)) {
            maxHoldRef.current = { v: mps, until: now + holdMs };
          }

          const n = s.ts;
          trailRef.current.push({ x: s.x, y: s.y, ts: n });
          trailRef.current = trailRef.current.filter((p) => n - p.ts <= 1500);

          if (recording) {
            recordBufRef.current.push({
              idx: recordBufRef.current.length,
              x: s.x,
              y: s.y,
              ts: s.ts,
            });
          }
        }
      }
      lastRef.current = s;
    },
    [
      H,
      metersPerUnit,
      minKmh,
      maxKmh,
      recording,
      updateSpeed,
      msToUnit,
      holdMs,
    ],
  );

  const cur = msToUnit(speedMs);
  const avg = msToUnit(avgMs);
  const maxDisp = (() => {
    const now = Date.now();
    const curMax = maxHoldRef.current;
    if (now <= curMax.until && curMax.v > 0) return msToUnit(curMax.v);
    return null;
  })();

  const onOverlayLayout = (e: LayoutChangeEvent) => {
    const { width, height } = e.nativeEvent.layout;
    setViewSize({ w: width, h: height });
  };

  if (!hasPerm)
    return (
      <View
        style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}
      >
        <Text>尚未取得相機權限</Text>
      </View>
    );

  // 面板尺寸（旋轉前）
  const PANEL_W = 560;
  const PANEL_MAX_H = 360;

  // 取 MapVars（供繪製點時用反變換）
  const mv = getMapVars(viewSize, frameSizeRef.current);

  // 把一串 frame normalized 座標轉回 View px
  const mapTrailToScreen = React.useCallback(() => {
    if (!mv) return '';
    return trailRef.current
      .map((p) => {
        const v = frameNormToView(p.x, p.y, mv);
        return `${v.x},${v.y}`;
      })
      .join(' ');
  }, [mv]);

  // 工具：把單一幀座標畫在螢幕
  const drawDot = (pt?: Pt | null, color = '#fff', r = 6) => {
    if (!mv || !pt) return null;
    const v = frameNormToView(pt.x, pt.y, mv);
    return <Circle cx={v.x} cy={v.y} r={r} fill={color} />;
  };

  return (
    <View style={{ flex: 1, backgroundColor: '#000' }}>
      {/* 相機預覽 */}
      <RNSpeedCamView
        style={{ flex: 1 }}
        isActive={true}
        onSample={onSample}
        yMin={yMinNum}
        chromaMax={cMaxNum}
        blockSize={blkNum}
        roiPad={roiNum}
      />

      {/* 透明點擊層（校正點） */}
      <View
        onLayout={onOverlayLayout}
        onStartShouldSetResponder={() => true}
        onResponderRelease={onTapOverlay}
        pointerEvents="box-only"
        style={{ position: 'absolute', left: 0, right: 0, top: 0, bottom: 0 }}
      />

      {/* 軌跡繪製（最近 1.5 秒）＋ 校正點可視化（改用 frameNormToView） */}
      <View
        pointerEvents="none"
        style={{ position: 'absolute', left: 0, right: 0, top: 0, bottom: 0 }}
      >
        <Svg width={viewSize.w} height={viewSize.h}>
          <Polyline
            points={mv ? mapTrailToScreen() : ''}
            stroke="#00e5ff"
            strokeWidth={3}
            fill="none"
            opacity={0.85}
          />
          {/* 末端點 */}
          {mv && trailRef.current.length > 0 && (
            (() => {
              const p = trailRef.current[trailRef.current.length - 1];
              const v = frameNormToView(p.x, p.y, mv);
              return <Circle cx={v.x} cy={v.y} r={6} fill="#00e5ff" />;
            })()
          )}
          {/* 四點校正點＆輪廓 */}
          {corners.map((pt, i) => drawDot(pt, '#ffeb3b', 6))}
          {mv && corners.length === 4 && (
            <Polyline
              points={
                corners
                  .concat([corners[0]])
                  .map((pt) => {
                    const v = frameNormToView(pt.x, pt.y, mv);
                    return `${v.x},${v.y}`;
                  })
                  .join(' ')
              }
              stroke="#ffeb3b"
              strokeWidth={2}
              fill="none"
              opacity={0.7}
            />
          )}
          {/* 兩點校正點 */}
          {drawDot(calibA, '#ffc107', 6)}
          {drawDot(calibB, '#ff9800', 6)}
        </Svg>
      </View>

      {/* 速度顯示（橫向） */}
      <View style={{ position: 'absolute', right: 0, top: 75 }}>
        <RotBox>
          <View
            style={{
              backgroundColor: 'rgba(0,0,0,0.55)',
              borderRadius: 8,
              paddingVertical: 6,
              paddingHorizontal: 10,
            }}
          >
            {H || metersPerUnit ? (
              <>
                <Text style={{ color: '#fff', fontSize: 18, fontWeight: '800' }}>
                  {cur.toFixed(1)} {unit}（α={alpha.toFixed(2)}）
                </Text>
                <Text style={{ color: '#fff', marginTop: 2 }}>
                  平均 {avg.toFixed(1)} {unit}
                  {maxDisp != null ? ` · MAX ${maxDisp.toFixed(1)} ${unit}` : ''}
                </Text>
              </>
            ) : (
              <Text style={{ color: '#fff' }}>尚未校正</Text>
            )}
          </View>
        </RotBox>
      </View>

      {/* 設定面板開關（橫向） */}
      <View style={{ position: 'absolute', right: 10, top: 200 }}>
        <RotBox>
          <Pressable
            onPress={() => setPanelOpen((o) => !o)}
            style={{
              backgroundColor: panelOpen ? '#455a64' : '#1976d2',
              paddingVertical: 6,
              paddingHorizontal: 10,
              borderRadius: 8,
            }}
          >
            <Text style={{ color: '#fff' }}>
              {panelOpen ? '收合設定' : '展開設定'}
            </Text>
          </Pressable>
        </RotBox>
      </View>

      {/* 設定面板（橫向）：兩欄 + 內層滾動 */}
      {panelOpen && (
        <View style={{ position: 'absolute', right: 320, bottom: 50 }}>
          <RotBox>
            <View
              style={{
                backgroundColor: 'rgba(0,0,0,0.6)',
                borderRadius: 12,
                padding: 12,
                width: 560,
              }}
            >
              <Text
                style={{
                  color: '#fff',
                  fontSize: 16,
                  fontWeight: '700',
                  marginBottom: 8,
                }}
              >
                設定
              </Text>

              <View style={{ maxHeight: 360 }}>
                <ScrollView
                  showsVerticalScrollIndicator
                  contentContainerStyle={{ paddingBottom: 8 }}
                >
                  <View style={{ flexDirection: 'row', flexWrap: 'wrap' }}>
                    {/* 左欄 */}
                    <View style={{ width: 270, paddingRight: 8 }}>
                      {/* 速度門檻（km/h） */}
                      <RangeBar
                        label="速度下限"
                        value={minKmh}
                        min={50}
                        max={300}
                        step={5}
                        unit="km/h"
                        defaultValue={200}
                        onChange={(v) => {
                          const nv = Math.min(v, maxKmh);
                          setMinKmh(nv);
                          if (nv >= maxKmh) setMaxKmh(Math.min(600, nv + 50));
                        }}
                      />
                      <RangeBar
                        label="速度上限"
                        value={maxKmh}
                        min={200}
                        max={600}
                        step={5}
                        unit="km/h"
                        defaultValue={500}
                        onChange={(v) => setMaxKmh(Math.max(v, minKmh))}
                      />

                      {/* 單位 */}
                      <View style={{ marginTop: 6, marginBottom: 10 }}>
                        <Text style={{ color: '#fff', fontWeight: '700', marginBottom: 6 }}>
                          單位
                        </Text>
                        <View style={{ flexDirection: 'row' }}>
                          <Pressable
                            onPress={() => setUnit('kmh')}
                            style={{
                              paddingVertical: 6,
                              paddingHorizontal: 10,
                              borderRadius: 14,
                              borderWidth: 1,
                              borderColor: unit === 'kmh' ? '#90caf9' : '#555',
                              backgroundColor:
                                unit === 'kmh' ? 'rgba(144,202,249,0.15)' : '#1f1f1f',
                              marginRight: 8,
                            }}
                          >
                            <Text style={{ color: '#fff' }}>km/h</Text>
                          </Pressable>
                          <Pressable
                            onPress={() => setUnit('mph')}
                            style={{
                              paddingVertical: 6,
                              paddingHorizontal: 10,
                              borderRadius: 14,
                              borderWidth: 1,
                              borderColor: unit === 'mph' ? '#90caf9' : '#555',
                              backgroundColor:
                                unit === 'mph' ? 'rgba(144,202,249,0.15)' : '#1f1f1f',
                            }}
                          >
                            <Text style={{ color: '#fff' }}>mph</Text>
                          </Pressable>
                        </View>
                      </View>

                      <RangeBar
                        label="平滑係數 α"
                        value={alpha}
                        min={0.05}
                        max={0.6}
                        step={0.01}
                        hint="0.05=更平滑，0.5=更靈敏"
                        defaultValue={0.3}
                        onChange={(v) => setAlpha(v)}
                      />
                      <RangeBar
                        label="MAX 暫留"
                        value={holdMs}
                        min={0}
                        max={2000}
                        step={50}
                        unit="ms"
                        defaultValue={800}
                        onChange={(v) => setHoldMs(v)}
                      />
                    </View>

                    {/* 右欄 */}
                    <View style={{ width: 270, paddingLeft: 8 }}>
                      <Text
                        style={{
                          color: '#fff',
                          fontWeight: '700',
                          marginBottom: 6,
                        }}
                      >
                        白球過濾/追蹤
                      </Text>
                      <RangeBar
                        label="亮度 yMin"
                        value={yMinNum}
                        min={100}
                        max={220}
                        step={2}
                        defaultValue={150}
                        onChange={(v) => setYMinNum(v)}
                      />
                      <RangeBar
                        label="彩度偏移 cMax"
                        value={cMaxNum}
                        min={5}
                        max={40}
                        step={1}
                        defaultValue={20}
                        onChange={(v) => setCMaxNum(v)}
                      />
                      <RangeBar
                        label="區塊大小 block"
                        value={blkNum}
                        min={4}
                        max={16}
                        step={1}
                        defaultValue={8}
                        onChange={(v) => {
                          const b = Math.round(v);
                          setBlkNum(b);
                          if (roiNum < b) setRoiNum(b);
                        }}
                      />
                      <RangeBar
                        label="ROI 半徑"
                        value={roiNum}
                        min={32}
                        max={128}
                        step={4}
                        defaultValue={64}
                        onChange={(v) => setRoiNum(Math.max(Math.round(v), blkNum))}
                      />

                      {/* 四點校正（優先） */}
                      <View style={{ marginTop: 6, marginBottom: 10 }}>
                        <Text
                          style={{ color: '#fff', fontWeight: '700', marginBottom: 6 }}
                        >
                          四點校正
                        </Text>
                        <View style={{ flexDirection: 'row', flexWrap: 'wrap' }}>
                          <Pressable
                            onPress={() => {
                              setCalib4On(true);
                              setCorners([]);
                              setH(null);
                              setCalib2On(false);
                            }}
                            style={{
                              backgroundColor: '#1976d2',
                              paddingVertical: 6,
                              paddingHorizontal: 10,
                              borderRadius: 8,
                              marginRight: 8,
                              marginBottom: 8,
                            }}
                          >
                            <Text style={{ color: '#fff' }}>
                              {calib4On ? '點四角：進行中…' : '開始點四角'}
                            </Text>
                          </Pressable>
                          <Pressable
                            onPress={() =>
                              setCourtMode((m) => (m === 'doubles' ? 'singles' : 'doubles'))
                            }
                            style={{
                              backgroundColor: '#455a64',
                              paddingVertical: 6,
                              paddingHorizontal: 10,
                              borderRadius: 8,
                              marginBottom: 8,
                            }}
                          >
                            <Text style={{ color: '#fff' }}>
                              {courtMode === 'doubles'
                                ? '模式：雙打 6.1×13.4'
                                : '模式：單打 5.18×13.4'}
                            </Text>
                          </Pressable>
                        </View>
                        {!!corners.length && (
                          <Text style={{ color: '#ddd', marginBottom: 6 }}>
                            已點 {corners.length}/4（順序：上左→上右→下右→下左）
                          </Text>
                        )}
                        {!!H && (
                          <Text style={{ color: '#90caf9' }}>
                            已使用四點校正（更精準）
                          </Text>
                        )}
                      </View>

                      {/* 二點校正（快速/備用） */}
                      <View style={{ marginBottom: 6 }}>
                        <Text
                          style={{ color: '#fff', fontWeight: '700', marginBottom: 6 }}
                        >
                          二點寬度校正
                        </Text>
                        <View style={{ flexDirection: 'row', flexWrap: 'wrap' }}>
                          <Pressable
                            onPress={() => {
                              setCalib2On(true);
                              setCalibA(null);
                              setCalibB(null);
                              setMetersPerUnit(null);
                              setCalib4On(false);
                            }}
                            style={{
                              backgroundColor: '#1976d2',
                              paddingVertical: 6,
                              paddingHorizontal: 10,
                              borderRadius: 8,
                              marginRight: 8,
                              marginBottom: 8,
                            }}
                          >
                            <Text style={{ color: '#fff' }}>
                              {calib2On ? '點兩點：進行中…' : '開始點兩點'}
                            </Text>
                          </Pressable>
                          <Pressable
                            onPress={() => applyCalib2(6.1)}
                            style={{
                              backgroundColor: '#2e7d32',
                              paddingVertical: 6,
                              paddingHorizontal: 10,
                              borderRadius: 8,
                              marginRight: 8,
                              marginBottom: 8,
                            }}
                          >
                            <Text style={{ color: '#fff' }}>雙打寬 6.1m</Text>
                          </Pressable>
                          <Pressable
                            onPress={() => applyCalib2(5.18)}
                            style={{
                              backgroundColor: '#00796b',
                              paddingVertical: 6,
                              paddingHorizontal: 10,
                              borderRadius: 8,
                              marginBottom: 8,
                            }}
                          >
                            <Text style={{ color: '#fff' }}>單打寬 5.18m</Text>
                          </Pressable>
                        </View>
                        {!!metersPerUnit && (
                          <Text style={{ color: '#90caf9' }}>
                            二點比例：{metersPerUnit.toFixed(3)} m / unit
                          </Text>
                        )}
                      </View>
                      {/* 錄製控制／清除校正 */}
                      <View style={{ flexDirection: 'row', marginTop: 6 }}>
                        {!recording ? (
                          <Pressable
                            onPress={startRecord}
                            style={{
                              backgroundColor: '#e53935',
                              paddingVertical: 8,
                              paddingHorizontal: 12,
                              borderRadius: 8,
                              marginRight: 8,
                            }}
                          >
                            <Text style={{ color: '#fff' }}>開始錄製</Text>
                          </Pressable>
                        ) : (
                          <Pressable
                            onPress={stopRecordAndSave}
                            style={{
                              backgroundColor: '#8e24aa',
                              paddingVertical: 8,
                              paddingHorizontal: 12,
                              borderRadius: 8,
                              marginRight: 8,
                            }}
                          >
                            <Text style={{ color: '#fff' }}>停止並儲存</Text>
                          </Pressable>
                        )}
                        <Pressable
                          onPress={clearAllCalib}
                          style={{
                            backgroundColor: '#9e9e9e',
                            paddingVertical: 8,
                            paddingHorizontal: 12,
                            borderRadius: 8,
                          }}
                        >
                          <Text style={{ color: '#fff' }}>清除校正</Text>
                        </Pressable>
                      </View>
                    </View>
                  </View>
                </ScrollView>
              </View>
            </View>
          </RotBox>
        </View>
      )}
    </View>
  );
}

// ----------- RangeBar（拉桿） -----------
function clamp(n: number, a: number, b: number) {
  return Math.min(Math.max(n, a), b);
}
function roundStep(v: number, step: number) {
  if (!step || step <= 0) return v;
  return Math.round(v / step) * step;
}
function formatNumber(v: number, decimals = 0) {
  const f = Math.pow(10, decimals);
  return String(Math.round(v * f) / f);
}
function RangeBar({
  label,
  value,
  min,
  max,
  step = 1,
  unit = '',
  hint,
  defaultValue,
  onChange,
}: {
  label: string;
  value: number;
  min: number;
  max: number;
  step?: number;
  unit?: string;
  hint?: string;
  defaultValue?: number;
  onChange: (v: number) => void;
}) {
  const trackRef = React.useRef<View>(null);
  const [trackW, setTrackW] = React.useState(0);

  const pct = max > min ? (value - min) / (max - min) : 0;
  const fillW = Math.round(trackW * pct);

  const onLayoutTrack = (e: any) => {
    setTrackW(Math.floor(e.nativeEvent.layout.width || 0));
  };

  const setFromX = (x: number) => {
    const p = clamp(x / Math.max(1, trackW), 0, 1);
    const raw = min + p * (max - min);
    const stepped = roundStep(raw, step);
    onChange(clamp(stepped, min, max));
  };

  const onStart = (e: any) => {
    const x = e.nativeEvent.locationX;
    setFromX(x);
    return true;
  };
  const onMove = (e: any) => {
    const x = e.nativeEvent.locationX;
    setFromX(x);
  };

  return (
    <View style={{ marginBottom: 10 }}>
      <View
        style={{
          flexDirection: 'row',
          alignItems: 'baseline',
          justifyContent: 'space-between',
          marginBottom: 4,
        }}
      >
        <Text style={{ color: '#fff', fontWeight: '700' }}>{label}</Text>
        <View style={{ flexDirection: 'row', alignItems: 'baseline' }}>
          <Text style={{ color: '#fff', fontSize: 16, fontWeight: '800' }}>
            {formatNumber(value, step < 1 ? 2 : 0)}
          </Text>
          {!!unit && <Text style={{ color: '#bbb', marginLeft: 2 }}>{unit}</Text>}
        </View>
      </View>
      {!!hint && <Text style={{ color: '#9e9e9e', marginBottom: 4 }}>{hint}</Text>}

      <View
        ref={trackRef}
        onLayout={onLayoutTrack}
        style={{
          height: 28,
          borderRadius: 8,
          backgroundColor: '#1f1f1f',
          borderWidth: 1,
          borderColor: '#555',
          overflow: 'hidden',
        }}
      >
        <View style={{ width: fillW, height: '100%', backgroundColor: '#1976d2' }} />
        <View
          style={{ position: 'absolute', inset: 0 }}
          onStartShouldSetResponder={() => true}
          onResponderGrant={onStart}
          onResponderMove={onMove}
        />
      </View>

      <View
        style={{
          marginTop: 6,
          flexDirection: 'row',
          justifyContent: 'space-between',
          alignItems: 'center',
        }}
      >
        <Text style={{ color: '#888' }}>
          {formatNumber(min, step < 1 ? 2 : 0)}{unit} ~ {formatNumber(max, step < 1 ? 2 : 0)}{unit}
        </Text>
        {typeof defaultValue === 'number' && (
          <Pressable
            onPress={() => onChange(clamp(defaultValue, min, max))}
            style={{
              paddingVertical: 4,
              paddingHorizontal: 8,
              borderRadius: 8,
              borderWidth: 1,
              borderColor: '#90caf9',
              backgroundColor: 'rgba(144,202,249,0.15)',
            }}
          >
            <Text style={{ color: '#fff' }}>預設</Text>
          </Pressable>
        )}
      </View>
    </View>
  );
}ezbmt-tracked/src/screens/PairingScreen.tsx
 
import React from 'react';
import { View, Text, Pressable, TextInput, Alert, ScrollView, ActivityIndicator } from 'react-native';
import { useRoute, useNavigation } from '@react-navigation/native';
import { listSessionAttendees, listRounds, upsertRound, getSession, setRoundStatus, upsertRoundCourts } from '../db';
import type { Attendee, RoundRow, RoundMatch } from '../db/supa_club';
import { pairRound, AttendeeLite, Constraints } from '../club/pairing';
import { getPrefs, savePrefs, clearPrefs, type PairingPrefs } from '../lib/pairingPrefs';
import { supa } from '../lib/supabase';
import { getMyClubRole } from '../db';

const C = { bg:'#111', card:'#1e1e1e', border:'#333', text:'#fff', sub:'#bbb', btn:'#1976d2', bad:'#d32f2f' };

export default function PairingScreen() {
const route = useRoute<any>();
const navigation = useNavigation<any>();
const sessionId: string | undefined = route.params?.sessionId;

const [loading, setLoading] = React.useState(true);
const [atts, setAtts] = React.useState<Attendee[]>([]);
const [rounds, setRounds] = React.useState<Array<{ id:string; index_no:number; status?:string|null; matches:any[] }>>([]);

const [sessionDate, setSessionDate] = React.useState<string>('');
const [sessionDefaults, setSessionDefaults] = React.useState<{ courts?: number|null; round_minutes?: number|null }>({});
const [sessionClubId, setSessionClubId] = React.useState<string | null>(null);

const [myRole, setMyRole] = React.useState<string | null>(null);
const canPair = ['owner','admin','scheduler'].includes(String(myRole || ''));

const [courts, setCourts] = React.useState('4');
const [teamSize, setTeamSize] = React.useState<'1'|'2'>('2');
const [roundMinutes, setRoundMinutes] = React.useState('15');
const [partnerCooldown, setPartnerCooldown] = React.useState('1');
const [opponentWindow, setOpponentWindow] = React.useState('1');
const [maxLevelDiffPerPair, setMaxLevelDiffPerPair] = React.useState('5');
const [preferMixed, setPreferMixed] = React.useState(false);
const [restCooldown, setRestCooldown] = React.useState('1'); // 新增：上/下場冷卻輪

const [preview, setPreview] = React.useState<null | { matches: Array<{ teamA:any; teamB:any }>; waiting: any[] }>(null);
const [genBusy, setGenBusy] = React.useState(false);
const [publishBusy, setPublishBusy] = React.useState(false);
const [savingPrefs, setSavingPrefs] = React.useState(false);
const [resettingPrefs, setResettingPrefs] = React.useState(false);

const loadAll = React.useCallback(async () => {
if (!sessionId) return;
setLoading(true);
try {
const sid = sessionId as string;

  try {
    const { data: sRow } = await supa
      .from('sessions')
      .select('id,club_id,date,courts,round_minutes')
      .eq('id', sid)
      .maybeSingle();
    if (sRow) {
      if (sRow.courts != null && Number.isFinite(Number(sRow.courts))) setCourts(String(Number(sRow.courts)));
      if (sRow.round_minutes != null && Number.isFinite(Number(sRow.round_minutes))) setRoundMinutes(String(Number(sRow.round_minutes)));
      setSessionDate(sRow.date || '');
      setSessionDefaults({ courts: sRow.courts ?? null, round_minutes: sRow.round_minutes ?? null });
      setSessionClubId(sRow.club_id || null);
      try {
        const role = sRow.club_id ? await getMyClubRole(sRow.club_id) : null;
        setMyRole(role);
      } catch { setMyRole(null); }
    }
  } catch {}

  try {
    const p = await getPrefs(sid);
    if (p) {
      if (p.courts != null) setCourts(p.courts);
      if (p.teamSize != null) setTeamSize(p.teamSize);
      if (p.roundMinutes != null) setRoundMinutes(p.roundMinutes);
      if (p.partnerCooldown != null) setPartnerCooldown(p.partnerCooldown);
      if (p.opponentWindow != null) setOpponentWindow(p.opponentWindow);
      if (p.maxLevelDiffPerPair != null) setMaxLevelDiffPerPair(p.maxLevelDiffPerPair);
      if (typeof p.preferMixed === 'boolean') setPreferMixed(!!p.preferMixed);
      if (p.restCooldown != null) setRestCooldown(p.restCooldown); // 新增
    }
  } catch {}

  const [a, r] = await Promise.all([listSessionAttendees(sid), listRounds(sid)]);
  setAtts(a);
  setRounds((r || []).map((x: RoundRow & { matches: RoundMatch[] }) => ({
    id: x.id,
    index_no: Number(x.index_no || 0),
    status: (x as any).status ?? null,
    matches: (x as any).matches || [],
  })));
} catch (e:any) {
  Alert.alert('載入失敗', String(e?.message||e));
} finally {
  setLoading(false);
}
}, [sessionId]);

React.useEffect(() => { loadAll(); }, [loadAll]);

if (!sessionId) {
return (
<View style={{ flex:1, backgroundColor:C.bg, alignItems:'center', justifyContent:'center', padding:16 }}>
<Text style={{ color:C.text, fontSize:16 }}>未提供 sessionId</Text>
</View>
);
}
if (loading) {
return (
<View style={{ flex:1, backgroundColor:C.bg, alignItems:'center', justifyContent:'center' }}>
<ActivityIndicator color="#90caf9" />
</View>
);
}

const nowIndex = rounds.length ? Math.max(...rounds.map(r => Number(r.index_no||0))) : 0;

function toLite(a: any) {
return { id: a.buddy_id || a.id, name: a.display_name, level: a.level ?? undefined, gender: (a.gender as any) ?? 'U' };
}

async function genPreview() {
if (!canPair) { Alert.alert('沒有權限','僅 owner/admin/scheduler 可排點'); return; }
setGenBusy(true);
try {
const candidates = atts.map(toLite);
const cons: Constraints = {
courts: Math.max(1, Number(courts||'1')),
teamSize: (teamSize==='1' ? 1 : 2),
partnerCooldown: Math.max(0, Number(partnerCooldown||'0')),
opponentWindow: Math.max(0, Number(opponentWindow||'0')),
maxLevelDiffPerPair: Math.max(0, Number(maxLevelDiffPerPair||'0')),
preferMixedGender: !!preferMixed,
restCooldown: Math.max(0, Number(restCooldown||'0')),  // 新增
};
const prevRounds = rounds.map(r => ({ index_no: Number(r.index_no||0), matches: r.matches || [] }));
const res = pairRound(candidates, cons, prevRounds);
setPreview({ matches: res.matches, waiting: res.waiting });
} catch (e:any) {
Alert.alert('產生失敗', String(e?.message || e));
} finally {
setGenBusy(false);
}
}

async function publish() {
if (!canPair) { Alert.alert('沒有權限','僅 owner/admin/scheduler 可發布'); return; }
if (!preview) {
Alert.alert('提示', '請先產生預覽');
return;
}
setPublishBusy(true);
try {
const sid = sessionId as string;
const start = new Date();
const end = new Date(start.getTime() + Math.max(5, Number(roundMinutes||'15')) * 60 * 1000);

  const payload = {
    index_no: nowIndex + 1,
    start_at: start.toISOString(),
    end_at: end.toISOString(),
    status: 'published' as const,
    matches: preview.matches.map((m, i) => ({
      court_no: i+1,
      team_a: { players: m.teamA.players, avgLevel: m.teamA.avgLevel },
      team_b: { players: m.teamB.players, avgLevel: m.teamB.avgLevel },
    })),
  };
  const newRoundId = await upsertRound(sid, payload);

  try {
    const rows = payload.matches.map((m) => ({
      court_no: m.court_no,
      team_a_ids: (m.team_a?.players || []).map((p:any) => p.id),
      team_b_ids: (m.team_b?.players || []).map((p:any) => p.id),
    }));
    await upsertRoundCourts(newRoundId, rows);
  } catch {}

  try {
    await supa.functions.invoke('send_notify', {
      body: {
        kind: 'event',
        targetId: sid,
        title: `第 ${nowIndex + 1} 輪已發布`,
        body: '請留意看板與場地',
        data: { sessionId: sid, roundId: newRoundId }
      }
    });
  } catch {}

  Alert.alert('已發布', `第 ${nowIndex + 1} 輪已建立`);
  setPreview(null);
  await loadAll();
} catch (e:any) {
  Alert.alert('發布失敗', String(e?.message || e));
} finally {
  setPublishBusy(false);
}
}

const onSavePrefs = async () => {
try {
setSavingPrefs(true);
const prefs: PairingPrefs = {
courts, teamSize, roundMinutes,
partnerCooldown, opponentWindow, maxLevelDiffPerPair,
preferMixed,
restCooldown,   // 新增
};
await savePrefs(sessionId!, prefs);
Alert.alert('已儲存', '已記住這個場次的排點參數');
} catch (e:any) {
Alert.alert('儲存失敗', String(e?.message||e));
} finally {
setSavingPrefs(false);
}
};
const onResetPrefs = async () => {
try {
setResettingPrefs(true);
await clearPrefs(sessionId!);
setCourts(String(Number(sessionDefaults.courts ?? 4)));
setRoundMinutes(String(Number(sessionDefaults.round_minutes ?? 15)));
setTeamSize('2');
setPartnerCooldown('1');
setOpponentWindow('1');
setMaxLevelDiffPerPair('5');
setPreferMixed(false);
setRestCooldown('1');  // 新增
Alert.alert('已還原', '已還原為場次預設（或系統預設）');
} catch (e:any) {
Alert.alert('還原失敗', String(e?.message||e));
} finally {
setResettingPrefs(false);
}
};

const onMarkOngoing = async (roundId: string) => {
if (!canPair) { Alert.alert('沒有權限','僅 owner/admin/scheduler 可切換狀態'); return; }
try { await setRoundStatus(roundId, 'ongoing'); await loadAll(); }
catch (e:any){ Alert.alert('設定失敗', String(e?.message || e)); }
};
const onMarkFinished = async (roundId: string) => {
if (!canPair) { Alert.alert('沒有權限','僅 owner/admin/scheduler 可切換狀態'); return; }
try { await setRoundStatus(roundId, 'finished'); await loadAll(); }
catch (e:any){ Alert.alert('設定失敗', String(e?.message || e)); }
};

function Param({ title, v, setV }: { title:string; v:string; setV:(s:string)=>void }) {
return (
<View style={{ marginRight:8, marginBottom:8 }}>
<Text style={{ color:'#bbb', marginBottom:4 }}>{title}</Text>
<TextInput
value={v}
onChangeText={setV}
placeholderTextColor="#888"
style={{ width: 130, height: 36, borderWidth:1, borderColor:'#444', borderRadius:8, color:'#fff', paddingHorizontal:8, backgroundColor:'#111' }}
/>
</View>
);
}

function Btn({ text, onPress, disabled }: { text:string; onPress:()=>void; disabled?:boolean }) {
return (
<Pressable onPress={onPress} disabled={disabled} style={{ paddingVertical:10, paddingHorizontal:14, borderRadius:8, backgroundColor: disabled ? '#555' : '#1976d2' }}>
<Text style={{ color:'#fff', fontWeight:'700' }}>{text}</Text>
</Pressable>
);
}

const statusLabel = (s?: string|null) =>
s === 'published' ? '已發布' :
s === 'ongoing'  ? '進行中' :
s === 'finished' ? '已結束' : '—';

const statusChipStyle = (s?: string|null) => {
const color =
s === 'published' ? '#1976d2' :
s === 'ongoing'  ? '#2e7d32' :
s === 'finished' ? '#757575' : '#555';
return { borderColor: color, bg: `${color}22`, color };
};

return (
<ScrollView style={{ flex:1, backgroundColor:C.bg }} contentContainerStyle={{ padding:12 }}>
<Text style={{ color:C.text, fontSize:16, fontWeight:'700', marginBottom:8 }}>
社團排點{sessionDate ? `（${sessionDate}）` : ''}
</Text>

  <Text style={{ color:C.sub, marginBottom:6 }}>{`參與者（${atts.length}）`}</Text>

  {/* 參數區 */}
  <View style={{ padding:10, backgroundColor:C.card, borderRadius:10, borderColor:C.border, borderWidth:1, marginTop:10 }}>
    <Text style={{ color:C.text, fontWeight:'700', marginBottom:8 }}>參數</Text>
    <View style={{ flexDirection:'row', flexWrap:'wrap', opacity: canPair ? 1 : 0.5 }}>
      <Param title="球場數" v={courts} setV={canPair?setCourts:()=>{}} />
      <Param title="每輪(分)" v={roundMinutes} setV={canPair?setRoundMinutes:()=>{}} />
      <Param title="單打(1)/雙打(2)" v={teamSize} setV={canPair?(s)=>setTeamSize((s==='1'?'1':'2')):()=>{}} />
      <Param title="上/下場冷卻輪" v={restCooldown} setV={canPair?setRestCooldown:()=>{}} />{/* 新增 */}
      <Param title="搭檔冷卻輪" v={partnerCooldown} setV={canPair?setPartnerCooldown:()=>{}} />
      <Param title="對手避免(輪)" v={opponentWindow} setV={canPair?setOpponentWindow:()=>{}} />
      <Param title="同隊等級差上限" v={maxLevelDiffPerPair} setV={canPair?setMaxLevelDiffPerPair:()=>{}} />
    </View>

    <View style={{ flexDirection:'row', flexWrap:'wrap', marginTop:8, opacity: canPair ? 1 : 0.5 }}>
      <Pressable onPress={canPair?()=>setPreferMixed(v=>!v):()=>{}} style={{ padding:8, borderRadius:8, borderWidth:1, borderColor:C.border, marginRight:8 }}>
        <Text style={{ color:'#90caf9' }}>{preferMixed ? '混雙偏好：開' : '混雙偏好：關'}</Text>
      </Pressable>
      {canPair && (
        <>
          <Pressable onPress={onSavePrefs} style={{ padding:8, borderRadius:8, backgroundColor:savingPrefs?'#555':'#1976d2', marginRight:8 }} disabled={savingPrefs}>
            <Text style={{ color:'#fff' }}>{savingPrefs ? '儲存中…' : '儲存參數'}</Text>
          </Pressable>
          <Pressable onPress={onResetPrefs} style={{ padding:8, borderRadius:8, backgroundColor:resettingPrefs?'#555':'#455a64' }} disabled={resettingPrefs}>
            <Text style={{ color:'#fff' }}>{resettingPrefs ? '還原中…' : '還原預設'}</Text>
          </Pressable>
        </>
      )}
    </View>
  </View>

  {/* 動作 */}
  <View style={{ flexDirection:'row', marginTop:10 }}>
    <Btn text={genBusy ? '產生中…' : '產生預覽'} onPress={genPreview} disabled={genBusy || !canPair} />
    <View style={{ width:8 }} />
    <Btn text={publishBusy ? '發布中…' : `發布第${nowIndex+1}輪`} onPress={publish} disabled={!preview || publishBusy || !canPair} />
  </View>

  {/* 預覽、歷史輪（省略，沿用你現有版面） */}
  {/* ... 保持原內容 ... */}
</ScrollView>
);
}ezbmt-tracked/src/screens/MatchesScreen.tsx
 
import React from 'react';
import { View, Text, FlatList, Pressable, TextInput, Alert, Platform, ActionSheetIOS } from 'react-native';
import { useRoute, useNavigation, useFocusEffect } from '@react-navigation/native';
import {
insertMatch,
listMatches,
updateMatchRules,
setMatchRecordMode,
getMatchPlayers,
deleteMatch,
hasMatchRallies,
openDB,
getMyEventRole,
listEvents, // sqlite fallback 會用到
} from '../db';
import { useRecordsStore } from '../store/records';
import MatchRulesSheet from '../components/MatchRulesSheet';
import { BACKEND } from '../lib/backend';
import { supa } from '../lib/supabase';

type MatchRow = {
id: string;
type: 'MS' | 'WS' | 'MD' | 'WD' | 'XD';
court_no: string | null;
rules_json: string | null;
record_mode?: 'tap' | 'route' | null;
};

type PlayerMap = Record<string, { home: [string|null, string|null]; away: [string|null, string|null] }>;
type GameSum = { i: number; home: number; away: number; winner: 0|1|null };
type GamesMap = Record<string, GameSum[]>;
type MemberRole = 'owner'|'coach'|'recorder'|'player'|'viewer';

const TYPE_OPTIONS: Array<{ label: string; value: MatchRow['type'] }> = [
{ label: 'MS', value: 'MS' },
{ label: 'WS', value: 'WS' },
{ label: 'MD', value: 'MD' },
{ label: 'WD', value: 'WD' },
{ label: 'XD', value: 'XD' },
];

export default function MatchesScreen() {
const route = useRoute<any>();
const navigation = useNavigation<any>();
const eventId = route.params?.eventId as string;

const [items, setItems] = React.useState<MatchRow[]>([]);
const [type, setType] = React.useState<MatchRow['type']>('MD');
const [court, setCourt] = React.useState('');
const [playersMap, setPlayersMap] = React.useState<PlayerMap>({});
const [gamesMap, setGamesMap] = React.useState<GamesMap>({});
const [q, setQ] = React.useState(''); // 搜尋關鍵字

const [sheetOpen, setSheetOpen] = React.useState(false);
const [editingMatchId, setEditingMatchId] = React.useState<string | null>(null);
const [editInitial, setEditInitial] = React.useState({ bestOf: 3, pointsToWin: 21, deuce: true, cap: 30 as number | null });

// 最大管理者
const [isAdmin, setIsAdmin] = React.useState<boolean>(false);
// 取得是否為最大管理者（supabase 模式才檢查）
useFocusEffect(
React.useCallback(() => {
let mounted = true;
(async () => {
if (BACKEND !== 'supabase') {
if (mounted) setIsAdmin(false);
return;
}
try {
const { data, error } = await supa.rpc('is_app_admin');
if (mounted) setIsAdmin(!error && !!data);
} catch {
if (mounted) setIsAdmin(false);
}
})();
return () => { mounted = false; };
}, [])
);

// 角色
const [eventRole, setEventRole] = React.useState<MemberRole | null>(null);
const [matchRoleMap, setMatchRoleMap] = React.useState<Record<string, MemberRole>>({});

// 賽事名稱
const [eventName, setEventName] = React.useState<string>('');

const setCurrentMatch = useRecordsStore(s => s.setCurrentMatch);

// 讀取場次清單
const load = React.useCallback(async () => {
try {
const rows = await listMatches(eventId);
setItems(rows as any);
} catch (e: any) {
Alert.alert('載入失敗', String(e?.message || e));
}
}, [eventId]);

React.useEffect(() => { load(); }, [load]);
useFocusEffect(React.useCallback(() => { load(); }, [load]));

// 讀取事件角色（event_members）
React.useEffect(() => {
let active = true;
(async () => {
try {
const role = await getMyEventRole(eventId);
if (active) setEventRole(role as MemberRole | null);
} catch {
if (active) setEventRole(null);
}
})();
return () => { active = false; };
}, [eventId]);

// 讀取賽事名稱
React.useEffect(() => {
let cancelled = false;
(async () => {
try {
if (!eventId) { if (!cancelled) setEventName(''); return; }
if (BACKEND === 'supabase') {
const { data, error } = await supa
.from('events')
.select('name')
.eq('id', eventId)
.single();
if (!cancelled) setEventName(error ? '' : (data?.name || ''));
} else {
// sqlite fallback：從全部 events 找
const all = await listEvents();
const hit = all.find(e => e.id === eventId);
if (!cancelled) setEventName(hit?.name || '');
}
} catch {
if (!cancelled) setEventName('');
}
})();
return () => { cancelled = true; };
}, [eventId]);

// 讀取本人在各場次的角色（一次撈）
React.useEffect(() => {
let cancelled = false;
(async () => {
try {
const ids = items.map(m => m.id);
if (!ids.length) {
if (!cancelled) setMatchRoleMap({});
return;
}
const { data: me } = await supa.auth.getUser();
const uid = me?.user?.id;
if (!uid) {
if (!cancelled) setMatchRoleMap({});
return;
}
// 直接撈這個使用者在這些 match 的角色
const { data, error } = await supa
.from('match_members')
.select('match_id,role')
.eq('user_id', uid)
.in('match_id', ids as any);
if (error) throw error;
const map: Record<string, MemberRole> = {};
(data || []).forEach((r: any) => {
const role = String(r.role) as MemberRole;
map[r.match_id] = role;
});
if (!cancelled) setMatchRoleMap(map);
} catch {
if (!cancelled) setMatchRoleMap({});
}
})();
return () => { cancelled = true; };
}, [items]);

// 讀球員名字（顯示）
React.useEffect(() => {
let cancelled = false;
(async () => {
const map: PlayerMap = {};
for (const m of items) {
try {
const rows = await getMatchPlayers(m.id);
const home: [string|null, string|null] = [null, null];
const away: [string|null, string|null] = [null, null];
(rows || []).forEach((r: any) => {
if (r.side === 'home') home[r.idx] = r.name ?? null;
else if (r.side === 'away') away[r.idx] = r.name ?? null;
});
map[m.id] = { home, away };
} catch {}
}
if (!cancelled) setPlayersMap(map);
})();
return () => { cancelled = true; };
}, [items]);

// 讀各局分數（games）
React.useEffect(() => {
let cancelled = false;
(async () => {
const gmap: GamesMap = {};
for (const m of items) {
try {
let rows: any[] = [];
if (BACKEND === 'supabase') {
const { data, error } = await supa
.from('games')
.select('index_no,home_score,away_score,winner_team')
.eq('match_id', m.id)
.order('index_no', { ascending: true });
if (error) throw error;
rows = data || [];
} else {
const db = await openDB();
const [res] = await db.executeSql(
'SELECT index_no,home_score,away_score,winner_team FROM games WHERE match_id=? ORDER BY index_no ASC',
[m.id]
);
rows = Array.from({ length: res.rows.length }, (_, i) => res.rows.item(i));
}
gmap[m.id] = rows.map(r => ({
i: Number(r.index_no || 0),
home: Number(r.home_score || 0),
away: Number(r.away_score || 0),
winner: (r.winner_team == null ? null : Number(r.winner_team)) as 0|1|null,
}));
} catch {
gmap[m.id] = [];
}
}
if (!cancelled) setGamesMap(gmap);
})();
return () => { cancelled = true; };
}, [items]);

// 新增場次（事件層級權限）
const canAddMatch = ['owner','coach','recorder'].includes(String(eventRole || '') as MemberRole);
const add = async () => {
const t = type.trim().toUpperCase() as MatchRow['type'];
if (!t) return;
try {
if (BACKEND === 'supabase') {
await (require('../db') as any).createMatchRPC({
event_id: eventId,
type: t,
court_no: court.trim() || undefined,
rules: { bestOf: 3, pointsToWin: 21, deuce: true, cap: 30 },
});
} else {
const id = Math.random().toString(36).slice(2);
await insertMatch({
id,
event_id: eventId,
type: t,
court_no: court.trim() || undefined,
rules_json: JSON.stringify({ bestOf: 3, pointsToWin: 21, deuce: true, cap: 30 }),
} as any);
}
await load();
setCourt('');
} catch (e: any) {
Alert.alert('新增失敗', String(e?.message || e));
}
};

const openTypePicker = () => {
if (Platform.OS === 'ios') {
const options = ['取消', ...TYPE_OPTIONS.map(o => o.label)];
ActionSheetIOS.showActionSheetWithOptions(
{ options, cancelButtonIndex: 0 },
(idx) => {
if (idx && idx > 0) setType(TYPE_OPTIONS[idx - 1].value);
}
);
} else {
Alert.alert(
'選擇類型',
'',
[
...TYPE_OPTIONS.map(o => ({ text: o.label, onPress: () => setType(o.value) })),
{ text: '取消', style: 'cancel' },
],
{ cancelable: true }
);
}
};

const choose = (id: string) => {
setCurrentMatch(id);
navigation.navigate('Record');
};

function parseRules(json: string | null) {
if (!json) return { bestOf: 3, pointsToWin: 21, deuce: true, cap: 30 as number | null };
try {
const r = JSON.parse(json);
return {
bestOf: r.bestOf ?? 3,
pointsToWin: r.pointsToWin ?? r.pointsPerGame ?? 21,
deuce: r.deuce ?? (r.winBy ? r.winBy > 1 : true),
cap: r.cap ?? 30,
};
} catch {
return { bestOf: 3, pointsToWin: 21, deuce: true, cap: 30 as number | null };
}
}

const editRules = (item: MatchRow) => {
const r = parseRules(item.rules_json);
setEditInitial(r);
setEditingMatchId(item.id);
setSheetOpen(true);
};

const saveRules = async (rules: { bestOf: number; pointsToWin: number; deuce: boolean; cap?: number | null }) => {
if (!editingMatchId) return;
try {
await updateMatchRules(editingMatchId, JSON.stringify(rules));
setSheetOpen(false);
setEditingMatchId(null);
load();
} catch (e: any) {
Alert.alert('儲存失敗', String(e?.message || e));
}
};

const setMode = async (id: string, mode: 'tap' | 'route') => {
try {
await setMatchRecordMode(id, mode);
load();
} catch (e: any) {
Alert.alert('切換失敗', String(e?.message || e));
}
};

const playerSummary = (m: MatchRow) => {
const p = playersMap[m.id];
if (!p) return null;
const isDouble = m.type.endsWith('D');
const left = isDouble ?  `${p.home[0] ?? '—'} ${p.home[1] ?? '—'}`  :  `${p.home[0] ?? '—'}` ;
const right = isDouble ?  `${p.away[0] ?? '—'} ${p.away[1] ?? '—'}`  :  `${p.away[0] ?? '—'}` ;
const hasAny = [p.home[0], p.home[1], p.away[0], p.away[1]].some(v => v && String(v).trim().length > 0);
return hasAny ?  `${left}  VS  ${right}`  : null;
};

// 搜尋
const norm = (s: any) => String(s ?? '').toLowerCase().trim();
const filtered = React.useMemo(() => {
const kw = norm(q);
if (!kw) return items;
const tokens = kw.split(/\s+/).filter(Boolean);
return items.filter(m => {
const p = playersMap[m.id] || { home:[null,null], away:[null,null] };
const hay = [
m.type,
m.court_no ?? '',
p.home[0] ?? '', p.home[1] ?? '',
p.away[0] ?? '', p.away[1] ?? ''
].map(norm).join(' ');
return tokens.every(t => hay.includes(t));
});
}, [items, q, playersMap]);

// 取得使用者對某場次的角色（若沒有就 fallback eventRole）
const roleOfMatch = (matchId: string): MemberRole => {
const r = matchRoleMap[matchId] || eventRole || 'viewer';
return r as MemberRole;
// 若你不想 fallback 賽事角色，請改成：
// return (matchRoleMap[matchId] as MemberRole) || 'viewer';
};

// 權限判斷
const canSelectAsRecording = (r: MemberRole) => r !== 'viewer';
const canEditRules = (r: MemberRole) => ['owner','coach','recorder'].includes(r);
const canEditPlayers = (r: MemberRole) => ['owner','coach','recorder'].includes(r);
const canSeeLive = (_r: MemberRole) => true;
const canSeeChat = (_r: MemberRole) => true;
const canSeeMedia = (_r: MemberRole) => true; // viewer 可看，新增限制在 MediaScreen 內做
const canManageMembers = (r: MemberRole) => ['owner','coach'].includes(r);
const canDeleteMatch = (r: MemberRole) => r === 'owner';
const canChangeMode = (r: MemberRole) => ['owner','coach','recorder'].includes(r);

const onDeleteMatch = async (m: MatchRow) => {
try {
const has = await hasMatchRallies(m.id);
if (has) {
Alert.alert('刪除場次', '此場次已有記錄資料，確定要刪除？', [
{ text: '取消', style: 'cancel' },
{ text: '刪除', style: 'destructive', onPress: async () => {
try { await deleteMatch(m.id); await load(); }
catch(e:any){ Alert.alert('刪除失敗', String(e?.message || e)); }
} },
]);
} else {
await deleteMatch(m.id);
await load();
}
} catch (e:any) {
Alert.alert('刪除失敗', String(e?.message || e));
}
};

const renderGames = (m: MatchRow) => {
const arr = gamesMap[m.id] || [];
if (arr.length === 0) return null;
return (
<View style={{ marginTop: 6, flexDirection:'row', flexWrap:'wrap' }}>
{arr.map(g => {
const tag = `G${g.i} ${g.home}-${g.away}`;
const winClr = g.winner === 0 ? '#1976d2' : g.winner === 1 ? '#d32f2f' : '#999';
return (
<View key={m.id + '-g' + g.i} style={{ paddingVertical:4, paddingHorizontal:8, borderRadius:12, borderWidth:1, borderColor:'#ccc', marginRight:6, marginBottom:6, backgroundColor:'#f7f7f7' }}>
<Text style={{ color:'#333' }}>
{tag}{g.winner!=null ? (g.winner===0 ? '（主）' : '（客）') : ''}
</Text>
<View style={{ position:'absolute', right:-2, top:-2, width:8, height:8, borderRadius:4, backgroundColor: winClr }} />
</View>
);
})}
</View>
);
};

const renderItem = ({ item }: { item: MatchRow }) => {
const summary = playerSummary(item);
const role = roleOfMatch(item.id);

return (
  <View style={{ padding: 12, borderWidth: 1, borderColor: '#eee', borderRadius: 8, marginBottom: 8 }}>
    <Text style={{ fontSize: 16, fontWeight: '700' }}>
      {item.type} 場地 {item.court_no || '-'}
    </Text>
    {summary && <Text style={{ marginTop: 6, marginBottom: 2, color: '#333' }}>{summary}</Text>}

    {/* 各局分數 + 勝方 */}
    {renderGames(item)}

    <View style={{ flexDirection: 'row', marginTop: 8, flexWrap: 'wrap', alignItems: 'center' }}>
      {canSelectAsRecording(role) && (
        <Pressable onPress={() => choose(item.id)} style={{ padding: 10, backgroundColor: '#2e7d32', borderRadius: 8, marginRight: 6, marginBottom: 6 }}>
          <Text style={{ color: '#fff' }}>選取為記錄中</Text>
        </Pressable>
      )}

      {canEditRules(role) && (
        <Pressable onPress={() => editRules(item)} style={{ padding: 10, backgroundColor: '#616161', borderRadius: 8, marginRight: 6, marginBottom: 6 }}>
          <Text style={{ color: '#fff' }}>規則</Text>
        </Pressable>
      )}

      {canEditPlayers(role) && (
        <Pressable onPress={() => navigation.navigate('PlayerSetup', { matchId: item.id })} style={{ padding: 10, backgroundColor: '#00897b', borderRadius: 8, marginRight: 6, marginBottom: 6 }}>
          <Text style={{ color: '#fff' }}>球員設定</Text>
        </Pressable>
      )}

      {canSeeLive(role) && (
        <Pressable onPress={() => navigation.navigate('Live', { matchId: item.id })} style={{ padding: 10, backgroundColor: '#5d4037', borderRadius: 8, marginRight: 6, marginBottom: 6 }}>
          <Text style={{ color: '#fff' }}>即時</Text>
        </Pressable>
      )}

      {canSeeChat(role) && (
        <Pressable onPress={() => navigation.navigate('Chat', { matchId: item.id })} style={{ padding: 10, backgroundColor: '#7b1fa2', borderRadius: 8, marginRight: 6, marginBottom: 6 }}>
          <Text style={{ color: '#fff' }}>聊天</Text>
        </Pressable>
      )}

      {canSeeMedia(role) && (
        <Pressable onPress={() => navigation.navigate('Media', { matchId: item.id, canEdit: role !== 'viewer' })} style={{ padding: 10, backgroundColor: '#f57c00', borderRadius: 8, marginRight: 6, marginBottom: 6 }}>
          <Text style={{ color: '#fff' }}>媒體</Text>
        </Pressable>
      )}

      {canManageMembers(role) && (
        <Pressable onPress={() => navigation.navigate('MatchMembers', { matchId: item.id })} style={{ padding: 10, backgroundColor: '#3949ab', borderRadius: 8, marginRight: 6, marginBottom: 6 }}>
          <Text style={{ color: '#fff' }}>成員</Text>
        </Pressable>
      )}

      {isAdmin && (
        <Pressable onPress={() => navigation.navigate('SpeedCam', { matchId: item.id })} style={{ padding: 10, backgroundColor: '#000', borderRadius: 8, marginRight: 6, marginBottom: 6 }}>
          <Text style={{ color: '#fff' }}>測速</Text>
        </Pressable>
      )}

      {canDeleteMatch(role) && (
        <Pressable onPress={() => onDeleteMatch(item)} style={{ padding: 10, backgroundColor: '#d32f2f', borderRadius: 8, marginRight: 6, marginBottom: 6 }}>
          <Text style={{ color: '#fff' }}>刪除</Text>
        </Pressable>
      )}
    </View>

    {canChangeMode(role) && (
      <View style={{ flexDirection: 'row', marginTop: 6 }}>
        <Pressable
          onPress={() => setMode(item.id, 'tap')}
          style={{ paddingVertical: 8, paddingHorizontal: 10, borderWidth: 1, borderColor: item.record_mode === 'tap' ? '#1976d2' : '#ccc', borderRadius: 8, marginRight: 6 }}
        >
          <Text style={{ color: item.record_mode === 'tap' ? '#1976d2' : '#444' }}>點擊模式</Text>
        </Pressable>
        <Pressable
          onPress={() => setMode(item.id, 'route')}
          style={{ paddingVertical: 8, paddingHorizontal: 10, borderWidth: 1, borderColor: item.record_mode === 'route' ? '#1976d2' : '#ccc', borderRadius: 8 }}
        >
          <Text style={{ color: item.record_mode === 'route' ? '#1976d2' : '#444' }}>線路模式</Text>
        </Pressable>
      </View>
    )}
  </View>
);
};

return (
<View style={{ flex: 1, padding: 12 }}>
{/* 頂部工具列：回賽事 + 類型 + 場地 + 新增（新增：依事件角色顯示） */}
<View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 6, flexWrap: 'wrap' }}>
<Pressable
onPress={() => navigation.navigate('Events')}
style={{ paddingVertical: 8, paddingHorizontal: 12, backgroundColor: '#455a64', borderRadius: 8, marginRight: 8 }}
>
<Text style={{ color: '#fff' }}>賽事</Text>
</Pressable>

    {canAddMatch && (
      <>
        <Pressable
          onPress={openTypePicker}
          style={{ paddingVertical: 8, paddingHorizontal: 12, borderWidth: 1, borderColor: '#ccc', borderRadius: 8, marginRight: 8 }}
        >
          <Text>類型：{type}</Text>
        </Pressable>
        <TextInput
          value={court}
          onChangeText={setCourt}
          placeholderTextColor="#888"
          placeholder="場地號 時間(可空)"
          style={{ width: 140, height: 40, borderWidth: 1, borderColor: '#ccc', borderRadius: 8, paddingHorizontal: 10, marginRight: 8 }}
          returnKeyType="done"
        />
        <Pressable onPress={add} style={{ backgroundColor: '#1976d2', paddingHorizontal: 14, height: 40, borderRadius: 8, justifyContent: 'center' }}>
          <Text style={{ color: '#fff' }}>新增</Text>
        </Pressable>
      </>
    )}
  </View>

  {/* 浮動式：左側賽事名稱 + 右側搜尋 */}
  <View style={{ flexDirection:'row', alignItems:'center', justifyContent:'space-between', marginBottom: 10 }}>
    <Text numberOfLines={1} style={{ color:'#333', fontSize:16, flexShrink:1, marginRight: 10 }}>
      {eventName || '-'}
    </Text>
    <View style={{
      width: 180,
      backgroundColor: '#fff',
      borderRadius: 10,
      paddingHorizontal: 10,
      paddingVertical: 8,
      borderWidth: 1,
      borderColor: '#e0e0e0',
      shadowColor: '#000',
      shadowOpacity: 0.08,
      shadowOffset: { width: 0, height: 4 },
      shadowRadius: 10,
      elevation: 2,
    }}>
      <TextInput
        value={q}
        onChangeText={setQ}
        placeholderTextColor="#888"
        placeholder="搜尋類型/場地/球員（可多關鍵字）"
        style={{ height: 24 }}
        returnKeyType="search"
      />
    </View>
  </View>

  <FlatList data={filtered} keyExtractor={(i) => i.id} renderItem={renderItem} />

  <MatchRulesSheet
    visible={sheetOpen}
    initial={editInitial}
    onClose={() => { setSheetOpen(false); setEditingMatchId(null); }}
    onSave={saveRules}
  />
</View>
);
}ezbmt-tracked/src/screens/AuthScreen.tsx
 
 import React from 'react'; 
 import { View, Text, TextInput, Pressable, Alert, Image, SafeAreaView, KeyboardAvoidingView, Platform, ScrollView, ActivityIndicator, StatusBar, } from 'react-native'; 
 import { supa, getCurrentUser } from '../lib/supabase';
 import AsyncStorage from '@react-native-async-storage/async-storage';
const ACTION_IMG = require('../images/action.png'); // 確認路徑

export default function AuthScreen({ navigation }: any) {
const [email, setEmail] = React.useState('');
const [password, setPassword] = React.useState('');
const [busy, setBusy] = React.useState(false);
const [mode, setMode] = React.useState<'signin' | 'signup'>('signin');

React.useEffect(() => {
(async () => {
const u = await getCurrentUser();
if (u) navigation.replace('Home');
})();
}, [navigation]);

const submit = async () => {
const addr = (email ?? '').trim();
const pwd = password;
if (!addr || !pwd) return;
setBusy(true);
try {
// 和 Supabase 後台 Additional Redirect URLs 對應的 Deep Link
const redirectTo = Platform.select({
ios: 'ezbmt://auth-callback',
android: 'ezbmt://auth-callback',
default: 'ezbmt://auth-callback',
}) as string;

  if (mode === 'signin') {
    const { error } = await supa.auth.signInWithPassword({ email: addr, password: pwd });
    if (error) throw error;
  } else {
    const { error } = await supa.auth.signUp({
      email: addr,
      password: pwd,
      options: { emailRedirectTo: redirectTo },
    });
    if (error) throw error;
    Alert.alert('已送出確認信', '請到信箱點擊驗證連結完成註冊');
  }
  navigation.replace('Home');
} catch (e: any) {
  Alert.alert('失敗', String(e?.message || e));
} finally {
  setBusy(false);
}
};

return (
<SafeAreaView style={{ flex: 1, backgroundColor: '#f2f5f6' }}>
<StatusBar barStyle={Platform.OS === 'ios' ? 'dark-content' : 'default'} />
<KeyboardAvoidingView
style={{ flex: 1 }}
behavior={Platform.OS === 'ios' ? 'padding' : undefined}
keyboardVerticalOffset={Platform.OS === 'ios' ? 16 : 0}
>
<ScrollView
contentContainerStyle={{ flexGrow: 1, padding: 16, justifyContent: 'center' }}
keyboardShouldPersistTaps="handled"
>
<View
style={{
backgroundColor: '#fff',
borderRadius: 18,
paddingTop: 20,
paddingBottom: 24,
paddingHorizontal: 16,
shadowColor: '#000',
shadowOpacity: 0.08,
shadowOffset: { width: 0, height: 4 },
shadowRadius: 12,
elevation: 2,
}}
>
<Text
style={{
fontSize: 20,
fontWeight: '800',
color: '#1B5E20',
textAlign: 'center',
marginBottom: 10,
}}
>
LBF能力有限 羽球分析平台
</Text>

        <Image
          source={ACTION_IMG}
          resizeMode="contain"
          style={{ width: '100%', height: 90, marginBottom: 14 }}
        />

        <View style={{ height: 1, backgroundColor: '#E9ECEF', marginBottom: 16 }} />

        <Text style={{ marginBottom: 6, color: '#333', fontSize: 16 }}>帳號：</Text>
        <TextInput
          placeholder="Email"
          autoCapitalize="none"
          keyboardType="email-address"
          value={email}
          onChangeText={setEmail}
          returnKeyType="next"
          style={{
            backgroundColor: '#f6f7f8',
            borderWidth: 1,
            borderColor: '#E0E0E0',
            borderRadius: 14,
            paddingHorizontal: 14,
            paddingVertical: 12,
            marginBottom: 16,
          }}
        />

        <Text style={{ marginBottom: 6, color: '#333', fontSize: 16 }}>密碼：</Text>
        <TextInput
          placeholder="請輸入密碼"
          secureTextEntry
          value={password}
          onChangeText={setPassword}
          returnKeyType="done"
          onSubmitEditing={!busy ? submit : undefined}
          style={{
            backgroundColor: '#f6f7f8',
            borderWidth: 1,
            borderColor: '#E0E0E0',
            borderRadius: 14,
            paddingHorizontal: 14,
            paddingVertical: 12,
            marginBottom: 24,
          }}
        />

        <Pressable
          disabled={busy}
          onPress={submit}
          style={{
            alignSelf: 'center',
            width: '86%',
            backgroundColor: '#0E8F64',
            borderRadius: 22,
            paddingVertical: 14,
            alignItems: 'center',
            opacity: busy ? 0.7 : 1,
          }}
        >
          {busy ? (
            <ActivityIndicator color="#fff" />
          ) : (
            <Text style={{ color: '#fff', fontWeight: '800', letterSpacing: 1 }}>
              {mode === 'signin' ? '登入' : '註冊'}
            </Text>
          )}
        </Pressable>

        <Pressable
          onPress={() => setMode((m) => (m === 'signin' ? 'signup' : 'signin'))}
          style={{ marginTop: 14, alignSelf: 'center' }}
        >
          <Text style={{ color: '#1976d2' }}>
            {mode === 'signin' ? '沒有帳號？前往註冊' : '已有帳號？前往登入'}
          </Text>
        </Pressable>
      </View>
    </ScrollView>
  </KeyboardAvoidingView>
</SafeAreaView>
);
}ezbmt-tracked/src/screens/EventsScreen.tsx
 
import React from 'react';
import {
View,
Text,
FlatList,
TextInput,
Pressable,
Alert,
KeyboardAvoidingView,
Platform,
} from 'react-native';
import { useNavigation, useFocusEffect } from '@react-navigation/native';
import { BACKEND } from '../lib/backend';
import {
listEvents,
insertEvent,
listMyEvents,
createEventRPC,
hasEventMatches,
deleteEvent,
} from '../db';
import { getCurrentUser, supa } from '../lib/supabase';
import { useHeaderHeight } from '@react-navigation/elements';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

type MemberRole = 'owner'|'coach'|'recorder'|'player'|'viewer' | null;

export default function EventsScreen() {
const nav = useNavigation<any>();
const [items, setItems] = React.useState<Array<{ id: string; name: string }>>([]);
const [name, setName] = React.useState('');
const [myName, setMyName] = React.useState<string>('');
const [q, setQ] = React.useState(''); // 搜尋關鍵字

// eventId => 是否有場次（true=有，因此不顯示刪除鈕）
const [hasMap, setHasMap] = React.useState<Record<string, boolean>>({});

// eventId => 我在該賽事的角色（owner/coach/…）
const [roleMap, setRoleMap] = React.useState<Record<string, MemberRole>>({});

// 最大管理者
const [isAdmin, setIsAdmin] = React.useState<boolean>(false);

const headerHeight = useHeaderHeight();
const insets = useSafeAreaInsets();
const INPUT_BAR_H = 44;

const load = React.useCallback(async () => {
try {
if (BACKEND === 'supabase') {
const rows = await listMyEvents();
setItems(rows);
} else {
setItems(await listEvents());
}
} catch (e: any) {
Alert.alert('載入失敗', String(e?.message || e));
}
}, []);

useFocusEffect(
React.useCallback(() => {
let active = true;
(async () => {
if (BACKEND === 'supabase') {
const u = await getCurrentUser();
if (!u && active) {
// @ts-ignore
nav.navigate('Auth');
return;
}
try {
if (u && active) {
const { data } = await supa.from('profiles').select('name').eq('id', u.id).single();
if (active) setMyName((data?.name || '').trim());
}
} catch {
if (active) setMyName('');
}
}
if (active) load();
})();
return () => {
active = false;
};
}, [load, nav]),
);

// 依 items 批次查是否有場次（有場次者隱藏刪除鈕）
React.useEffect(() => {
let cancelled = false;
(async () => {
if (!items.length) {
if (!cancelled) setHasMap({});
return;
}
const entries: Array<[string, boolean]> = [];
for (const it of items) {
try {
const has = await hasEventMatches(it.id);
entries.push([it.id, !!has]);
} catch {
// 若 RLS/網路錯誤，保守起見視為「有場次」，隱藏刪除鈕
entries.push([it.id, true]);
}
}
if (!cancelled) setHasMap(Object.fromEntries(entries));
})();
return () => {
cancelled = true;
};
}, [items]);

// 批次查詢我在各賽事的角色（只在 supabase 模式下執行）
React.useEffect(() => {
if (BACKEND !== 'supabase') {
setRoleMap({});
return;
}
let cancelled = false;
(async () => {
try {
if (!items.length) {
if (!cancelled) setRoleMap({});
return;
}
const { data: me } = await supa.auth.getUser();
const uid = me?.user?.id;
if (!uid) {
if (!cancelled) setRoleMap({});
return;
}
const ids = items.map(i => i.id);
const { data, error } = await supa
.from('event_members')
.select('event_id,role')
.eq('user_id', uid)
.in('event_id', ids as any);
if (error) throw error;
const map: Record<string, MemberRole> = {};
(data || []).forEach((r: any) => {
map[r.event_id] = (String(r.role) as MemberRole) || null;
});
if (!cancelled) setRoleMap(map);
} catch {
if (!cancelled) setRoleMap({});
}
})();
return () => { cancelled = true; };
}, [items]);

// 取得是否為最大管理者（supabase 模式才檢查）
useFocusEffect(
React.useCallback(() => {
let mounted = true;
(async () => {
if (BACKEND !== 'supabase') {
if (mounted) setIsAdmin(false);
return;
}
try {
const { data, error } = await supa.rpc('is_app_admin');
if (mounted) setIsAdmin(!error && !!data);
} catch {
if (mounted) setIsAdmin(false);
}
})();
return () => { mounted = false; };
}, [])
);

const add = async () => {
const nm = name.trim();
if (!nm) return;
try {
if (BACKEND === 'supabase') {
await createEventRPC({ name: nm });
} else {
const id = Math.random().toString(36).slice(2);
await insertEvent({ id, name: nm } as any);
}
setName('');
load();
} catch (e: any) {
Alert.alert('新增失敗', String(e?.message || e));
}
};

const onDeleteEvent = async (eventId: string) => {
try {
// 再保險一次（就算 hasMap 有值，也以實際狀態為準）
const has = await hasEventMatches(eventId);
if (has) {
Alert.alert('無法刪除', '此賽事已有場次資料，不可刪除');
return;
}
Alert.alert('刪除賽事', '確定要刪除此賽事？', [
{ text: '取消', style: 'cancel' },
{
text: '刪除',
style: 'destructive',
onPress: async () => {
try {
await deleteEvent(eventId);
await load();
} catch (e: any) {
Alert.alert('刪除失敗', String(e?.message || e));
}
},
},
]);
} catch (e: any) {
Alert.alert('刪除失敗', String(e?.message || e));
}
};

// 標準化 + 多關鍵字搜尋
const norm = (s: any) => String(s ?? '').toLowerCase().trim();
const filtered = React.useMemo(() => {
const kw = norm(q);
if (!kw) return items;
const tokens = kw.split(/\s+/).filter(Boolean);
return items.filter((it) => {
const hay = norm(it.name);
return tokens.every((t) => hay.includes(t));
});
}, [items, q]);

const renderItem = ({ item }: { item: { id: string; name: string } }) => {
const has = !!hasMap[item.id]; // true=有場次，不顯示刪除
const myRole = roleMap[item.id] || null;
const canSeeMembers = (myRole === 'owner' || myRole === 'coach');

return (
  <View
    style={{
      padding: 12,
      borderWidth: 1,
      borderColor: '#eee',
      borderRadius: 8,
      marginBottom: 8,
    }}
  >
    <Pressable onPress={() => nav.navigate('Matches', { eventId: item.id })}>
      <Text style={{ fontSize: 16 }}>{item.name}</Text>
      <Text style={{ color: '#666', marginTop: 4 }}>點擊進入場次管理</Text>
    </Pressable>
    <View style={{ flexDirection: 'row', marginTop: 8 }}>
      {canSeeMembers && (
        <Pressable
          onPress={() => nav.navigate('EventMembers', { eventId: item.id })}
          style={{
            paddingVertical: 6,
            paddingHorizontal: 10,
            backgroundColor: '#7b1fa2',
            borderRadius: 8,
            marginRight: 8,
          }}
        >
          <Text style={{ color: '#fff' }}>成員</Text>
        </Pressable>
      )}

      {/* 沒有場次時才顯示刪除 */}
      {!has && (
        <Pressable
          onPress={() => onDeleteEvent(item.id)}
          style={{
            paddingVertical: 6,
            paddingHorizontal: 10,
            backgroundColor: '#d32f2f',
            borderRadius: 8,
          }}
        >
          <Text style={{ color: '#fff' }}>刪除</Text>
        </Pressable>
      )}
    </View>
  </View>
);
};

return (
<KeyboardAvoidingView
style={{ flex: 1, backgroundColor: '#fff' }}
behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
keyboardVerticalOffset={headerHeight}
>
<View style={{ flex: 1, paddingHorizontal: 12, paddingTop: 12 }}>
{/* 搜尋 + 個人/設定 */}
<View
style={{
flexDirection: 'row',
justifyContent: 'space-between',
alignItems: 'center',
marginBottom: 8,
}}
>
<View style={{ flex: 1, marginRight: 8 }}>
<TextInput
value={q}
onChangeText={setQ}
placeholderTextColor="#888"
placeholder="搜尋賽事名稱（可輸入多關鍵字）"
style={{
height: 36,
borderWidth: 1,
borderColor: '#ccc',
borderRadius: 8,
paddingHorizontal: 10,
backgroundColor: '#fff',
}}
returnKeyType="search"
/>
</View>

        <Pressable
          onPress={() => nav.navigate('Home')}
          style={{
            paddingVertical: 6,
            paddingHorizontal: 10,
            backgroundColor: '#1976d2',
            borderRadius: 8,
          }}
        >
          <Text style={{ color: '#fff' }}>回首頁</Text>
        </Pressable>
        <Pressable
style={{
paddingVertical: 6,
paddingHorizontal: 10,
backgroundColor: '#607d8b',
borderRadius: 8,
marginLeft:6,
}}
>
<Text style={{ color: '#fff' }}>
{myName ? `Hi! ${myName}` : '個人'}
</Text>
</Pressable>
    </View>

    <Text style={{ fontSize: 16, fontWeight: '600', marginBottom: 8 }}>
      賽事清單
    </Text>

    {/* 清單 */}
    <FlatList
      data={filtered}
      keyExtractor={(i) => i.id}
      renderItem={renderItem}
      contentContainerStyle={{ paddingBottom: 12 }}
    />

    {/* 底部新增賽事 */}
    <View
      style={{
        marginTop: 8,
        flexDirection: 'row',
        alignItems: 'center',
        gap: 8,
        height: INPUT_BAR_H,
        paddingBottom: Math.max(0, insets.bottom),
      }}
    >
      <TextInput
        value={name}
        onChangeText={setName}
        placeholder="新增賽事名稱"
        placeholderTextColor="#888"
        style={{
          flex: 1,
          height: INPUT_BAR_H,
          borderWidth: 1,
          borderColor: '#ccc',
          borderRadius: 8,
          paddingHorizontal: 10,
          backgroundColor: '#fff',
        }}
        returnKeyType="done"
        onSubmitEditing={add}
      />
      <Pressable
        onPress={add}
        style={{
          backgroundColor: '#1976d2',
          paddingHorizontal: 16,
          height: INPUT_BAR_H,
          borderRadius: 8,
          justifyContent: 'center',
        }}
      >
        <Text style={{ color: '#fff' }}>新增</Text>
      </Pressable>
    </View>
  </View>
</KeyboardAvoidingView>
);
}ezbmt-tracked/src/screens/ClubChatScreen.tsx
 
import React from 'react';
import {
View, Text, TextInput, Pressable, KeyboardAvoidingView, Platform, FlatList, ActivityIndicator,
} from 'react-native';
import { useRoute, useNavigation } from '@react-navigation/native';
import { useHeaderHeight } from '@react-navigation/elements';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { supa, getCurrentUser } from '../lib/supabase';
import { getMyClubRole, listClubChatMessages, insertClubChatMessage } from '../db';

const C = { bg:'#111', card:'#222', border:'#333', text:'#fff', sub:'#bbb', btn:'#1976d2' };

type ChatItem = { id?: string; user?: string; text: string; created_at: string };

export default function ClubChatScreen() {
const route = useRoute<any>();
const navigation = useNavigation<any>();
const clubId = route.params?.clubId as string;

const headerHeight = useHeaderHeight();
const insets = useSafeAreaInsets();
const INPUT_H = 52;

const [items, setItems] = React.useState<ChatItem[]>([]);
const [name, setName] = React.useState('');
const [text, setText] = React.useState('');
const [loading, setLoading] = React.useState(true);

// 載入預設名稱（profiles.name 或 email 前綴）
React.useEffect(() => {
let active = true;
(async () => {
const u = await getCurrentUser();
if (!u || !active) return;
let preset = '';
try {
const { data } = await supa.from('profiles').select('name').eq('id', u.id).single();
if (data?.name && String(data.name).trim()) preset = String(data.name).trim();
else if (u.email) preset = String(u.email).split('@')[0];
} catch {}
if (active && preset) setName(preset);
})();
return () => { active = false; };
}, []);

const load = React.useCallback(async () => {
try { setItems(await listClubChatMessages(clubId, 200)); }
finally { setLoading(false); }
}, [clubId]);

// Realtime + 輪詢 fallback
React.useEffect(() => {
let channel: ReturnType<typeof supa.channel> | null = null;
try {
channel = supa
.channel('club-chat-' + clubId)
.on('postgres_changes',
{ event: 'INSERT', schema: 'public', table: 'club_chats', filter: 'club_id=eq.' + clubId },
(payload: any) => {
const r = payload?.new || {};
const msg: ChatItem = { id: r.id, user: r.user_name || '匿名', text: r.text || '', created_at: r.created_at || new Date().toISOString() };
setItems(prev => [msg, ...prev]);
}
)
.subscribe();
} catch {}

load();
const t = setInterval(load, 3000);
return () => { clearInterval(t); if (channel) channel.unsubscribe(); };
}, [load, clubId]);

const send = async () => {
const txt = text.trim();
const nm = name.trim();
if (!txt) return;
const optimistic: ChatItem = {
id: 'local-' + Date.now(),
user: nm || '匿名',
text: txt,
created_at: new Date().toISOString(),
};
setItems(prev => [optimistic, ...prev]);
setText('');
try { await insertClubChatMessage({ clubId, user: nm || '匿名', text: txt }); } catch {}
};

return (
<KeyboardAvoidingView
style={{ flex: 1, backgroundColor: C.bg }}
behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
keyboardVerticalOffset={headerHeight}
>
<View style={{ flex:1, padding:12 }}>
<Text style={{ color:C.text, fontSize:16, fontWeight:'700', marginBottom:8 }}>社團聊天室</Text>

    {loading ? (
      <View style={{ flex:1, alignItems:'center', justifyContent:'center' }}>
        <ActivityIndicator color="#fff" />
      </View>
    ) : (
      <FlatList
        style={{ flex:1 }}
        inverted
        data={items}
        keyExtractor={(i)=> i.id || String(i.created_at)}
        renderItem={({ item }) => (
          <View style={{ padding:10, borderRadius:8, backgroundColor:C.card, marginBottom:8 }}>
            <Text style={{ color:'#aaa', marginBottom:4 }}>{item.user || '匿名'} · {new Date(item.created_at).toLocaleTimeString()}</Text>
            <Text style={{ color:'#fff' }}>{item.text}</Text>
          </View>
        )}
      />
    )}

    {/* 輸入列 */}
    <View
      style={{
        marginTop: 8,
        flexDirection: 'row',
        alignItems: 'center',
        gap: 8,
        height: INPUT_H,
        backgroundColor: C.card,
        borderRadius: 10,
        paddingHorizontal: 8,
        paddingBottom: Math.max(0, insets.bottom),
        borderWidth: 1,
        borderColor: C.border,
      }}
    >
      <TextInput
        placeholder="名稱（可空）"
        placeholderTextColor="#888"
        value={name}
        onChangeText={setName}
        style={{ width: 140, height: INPUT_H - 10, borderWidth: 1, borderColor: '#444', borderRadius: 8, paddingHorizontal: 10, color: '#fff', backgroundColor: '#111' }}
        autoCapitalize="none"
        returnKeyType="next"
      />
      <TextInput
        placeholder="輸入訊息…"
        placeholderTextColor="#888"
        value={text}
        onChangeText={setText}
        onSubmitEditing={send}
        style={{ flex: 1, height: INPUT_H - 10, borderWidth: 1, borderColor: '#444', borderRadius: 8, paddingHorizontal: 10, color: '#fff', backgroundColor: '#111' }}
        returnKeyType="send"
        blurOnSubmit={false}
      />
      <Pressable onPress={send} disabled={!text.trim()} style={{ backgroundColor: text.trim() ? C.btn : '#555', paddingHorizontal: 16, height: INPUT_H - 10, borderRadius: 8, justifyContent: 'center' }}>
        <Text style={{ color: '#fff' }}>送出</Text>
      </Pressable>
    </View>
  </View>
</KeyboardAvoidingView>
);
}ezbmt-tracked/src/screens/WebCamScreen.tsx
 
import React from 'react';
import {
View,
Text,
Pressable,
ActivityIndicator,
Alert,
TextInput,
FlatList,
Switch,
PermissionsAndroid,
Platform,
} from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import KeepAwake from 'react-native-keep-awake';
import { useNavigation } from '@react-navigation/native';
import { supa } from '../lib/supabase';
import { getDeviceId, getPlatformTag } from '../lib/deviceId';
import { openSignalChannel } from '../lib/webrtcSignal';
import {
RTCPeerConnection,
mediaDevices,
RTCView,
RTCSessionDescription,
RTCIceCandidate,
} from 'react-native-webrtc';

const C = {
bg: '#111',
card: '#1e1e1e',
border: '#333',
text: '#fff',
sub: '#bbb',
btn: '#1976d2',
warn: '#d32f2f',
chip: '#90caf9',
gray: '#616161',
};

type CamRow = {
device_id: string;
owner_id: string;
name?: string | null;
platform?: string | null;
status?: 'online' | 'offline' | string | null;
last_seen_at?: string | null;
};

const ICE_SERVERS = {
iceServers: [
{ urls: ['stun:stun.l.google.com:19302',
'stun:stun1.l.google.com:19302',
'stun:stun2.l.google.com:19302',
'stun:stun3.l.google.com:19302',
'stun:stun4.l.google.com:19302'] },
],
};

const AUTO_KEY = 'webcam:autoBroadcast';

export default function WebCamScreen() {
const navigation = useNavigation<any>();

const [uid, setUid] = React.useState<string>('');
const [loading, setLoading] = React.useState(true);

const [deviceId, setDeviceId] = React.useState<string>('');
const [myName, setMyName] = React.useState<string>('');
const [advertise, setAdvertise] = React.useState(false);
const hbRef = React.useRef<null | (() => void)>(null);

const [list, setList] = React.useState<CamRow[]>([]);
const [busyRename, setBusyRename] = React.useState(false);
const [listLoading, setListLoading] = React.useState(false);

// WebRTC：廣播端狀態
const pcRef = React.useRef<RTCPeerConnection | null>(null);
const localStreamRef = React.useRef<any>(null);
const signalRef = React.useRef<ReturnType<typeof openSignalChannel> | null>(null);
const [previewOn, setPreviewOn] = React.useState(false);

React.useEffect(() => {
let active = true;
(async () => {
try {
const { data: admin } = await supa.rpc('is_app_admin');
if (!admin) throw new Error('not_admin');
const { data } = await supa.auth.getUser();
const u = data?.user?.id;
if (!u) throw new Error('no_login');
if (!active) return;
setUid(u);

    const id = await getDeviceId();
    if (!active) return;
    setDeviceId(id);
    setMyName(`Cam-${getPlatformTag()}-${id.slice(0, 4)}`);

    // 自動廣播偏好：若為開則自動啟動
    try {
      const pref = await AsyncStorage.getItem(AUTO_KEY);
      if (pref === '1') {
        setAdvertise(true);
        await startHeartbeat();
        await startBroadcast();
      }
    } catch {}

    await reload(u);
  } catch (e: any) {
    Alert.alert('無法進入', '此功能僅供最大管理者使用或尚未登入。');
  } finally {
    if (active) setLoading(false);
  }
})();
return () => {
  active = false;
  stopHeartbeat();
  stopBroadcast();
  try { KeepAwake.deactivate(); } catch {}
};
}, []);

// 廣播中 → 常亮
React.useEffect(() => {
try {
if (advertise) KeepAwake.activate();
else KeepAwake.deactivate();
} catch {}
return () => { try { KeepAwake.deactivate(); } catch {} };
}, [advertise]);

async function ensureAVPermission() {
if (Platform.OS === 'android') {
const cam = await PermissionsAndroid.request(PermissionsAndroid.PERMISSIONS.CAMERA);
const mic = await PermissionsAndroid.request(PermissionsAndroid.PERMISSIONS.RECORD_AUDIO);
if (cam !== PermissionsAndroid.RESULTS.GRANTED || mic !== PermissionsAndroid.RESULTS.GRANTED) {
throw new Error('CAMERA/MIC permission denied');
}
}
// iOS: Info.plist 需有相機/麥克風描述，首次會彈窗
}

async function reload(ownerId?: string) {
try {
setListLoading(true);
const { data, error } = await supa
.from('user_cams')
.select('device_id,owner_id,name,platform,status,last_seen_at')
.eq('owner_id', ownerId || uid)
.order('last_seen_at', { ascending: false })
.limit(200);
if (error) throw error;
setList(data || []);
const self = (data || []).find((r: any) => r.device_id === deviceId);
if (self && self.name && String(self.name).trim()) setMyName(String(self.name));
} catch (e: any) {
Alert.alert('載入失敗', String(e?.message || e));
} finally {
setListLoading(false);
}
}

function stopHeartbeat() {
try { hbRef.current?.(); } catch {}
hbRef.current = null;
}

async function startHeartbeat() {
stopHeartbeat();
const tick = async () => {
try {
await supa.from('user_cams').upsert({
device_id: deviceId,
owner_id: uid,
name: myName.trim() || `Cam-${getPlatformTag()}-${deviceId.slice(0, 4)}`,
platform: getPlatformTag(),
status: 'online',
last_seen_at: new Date().toISOString(),
updated_at: new Date().toISOString(),
});
} catch {}
};
await tick().catch(() => {});
const timer = setInterval(() => tick().catch(() => {}), 15_000);
hbRef.current = () => clearInterval(timer);
}

async function startBroadcast() {
try {
await ensureAVPermission();

  // 1) local stream
  const stream = await mediaDevices.getUserMedia({
    audio: true,
    video: { facingMode: 'environment', frameRate: 30, width: 640, height: 480 },
  });
  localStreamRef.current = stream;
  setPreviewOn(true);

  // 2) RTCPeerConnection
  const pc = new RTCPeerConnection(ICE_SERVERS);
  pcRef.current = pc;

  // Debug logs
  (pc as any).oniceconnectionstatechange = () => {
    console.log('[BROADCAST][ICE] state =', pc.iceConnectionState);
  };
  (pc as any).onconnectionstatechange = () => {
    console.log('[BROADCAST][PC] state =', pc.connectionState);
  };
  (pc as any).onicegatheringstatechange = () => {
    console.log('[BROADCAST][ICE] gathering =', pc.iceGatheringState);
  };

  // 3) 加入 tracks
  stream.getTracks().forEach((t: any) => pc.addTrack(t, stream));

  // 4) Signaling
  const signal = openSignalChannel(deviceId);
  signalRef.current = signal;

  (pc as any).onicecandidate = (ev: any) => {
    if (ev?.candidate) {
      console.log('[BROADCAST][ICE] send cand');
      signal.send({ kind: 'ice', from: deviceId, candidate: ev.candidate }).catch(() => {});
    } else {
      console.log('[BROADCAST][ICE] cand = null (completed)');
    }
  };

  await signal.subscribe(async (msg) => {
    try {
      if (!pcRef.current) return;
      if (msg.kind === 'offer' && msg.sdp) {
        console.log('[BROADCAST] recv offer');
        await pcRef.current.setRemoteDescription(new RTCSessionDescription(msg.sdp));
        const answer = await pcRef.current.createAnswer();
        await pcRef.current.setLocalDescription(answer);
        console.log('[BROADCAST] send answer');
        await signal.send({ kind: 'answer', from: deviceId, sdp: answer });
      } else if (msg.kind === 'ice' && msg.candidate) {
        console.log('[BROADCAST] recv cand');
        try { await pcRef.current.addIceCandidate(new RTCIceCandidate(msg.candidate)); } catch {}
      }
    } catch (e) {
      console.log('[BROADCAST] signal error', e);
    }
  });
} catch (e: any) {
  Alert.alert('串流啟動失敗', String(e?.message || e));
  stopBroadcast();
  try { await AsyncStorage.setItem(AUTO_KEY, '0'); } catch {}
  setAdvertise(false);
}
}

function stopBroadcast() {
try { signalRef.current?.close(); } catch {}
signalRef.current = null;
try { pcRef.current?.close(); } catch {}
pcRef.current = null;
try {
const s = localStreamRef.current;
if (s) s.getTracks().forEach((t: any) => t.stop?.());
} catch {}
localStreamRef.current = null;
setPreviewOn(false);
}

async function toggleAdvertise(on: boolean) {
setAdvertise(on);
try { await AsyncStorage.setItem(AUTO_KEY, on ? '1' : '0'); } catch {}
if (on) {
await startHeartbeat();
await startBroadcast();
} else {
stopHeartbeat();
stopBroadcast();
try {
await supa.from('user_cams').upsert({
device_id: deviceId,
owner_id: uid,
name: myName.trim() || `Cam-${getPlatformTag()}-${deviceId.slice(0, 4)}`,
platform: getPlatformTag(),
status: 'offline',
last_seen_at: new Date().toISOString(),
updated_at: new Date().toISOString(),
});
} catch {}
reload().catch(() => {});
}
}

async function saveName() {
const nm = myName.trim();
if (!nm) return;
setBusyRename(true);
try {
await supa.from('user_cams').upsert({
device_id: deviceId,
owner_id: uid,
name: nm,
platform: getPlatformTag(),
status: advertise ? 'online' : 'offline',
last_seen_at: new Date().toISOString(),
updated_at: new Date().toISOString(),
});
await reload();
Alert.alert('成功', '已更新名稱');
} catch (e: any) {
Alert.alert('失敗', String(e?.message || e));
} finally {
setBusyRename(false);
}
}

const Item = ({ item }: { item: CamRow }) => {
const online =
String(item.status || '') === 'online' &&
(item.last_seen_at ? Date.now() - new Date(item.last_seen_at).getTime() < 60_000 : false);

const onWatch = () => {
  navigation.navigate('WebCamViewer', {
    deviceId: item.device_id,
    name: item.name || item.device_id.slice(0, 8) + '…',
    online,
    lastSeenAt: item.last_seen_at || null,
  });
};

return (
  <View style={{ padding: 10, borderWidth: 1, borderColor: C.border, backgroundColor: C.card, borderRadius: 8, marginBottom: 8 }}>
    <Text style={{ color: '#fff', fontWeight: '700' }}>
      {item.name || item.device_id.slice(0, 8) + '…'}
    </Text>
    <Text style={{ color: '#ccc', marginTop: 4 }}>裝置：{item.device_id}</Text>
    <Text style={{ color: '#ccc', marginTop: 4 }}>平台：{item.platform || '-'}</Text>
    <Text style={{ color: online ? '#90caf9' : '#bbb', marginTop: 4 }}>
      狀態：{online ? 'online' : 'offline'}
      {!!item.last_seen_at && ` · ${new Date(item.last_seen_at).toLocaleString()}`}
    </Text>
    <View style={{ flexDirection: 'row', marginTop: 10 }}>
      <Pressable
        onPress={onWatch}
        disabled={!online}
        style={{ paddingVertical: 8, paddingHorizontal: 12, borderRadius: 8, backgroundColor: online ? C.btn : '#555', marginRight: 8 }}
      >
        <Text style={{ color: '#fff' }}>觀看</Text>
      </Pressable>
    </View>
  </View>
);
};

if (loading) {
return (
<View style={{ flex: 1, backgroundColor: C.bg, alignItems: 'center', justifyContent: 'center' }}>
<ActivityIndicator color="#90caf9" />
</View>
);
}

return (
<View style={{ flex: 1, backgroundColor: C.bg, padding: 12 }}>
<Text style={{ color: C.text, fontSize: 16, fontWeight: '800', marginBottom: 10 }}>
WEB CAM（我的裝置）
</Text>

  {previewOn && localStreamRef.current ? (
    <View style={{ height: 220, marginBottom: 10, borderRadius: 8, overflow: 'hidden', borderWidth: 1, borderColor: C.border }}>
      <RTCView streamURL={localStreamRef.current.toURL()} mirror={false} style={{ flex: 1, backgroundColor: '#000' }} objectFit="cover" />
    </View>
  ) : null}

  <View style={{ padding: 10, borderWidth: 1, borderColor: C.border, backgroundColor: C.card, borderRadius: 10, marginBottom: 12 }}>
    <Text style={{ color: '#fff', fontWeight: '700' }}>這台裝置</Text>
    <Text style={{ color: '#bbb', marginTop: 6 }}>Device ID：{deviceId}</Text>

    <View style={{ marginTop: 10 }}>
      <Text style={{ color: '#bbb', marginBottom: 6 }}>名稱</Text>
      <View style={{ flexDirection: 'row', alignItems: 'center' }}>
        <TextInput
          value={myName}
          onChangeText={setMyName}
          placeholder="裝置名稱"
          placeholderTextColor="#888"
          style={{ flex: 1, height: 40, borderWidth: 1, borderColor: '#444', borderRadius: 8, paddingHorizontal: 10, color: '#fff', backgroundColor: '#111' }}
        />
        <Pressable onPress={saveName} disabled={busyRename} style={{ marginLeft: 8, paddingVertical: 10, paddingHorizontal: 12, backgroundColor: busyRename ? '#555' : C.btn, borderRadius: 8 }}>
          <Text style={{ color: '#fff' }}>{busyRename ? '儲存中…' : '儲存'}</Text>
        </Pressable>
      </View>
    </View>

    <View style={{ flexDirection: 'row', alignItems: 'center', marginTop: 12 }}>
      <Text style={{ color: '#fff', marginRight: 8 }}>廣播中</Text>
      <Switch value={advertise} onValueChange={toggleAdvertise} />
      <Text style={{ color: '#888', marginLeft: 8 }}>（開啟後會記住，下次打開 App 自動開始廣播）</Text>
    </View>

    <View style={{ marginTop: 8 }}>
      <Text style={{ color: '#ffecb3' }}>注意：iOS/Android 都無法在背景或螢幕關閉時持續使用相機。請讓此畫面保持在前景；已啟用「螢幕常亮」避免裝置自動鎖定。</Text>
    </View>
  </View>

  <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 8 }}>
    <Text style={{ color: '#fff', fontWeight: '700' }}>我的 cams</Text>
    <Pressable onPress={() => reload()} style={{ marginLeft: 'auto', paddingVertical: 6, paddingHorizontal: 10, backgroundColor: C.btn, borderRadius: 8 }}>
      <Text style={{ color: '#fff' }}>{listLoading ? '更新中…' : '重新整理'}</Text>
    </Pressable>
  </View>
  {listLoading ? (
    <View style={{ padding: 16, alignItems: 'center' }}>
      <ActivityIndicator color="#90caf9" />
    </View>
  ) : (
    <FlatList data={list} keyExtractor={(i) => i.device_id} renderItem={({ item }) => <Item item={item} />} ListEmptyComponent={<Text style={{ color: C.sub }}>目前沒有已登記的裝置</Text>} />
  )}
</View>
);
}ezbmt-tracked/src/screens/SessionSignupsScreen.tsx
 
import React from 'react';
import { View, Text, FlatList, Pressable, Alert, ActivityIndicator } from 'react-native';
import { useRoute } from '@react-navigation/native';
import { listSignups, deleteSignup, upsertSessionAttendee } from '../db';
import { supa } from '../lib/supabase';

const C = { bg:'#111', card:'#1e1e1e', text:'#fff', sub:'#bbb', border:'#333', btn:'#1976d2', warn:'#d32f2f' };

type Row = { id:string; user_id:string; name?:string|null; email?:string|null; created_at:string };

export default function SessionSignupsScreen() {
const route = useRoute<any>();
const sessionId = route.params?.sessionId as string;
const clubId = route.params?.clubId as string;

const [loading, setLoading] = React.useState(true);
const [items, setItems] = React.useState<Row[]>([]);
const [busy, setBusy] = React.useState<string | null>(null);

const load = React.useCallback(async ()=>{
setLoading(true);
try {
const rows = await listSignups(sessionId);
setItems(rows);
} catch (e:any) {
Alert.alert('載入失敗', String(e?.message || e));
setItems([]);
} finally {
setLoading(false);
}
}, [sessionId]);

React.useEffect(()=>{ load(); }, [load]);

function displayNameOf(item: Row): string {
const n = (item.name && item.name.trim()) || '';
if (n) return n;
const e = (item.email && item.email.trim()) || '';
if (e) return e.split('@')[0];
return (item.user_id ? (item.user_id.slice(0, 8) + '…') : 'Anon');
}

async function ensureBuddyIdForUser(signup: Row): Promise<string> {
// 用顯示名稱作為 buddy 名稱（避免未命名）
const name = displayNameOf(signup);

try {
  const { data: found } = await supa
    .from('buddies')
    .select('id')
    .eq('club_id', clubId)
    .eq('name', name)
    .maybeSingle();
  if (found?.id) return String(found.id);
} catch {}

const id = Math.random().toString(36).slice(2);
const { error } = await supa.from('buddies').insert({
  id,
  club_id: clubId,
  name,
  level: 5,
});
if (error) throw error;
return id;
}

async function approve(signup: Row) {
setBusy(signup.id);
try {
const buddyId = await ensureBuddyIdForUser(signup);
await upsertSessionAttendee({ session_id: sessionId, buddy_id: buddyId } as any);
await deleteSignup(signup.id);
await load();
Alert.alert('已核准', '已加入報到名單');
} catch (e:any) {
Alert.alert('核准失敗', String(e?.message || e));
} finally {
setBusy(null);
}
}

async function reject(signup: Row) {
setBusy(signup.id);
try {
await deleteSignup(signup.id);
await load();
} catch (e:any) {
Alert.alert('刪除失敗', String(e?.message || e));
} finally {
setBusy(null);
}
}

if (loading) {
return (
<View style={{ flex:1, backgroundColor:C.bg, alignItems:'center', justifyContent:'center' }}>
<ActivityIndicator color="#90caf9" />
</View>
);
}

const Item = ({ item }: { item: Row }) => {
const display = displayNameOf(item);

return (
  <View style={{ padding:10, borderWidth:1, borderColor:C.border, backgroundColor:'#1e1e1e', borderRadius:10, marginBottom:10 }}>
    <Text style={{ color:'#fff', fontWeight:'700' }}>{display}</Text>
    {!!item.email && <Text style={{ color:'#bbb', marginTop:2 }}>{item.email}</Text>}
    <Text style={{ color:'#888', marginTop:2 }}>{new Date(item.created_at).toLocaleString()}</Text>
    <View style={{ flexDirection:'row', marginTop:8 }}>
      <Pressable
        onPress={()=>approve(item)}
        disabled={busy===item.id}
        style={{ paddingVertical:8, paddingHorizontal:12, borderRadius:8, backgroundColor: busy===item.id ? '#555' : C.btn, marginRight:8 }}
      >
        <Text style={{ color:'#fff' }}>{busy===item.id?'處理中…':'核准（加入報到）'}</Text>
      </Pressable>
      <Pressable
        onPress={()=>reject(item)}
        disabled={busy===item.id}
        style={{ paddingVertical:8, paddingHorizontal:12, borderRadius:8, backgroundColor: C.warn }}
      >
        <Text style={{ color:'#fff' }}>刪除</Text>
      </Pressable>
    </View>
  </View>
);
};

return (
<View style={{ flex:1, backgroundColor:C.bg, padding:12 }}>
<Text style={{ color:'#fff', fontSize:16, fontWeight:'800', marginBottom:8 }}>報名/候補名單</Text>
<FlatList data={items} keyExtractor={(i)=>i.id} renderItem={({ item }) => <Item item={item} />} />
</View>
);
}ezbmt-tracked/src/screens/ReplayScreen.tsx
 
import React from 'react';
import { View, Text, Alert, Pressable } from 'react-native';
import { useRoute } from '@react-navigation/native';
import { getRalliesByIds, listRalliesOrdered } from '../db';
import RoutePlayer, { RoutePlayerHandle } from '../components/RoutePlayer';

type RouteParam = { matchId: string; ids?: string[] };

type R = {
id: string;
route_start_rx?: number|null;
route_start_ry?: number|null;
route_end_rx?: number|null;
route_end_ry?: number|null;
winner_side: 'home'|'away';
meta_json?: string|null;
game_index?: number;
rally_no?: number;
};

const BLUE = '#1976d2';
const RED  = '#d32f2f';

function safeMeta(json: string|null|undefined) {
try { return json ? JSON.parse(json) : {}; } catch { return {}; }
}
function hasFullRoute(r: R) {
return (
r.route_start_rx != null && r.route_start_ry != null &&
r.route_end_rx   != null && r.route_end_ry   != null
);
}

export default function ReplayScreen() {
const route = useRoute<any>();
const { matchId, ids } = (route.params || {}) as RouteParam;

const [routes, setRoutes] = React.useState<Array<{ sx:number; sy:number; ex:number; ey:number; kind:'win'|'loss'; color:string; meta?: any }>>([]);
const [filter, setFilter] = React.useState<'all'|'win'|'loss'|'random'>('all');
const [nowIndex, setNowIndex] = React.useState(0);
const [playing, setPlaying] = React.useState(false);
const [speedHalf, setSpeedHalf] = React.useState(false); // 0.5x 切換

// non-null ref（避免型別錯）
const playerRef = React.useRef<RoutePlayerHandle>(null!);

React.useEffect(() => {
(async () => {
try {
let rows: R[] = [];

    if (Array.isArray(ids) && ids.length) {
      try { rows = await getRalliesByIds(ids); } catch { rows = []; }
    }
    if ((!rows || rows.length === 0) && matchId) {
      const all = await listRalliesOrdered(matchId) as unknown as R[];
      rows = (all || []).filter(hasFullRoute);
      rows.sort((a,b) => {
        const ga = Number(a.game_index||0), gb = Number(b.game_index||0);
        if (ga !== gb) return ga - gb;
        return Number(a.rally_no||0) - Number(b.rally_no||0);
      });
    }

    const items = (rows || [])
      .map((r) => {
        if (!hasFullRoute(r)) return null;
        const sx = Number(r.route_start_rx);
        const sy = Number(r.route_start_ry);
        const ex = Number(r.route_end_rx);
        const ey = Number(r.route_end_ry);
        if (!isFinite(sx) || !isFinite(sy) || !isFinite(ex) || !isFinite(ey)) return null;

        // 決定起點方：奇數局主在上、偶數局客在上（分析層簡化，不處理中途換邊）
        const top: 0|1 = (Number(r.game_index||0) % 2 === 1) ? 0 : 1;
        const startTeam: 0|1 = (sy < 0.5 ? top : (top ^ 1)) as 0|1;
        const color = startTeam === 0 ? BLUE : RED;

        const kind: 'win'|'loss' = r.winner_side === 'home' ? 'win' : 'loss';
        const meta = safeMeta(r.meta_json as any);
        return { sx, sy, ex, ey, kind, color, meta };
      })
      .filter(Boolean) as Array<{ sx:number; sy:number; ex:number; ey:number; kind:'win'|'loss'; color:string; meta?: any }>;

    setRoutes(items);

    if ((!rows || rows.length === 0) && (!ids || ids.length === 0)) {
      Alert.alert('沒有可播放的路線', '此場次目前沒有同時包含起點與落點的路線紀錄。');
    }
  } catch (e:any) {
    Alert.alert('載入失敗', String(e?.message || e));
  }
})();
}, [matchId, ids]);

const curMeta = routes[nowIndex]?.meta;

// 0.5x 切換
const toggleSpeedHalf = () => {
const next = !speedHalf;
setSpeedHalf(next);
playerRef.current?.setSpeed(next ? 0.5 : 1);
};

return (
<View style={{ flex: 1, padding: 12 }}>
<Text style={{ fontSize: 16, fontWeight: '600', marginBottom: 8 }}>路徑回放</Text>

  {/* 上方：篩選 Chips（唯一一組） */}
  <View style={{ flexDirection:'row', marginBottom: 8, flexWrap: 'wrap' }}>
    {(['all','win','loss','random'] as const).map(f=>(
      <Pressable
        key={f}
        onPress={()=>setFilter(f)}
        style={{
          paddingVertical:6, paddingHorizontal:10, borderRadius:14,
          borderWidth:1, borderColor: filter===f?'#1976d2':'#ccc',
          backgroundColor: filter===f?'rgba(25,118,210,0.1)':'#fff',
          marginRight:8, marginBottom:8
        }}
      >
        <Text>{f==='all'?'全部':f==='win'?'只播得分':f==='loss'?'只播失分':'隨機'}</Text>
      </Pressable>
    ))}
  </View>

  {/* 中間：播放器（外層自繪控制列，不遮畫面） */}
  <View style={{ flex: 1 }}>
    <FitPlayer
      routes={routes}
      filter={filter}
      onIndexChange={setNowIndex}
      onPlayingChange={setPlaying}
      playerRef={playerRef}
    />
  </View>

  {/* 下方：精簡控制列 + 新增功能鍵 */}
  <View style={{ flexDirection:'row', justifyContent:'space-between', alignItems:'center', marginTop: 10, flexWrap:'wrap' }}>
    <Text style={{ color:'#333', marginBottom:8 }}>{routes.length ? `第 ${nowIndex+1}/${routes.length} 球` : '無可播放路徑'}</Text>
    <View style={{ flexDirection:'row', flexWrap:'wrap' }}>
      <Pressable onPress={()=>playerRef.current?.prev()} style={{ paddingVertical:8, paddingHorizontal:12, backgroundColor:'#424242', borderRadius:8, marginRight:8, marginBottom:8 }}>
        <Text style={{ color:'#fff' }}>上</Text>
      </Pressable>
      <Pressable onPress={()=>playerRef.current?.toggle()} style={{ paddingVertical:8, paddingHorizontal:12, backgroundColor:'#1976d2', borderRadius:8, marginRight:8, marginBottom:8 }}>
        <Text style={{ color:'#fff' }}>{playing ? '暫停' : '播放'}</Text>
      </Pressable>
      <Pressable onPress={()=>playerRef.current?.replay()} style={{ paddingVertical:8, paddingHorizontal:12, backgroundColor:'#455a64', borderRadius:8, marginRight:8, marginBottom:8 }}>
        <Text style={{ color:'#fff' }}>重播</Text>
      </Pressable>
      <Pressable onPress={()=>playerRef.current?.next()} style={{ paddingVertical:8, paddingHorizontal:12, backgroundColor:'#424242', borderRadius:8, marginRight:8, marginBottom:8 }}>
        <Text style={{ color:'#fff' }}>下</Text>
      </Pressable>

      {/* 新增：全部重播 */}
      <Pressable onPress={()=>playerRef.current?.restartAll()} style={{ paddingVertical:8, paddingHorizontal:12, backgroundColor:'#00695c', borderRadius:8, marginRight:8, marginBottom:8 }}>
        <Text style={{ color:'#fff' }}>全部重播</Text>
      </Pressable>

      {/* 新增：0.5x */}
      <Pressable onPress={toggleSpeedHalf} style={{ paddingVertical:8, paddingHorizontal:12, backgroundColor: speedHalf ? '#8e24aa' : '#9e9e9e', borderRadius:8, marginBottom:8 }}>
        <Text style={{ color:'#fff' }}>0.5x</Text>
      </Pressable>
    </View>
  </View>

  {/* 當前球的標籤（球種/主受迫/原因） */}
  {curMeta ? (
    <View style={{ marginTop: 10, flexDirection:'row', flexWrap:'wrap' }}>
      {curMeta.shotType && <Badge text={curMeta.shotType} />}
      {curMeta.forceType && <Badge text={curMeta.forceType} />}
      {curMeta.errorReason && <Badge text={curMeta.errorReason} />}
    </View>
  ) : null}

  {routes.length === 0 && (
    <Text style={{ marginTop: 8, color: '#666' }}>目前沒有可播放的路徑</Text>
  )}
</View>
);
}

/* 播放器外層：等比縮放 + 轉接 ref 與回呼 */
function FitPlayer({
routes, filter, onIndexChange, onPlayingChange, playerRef,
}: {
routes: any[];
filter: 'all'|'win'|'loss'|'random';
onIndexChange: (i:number)=>void;
onPlayingChange: (p:boolean)=>void;
playerRef: React.RefObject<RoutePlayerHandle>;
}) {
const [box, setBox] = React.useState({ w: 0, h: 0 });

const onLayout = (e: any) => {
const { width, height } = e.nativeEvent.layout;
if (width && height) setBox({ w: Math.floor(width), h: Math.floor(height) });
};

const ar = 6.1 / 13.4;
let w = 0, h = 0;
if (box.w > 0 && box.h > 0) {
const wByH = box.h * ar;
if (wByH <= box.w) { w = Math.floor(wByH); h = Math.floor(box.h); }
else { w = Math.floor(box.w); h = Math.floor(box.w / ar); }
}

return (
<View style={{ flex: 1 }} onLayout={onLayout}>
{w > 0 && h > 0 ? (
<View style={{ width: w, height: h, alignSelf: 'center' }}>
<RoutePlayer
ref={playerRef}
width={w}
height={h}
routes={routes}
autoPlay
initialSpeed={1}
filter={filter}
onIndexChange={onIndexChange}
onPlayingChange={onPlayingChange}
controls="none"            // 外層自畫控制列
showFilterChips={false}
/>
</View>
) : null}
</View>
);
}

function Badge({ text }: { text: string }) {
return (
<View style={{ paddingVertical:4, paddingHorizontal:8, borderRadius:12, backgroundColor:'#eee', marginRight:6, marginBottom:6 }}>
<Text>{text}</Text>
</View>
);
}

ezbmt-tracked/src/screens/ClubDashboardScreen.tsx
 
import React from 'react';
import { View, Text, Pressable } from 'react-native';
import { useRoute, useNavigation } from '@react-navigation/native';

const C = { bg:'#111', card:'#1e1e1e', text:'#fff', btn:'#1976d2', gray:'#616161' };

export default function ClubDashboardScreen() {
const route = useRoute<any>();
const nav = useNavigation<any>();
const clubId = route.params?.clubId as string;

const Btn = ({ title, onPress, color='#1976d2' }: any) => (
<Pressable onPress={onPress} style={{ backgroundColor: color, borderRadius:12, paddingVertical:12, alignItems:'center', marginBottom:10 }}>
<Text style={{ color:'#fff', fontWeight:'700' }}>{title}</Text>
</Pressable>
);

return (
<View style={{ flex:1, backgroundColor:C.bg, padding:16 }}>
<Text style={{ color:C.text, fontSize:18, fontWeight:'700', marginBottom:12 }}>社團主頁</Text>
<Btn title="成員" onPress={()=>nav.navigate('ClubMembers', { clubId })} />
<Btn title="球友名單" onPress={()=>nav.navigate('Buddies', { clubId })} />
<Btn title="場次" onPress={()=>nav.navigate('Sessions', { clubId })} />
<Btn title="聊天室" onPress={()=>nav.navigate('ClubChat', { clubId })} />
<Btn title="媒體" onPress={()=>nav.navigate('ClubMedia', { clubId })} />
{/* 之後會加入：排點、計分板、聊天室、媒體 */}
<View style={{ height:8 }} />
<Btn title="返回社團清單" onPress={()=>nav.navigate('Clubs')} color={C.gray} />
</View>
);
}ezbmt-tracked/src/screens/ClubMembersScreen.tsx
 
import React from 'react';
import {
View, Text, FlatList, Pressable, Alert, TextInput, KeyboardAvoidingView, Platform
} from 'react-native';
import { useRoute, useNavigation } from '@react-navigation/native';
import { useHeaderHeight } from '@react-navigation/elements';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import {
getMyClubRole,
listClubMembers,
upsertClubMember,
deleteClubMember,
inviteClubMemberByEmail,
listMyInviteContactsWithNames,
} from '../db';

type ClubRole = 'owner' | 'admin' | 'scheduler' | 'scorer' | 'member';
const ROLES: Array<{ key: ClubRole; label: string }> = [
{ key: 'owner', label: '社長' },
{ key: 'admin', label: '管理員' },
{ key: 'scheduler', label: '排程' },
{ key: 'scorer', label: '記分' },
{ key: 'member', label: '一般' },
];
const C = { bg:'#111', card:'#222', border:'#333', text:'#fff', sub:'#ddd', chipOn:'#90caf9', chipOff:'#555' };

export default function ClubMembersScreen() {
const route = useRoute<any>();
const nav = useNavigation<any>();
const clubId: string | undefined = route.params?.clubId;

const headerHeight = useHeaderHeight();
const insets = useSafeAreaInsets();

const [mine, setMine] = React.useState<ClubRole | null>(null);
const [items, setItems] = React.useState<Array<{ id:string; user_id:string; role:ClubRole; name:string; email?:string|null }>>([]);
const [loading, setLoading] = React.useState(true);

// 邀請欄位
const [inviteEmail, setInviteEmail] = React.useState('');
const [inviteRole, setInviteRole] = React.useState<ClubRole>('member');

// 曾邀請聯絡人
const [contacts, setContacts] = React.useState<Array<{ email:string; name?:string|null; last_role:string; total_count?:number; last_invited_at?:string|null }>>([]);
const [contactsOpen, setContactsOpen] = React.useState(false);
const [contactsLimit, setContactsLimit] = React.useState(12);

React.useEffect(() => {
if (!clubId) return;
(async () => {
try { setMine((await getMyClubRole(clubId)) as ClubRole | null); }
catch { setMine(null); }
})();
}, [clubId]);

const loadContacts = React.useCallback(async ()=>{
try {
const rows = await listMyInviteContactsWithNames();
setContacts(rows || []);
} catch { setContacts([]); }
}, []);

const load = React.useCallback(async () => {
if (!clubId) return;
setLoading(true);
try {
const rows = await listClubMembers(clubId);
setItems(rows as any);
await loadContacts();
} catch (e:any) {
Alert.alert('載入失敗', String(e?.message||e));
} finally {
setLoading(false);
}
}, [clubId, loadContacts]);

React.useEffect(() => { load(); }, [load]);

if (!clubId) {
return (
<View style={{ flex:1, backgroundColor:C.bg, alignItems:'center', justifyContent:'center', padding:16 }}>
<Text style={{ color:C.text, fontSize:16 }}>未提供 clubId</Text>
</View>
);
}

const canManage = mine === 'owner' || mine === 'admin';
const ownersCount = React.useMemo(() => items.filter(m => m.role === 'owner').length, [items]);

async function changeRole(memberId: string, userId: string, newRole: ClubRole) {
const target = items.find(m => m.id === memberId);
if (!target) return;
if (target.role === 'owner' && newRole !== 'owner' && ownersCount <= 1) {
Alert.alert('無法變更', '社團至少需保留 1 位社長'); return;
}
try { await upsertClubMember({ clubId, userId, role: newRole }); load(); }
catch (e:any) { Alert.alert('變更失敗', String(e?.message||e)); }
}
async function removeMember(memberId: string) {
const target = items.find(m => m.id === memberId);
if (!target) return;
if (target.role === 'owner' && ownersCount <= 1) {
Alert.alert('無法移除', '社團至少需保留 1 位社長'); return;
}
try { await deleteClubMember(memberId); load(); }
catch (e:any) { Alert.alert('移除失敗', String(e?.message||e)); }
}

const renderItem = ({ item }: { item: { id:string; user_id:string; role:ClubRole; name:string; email?:string|null } }) => {
const displayName = (item.name && item.name.trim()) || (item.email && item.email.trim()) || '未命名';
return (
<View style={{ padding:10, borderWidth:1, borderColor:C.border, backgroundColor:C.card, borderRadius:8, marginBottom:8 }}>
<Text style={{ color:C.text, fontWeight:'600' }}>{displayName}</Text>
{!!item.email && <Text style={{ color:'#aaa', marginTop:2 }}>{item.email}</Text>}
<View style={{ flexDirection:'row', flexWrap:'wrap', marginTop:6 }}>
{ROLES.map(r => {
const selected = item.role === r.key;
const disabled = !canManage || (item.role==='owner' && r.key!=='owner' && ownersCount<=1);
return (
<Pressable
key={r.key}
onPress={() => !disabled && changeRole(item.id, item.user_id, r.key)}
style={{
paddingVertical:6, paddingHorizontal:10, borderRadius:14,
borderWidth:1, borderColor: selected ? C.chipOn : C.chipOff,
backgroundColor: selected ? 'rgba(144,202,249,0.15)' : C.card,
marginRight:8, marginBottom:8, opacity: disabled?0.5:1
}}
>
<Text style={{ color:C.text }}>{r.label}</Text>
</Pressable>
);
})}
{canManage && (
<Pressable onPress={() => removeMember(item.id)} style={{ paddingVertical:6, paddingHorizontal:10, backgroundColor:'#d32f2f', borderRadius:8, marginLeft:8 }}>
<Text style={{ color:'#fff' }}>移除</Text>
</Pressable>
)}
</View>
</View>
);
};

const ListHeader = (
<View style={{ marginBottom:10 }}>
<Text style={{ color:C.text, fontSize:16, fontWeight:'700', marginBottom:6 }}>社團成員</Text>
<Text style={{ color:C.sub }}>{`我的角色：${mine || '-'}`}</Text>
</View>
);

const ListFooter = (
<View style={{ borderTopWidth:1, borderColor:C.border, paddingTop:10, marginTop:10, paddingBottom:(insets.bottom||12)+12 }}>
<Text style={{ color:C.text, fontWeight:'600', marginBottom:6 }}>邀請成員（Email）</Text>

  {/* 曾邀請過（可收合） */}
  {contacts.length > 0 && (
    <View style={{ marginBottom: 8, borderWidth:1, borderColor:C.border, backgroundColor:C.card, borderRadius:8, paddingHorizontal:10, paddingTop:8 }}>
      <Pressable onPress={() => setContactsOpen(o => !o)} style={{ flexDirection:'row', alignItems:'center', justifyContent:'space-between', paddingVertical:6 }}>
        <Text style={{ color: C.sub, fontWeight:'600' }}>{`曾邀請過（${contacts.length}）`}</Text>
        <Text style={{ color:'#90caf9' }}>{contactsOpen ? '收起' : '展開'}</Text>
      </Pressable>
      {contactsOpen && (
        <>
          <View style={{ marginTop:4 }}>
            {contacts.slice(0, contactsLimit).map((c) => (
              <Pressable
                key={c.email}
                onPress={() => { setInviteEmail(c.email); if (c.last_role) setInviteRole(c.last_role as ClubRole); }}
                style={{
                  paddingVertical:6, paddingHorizontal:10, borderRadius:8,
                  borderWidth:1, borderColor:'#555',
                  backgroundColor: '#1f1f1f',
                  marginRight:8, marginBottom:8
                }}
              >
                <Text style={{ color:'#fff' }}>{`${c.name || ''}${c.name ? ' · ' : ''}${c.email}`}</Text>
                {!!c.last_role && <Text style={{ color:'#aaa', marginTop:2 }}>{`上次角色：${c.last_role}`}</Text>}
              </Pressable>
            ))}
          </View>
          {/* 顯示全部 / 收斂 */}
          {contacts.length > contactsLimit ? (
            <Pressable onPress={() => setContactsLimit(contacts.length)} style={{ alignSelf:'flex-end', paddingVertical:6, paddingHorizontal:8 }}>
              <Text style={{ color:'#90caf9' }}>顯示全部</Text>
            </Pressable>
          ) : contacts.length > 12 ? (
            <Pressable onPress={() => setContactsLimit(12)} style={{ alignSelf:'flex-end', paddingVertical:6, paddingHorizontal:8 }}>
              <Text style={{ color:'#90caf9' }}>只顯示 12 筆</Text>
            </Pressable>
          ) : null}
        </>
      )}
    </View>
  )}

  <TextInput
    value={inviteEmail}
    onChangeText={setInviteEmail}
    placeholder="example@mail.com"
    placeholderTextColor="#888"
    autoCapitalize="none"
    keyboardType="email-address"
    style={{ borderWidth:1, borderColor:'#444', borderRadius:8, paddingHorizontal:10, paddingVertical:8, color: C.text, backgroundColor:'#111', marginBottom:8 }}
  />
  <View style={{ flexDirection:'row', flexWrap:'wrap', marginBottom:8 }}>
    {(['member','scorer','scheduler','admin','owner'] as const).map(r => (
      <Pressable
        key={r}
        onPress={()=>setInviteRole(r)}
        style={{ paddingVertical:6, paddingHorizontal:10, borderRadius:14, borderWidth:1, borderColor: inviteRole===r? C.chipOn:'#555', backgroundColor: inviteRole===r?'rgba(144,202,249,0.15)':C.card, marginRight:8, marginBottom:8 }}
      >
        <Text style={{ color: C.text }}>{r}</Text>
      </Pressable>
    ))}
  </View>
  <Pressable
    onPress={async()=>{
      try {
        await inviteClubMemberByEmail({ clubId, email: inviteEmail.trim(), role: inviteRole });
        Alert.alert('成功','邀請已送出');
        setInviteEmail('');
        await loadContacts(); // 送出後刷新聯絡人
        await load();         // 刷新成員
      } catch(e:any){ Alert.alert('失敗', String(e?.message || e)); }
    }}
    style={{ backgroundColor:'#1976d2', paddingVertical:10, borderRadius:8, alignItems:'center' }}
  >
    <Text style={{ color:'#fff' }}>送出邀請</Text>
  </Pressable>
</View>
);

return (
<KeyboardAvoidingView style={{ flex:1, backgroundColor: C.bg }} behavior={Platform.OS==='ios' ? 'padding' : undefined} keyboardVerticalOffset={headerHeight}>
<FlatList
data={items}
keyExtractor={(i)=>i.id}
renderItem={renderItem}
contentContainerStyle={{ padding:12 }}
ListHeaderComponent={ListHeader}
ListFooterComponent={ListFooter}
/>
</KeyboardAvoidingView>
);
}ezbmt-tracked/src/screens/LiveScreen.tsx
 
import React from 'react';
import { View, Text, ScrollView, Pressable } from 'react-native';
import { useRoute, useNavigation } from '@react-navigation/native';
import Svg, { Line, Path, Text as SvgText, G } from 'react-native-svg';
import { getMatch, getMatchPlayers, listRalliesOrdered } from '../db';
import { deserialize, getUiSnapshot } from '../logic/serve';
import { subscribeLive, LiveSnapshot } from '../lib/supabase';

type SeriesByGame = Array<{ game: number; rows: Array<{ win: boolean }> }>;

function TrendChart({ title, rows }: { title: string; rows: Array<{ win: boolean }> }) {
  const [w, setW] = React.useState(0);
  const H = 160;
  const PAD = 28;

  const series = React.useMemo(() => {
    const home: number[] = [0];
    const away: number[] = [0];
    let h = 0, a = 0;
    for (let i = 0; i < rows.length; i++) {
      if (rows[i].win) h++; else a++;
      home.push(h); away.push(a);
    }
    const maxY = Math.max(1, h, a);
    return { home, away, maxY };
  }, [rows]);

  const ticks = React.useMemo(() => {
    const arr: number[] = [];
    for (let v = 0; v <= series.maxY; v += 5) arr.push(v);
    if (arr[arr.length - 1] !== series.maxY) arr.push(series.maxY);
    return arr;
  }, [series.maxY]);

  const yOf = (v: number) => {
    const plotH = Math.max(1, H - PAD * 2);
    return PAD + (plotH * (1 - v / series.maxY));
  };

  const buildPath = (vals: number[], W: number, H: number, maxY: number) => {
    const plotW = Math.max(1, W - PAD * 2);
    const plotH = Math.max(1, H - PAD * 2);
    const n = vals.length; if (n <= 1) return '';
    const stepX = plotW / (n - 1);
    const yOf2 = (v: number) => PAD + (plotH * (1 - v / maxY));
    let d = `M ${PAD} ${yOf2(vals[0])}`;
    for (let i = 1; i < n; i++) {
      const x = PAD + i * stepX;
      const y = yOf2(vals[i]);
      d +=  `L ${x} ${y}`;
    }
    return d;
  };

  return (
    <View
      onLayout={e => setW(Math.floor(e.nativeEvent.layout.width))}
      style={{ marginTop: 10, padding: 10, borderWidth: 1, borderColor: '#333', borderRadius: 10, backgroundColor: '#222' }}
    >
      <Text style={{ color: '#fff', fontWeight: '600', marginBottom: 8 }}>{title}</Text>
      {w <= 0 ? null : (
        <Svg width={w} height={H}>
          {/* 軸線 */}
          <G>
            <Line x1={PAD} y1={PAD} x2={PAD} y2={H - PAD} stroke="#444" strokeWidth={1} />
            <Line x1={PAD} y1={H - PAD} x2={w - PAD} y2={H - PAD} stroke="#444" strokeWidth={1} />
          </G>
          {/* 每 5 分 + 最後分數，滿版水平線 + 數字 */}
          <G>
            {ticks.map(v => {
              const y = yOf(v);
              return (
                <G key={'yt-'+v}>
                  <Line x1={PAD} y1={y} x2={w - PAD} y2={y} stroke="#3a3a3a" strokeWidth={1} opacity={v===0?0.55:0.28}/>
                  <SvgText x={PAD - 6} y={y + 4} fill="#888" fontSize={10} textAnchor="end">{v}</SvgText>
                </G>
              );
            })}
          </G>
          {/* 折線 */}
          <Path d={buildPath(series.home, w, H, series.maxY)} stroke="#1976d2" strokeWidth={2} fill="none" />
          <Path d={buildPath(series.away, w, H, series.maxY)} stroke="#d32f2f" strokeWidth={2} fill="none" />
        </Svg>
      )}
    </View>
  );
}

export default function LiveScreen() {
  const route = useRoute<any>();
  const navigation = useNavigation<any>();
  const matchId = route.params?.matchId as string | undefined;

  const [ui, setUi] = React.useState<LiveSnapshot | null>(null);
  const [meta, setMeta] = React.useState<{ type?: string; court?: string | null; singles?: boolean }>({});
  const [players, setPlayers] = React.useState<{ home: [string|null, string|null]; away: [string|null, string|null] }>({ home: [null, null], away: [null, null] });
  const [series, setSeries] = React.useState<SeriesByGame>([]);
  const [eventId, setEventId] = React.useState<string | null>(null);

  React.useEffect(() => {
    if (!matchId) return;

    let unsub: any = null;
    // Realtime（若未啟用則無動作）
    try {
      const sub = subscribeLive(matchId, (snap: LiveSnapshot) => setUi(snap));
      unsub = sub;
    } catch (_e) {}

    // Poll fallback
    let active = true;
    const fetchState = async () => {
      try {
        if (ui) return;
        const m = await getMatch(matchId);
        if (!active) return;
        if (m && m.state_json) {
          const s = deserialize(m.state_json);
          setUi(getUiSnapshot(s) as unknown as LiveSnapshot);
        }
      } catch {}
    };
    fetchState();
    const t = setInterval(fetchState, 1500);

    // 基本資料（類型/場地/球員/eventId）
    (async () => {
      try {
        const m = await getMatch(matchId);
        setEventId(m?.event_id || null);

        const type = String(m?.type || '');
        const singles = type.endsWith('S');
        setMeta({ type, court: (m?.court_no ?? null), singles });

        const rows = await getMatchPlayers(matchId);
        const home:[string|null,string|null] = [null,null];
        const away:[string|null,string|null] = [null,null];
        (rows||[]).forEach((r:any)=> {
          const nm = r?.name || null;
          if (r.side==='home') home[r.idx] = nm;
          else if (r.side==='away') away[r.idx] = nm;
        });
        setPlayers({ home, away });
      } catch {}
    })();

    // 每局趨勢資料（每 3 秒）
    const refreshSeries = async () => {
      try {
        const rows = await listRalliesOrdered(matchId);
        const byGame = new Map<number, Array<{win:boolean}>>();
        (rows||[]).forEach((r:any)=>{
          const g = Number(r.game_index||0);
          const win = r.winner_side === 'home';
          const arr = byGame.get(g) || [];
          arr.push({ win });
          byGame.set(g, arr);
        });
        const arr:SeriesByGame = Array.from(byGame.entries())
          .sort((a,b)=> b[0]-a[0]) // 最近的在最上
          .map(([g, rows])=>({ game: g, rows }));
        setSeries(arr);
      } catch {}
    };
    refreshSeries();
    const ts = setInterval(refreshSeries, 3000);

    return () => {
      active = false;
      clearInterval(t);
      clearInterval(ts);
      if (unsub && unsub.unsubscribe) unsub.unsubscribe();
    };
  }, [matchId]);

  if (!matchId) {
    return (
      <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center', padding: 16, backgroundColor:'#111' }}>
        <Text style={{ color:'#fff' }}>尚未提供 matchId，請從場次頁進入。</Text>
      </View>
    );
  }

  const scoreA = typeof ui?.scoreA === 'number' ? ui!.scoreA! : 0;
  const scoreB = typeof ui?.scoreB === 'number' ? ui!.scoreB! : 0;
  const server = ui?.server;
  const receiver = ui?.receiver;

  // 類型/場地/選手（發/接）
  const singles = !!meta.singles;
  const safe = (s: string|null|undefined, fallback: string) => (s && String(s).trim()) || fallback;
  const h0 = safe(players.home[0], '主#1');
  const h1 = safe(players.home[1], '主#2');
  const a0 = safe(players.away[0], '客#1');
  const a1 = safe(players.away[1], '客#2');

  const label = (team:0|1, idx:0|1, base:string) => {
    const tags:string[] = [];
    if (server && server.team===team && server.index===idx) tags.push('發');
    if (receiver && receiver.team===team && receiver.index===idx) tags.push('接');
    return tags.length ? `${base}（${tags.join('、')}）` : base;
  };

  const homeLine = singles
    ? `主隊：${label(0,0,h0)}`
    : `主隊：${label(0,0,h0)}、${label(0,1,h1)}`;

  const awayLine = singles
    ? `客隊：${label(1,0,a0)}`
    : `客隊：${label(1,0,a0)}、${label(1,1,a1)}`;

  // 卡片上的每局比分標籤（已含勝方）
  const gameBadges = React.useMemo(() => {
    if (!series.length) return null;
    const sums = series
      .map(sec => {
        const home = sec.rows.reduce((acc, r) => acc + (r.win ? 1 : 0), 0);
        const away = sec.rows.length - home;
        const winner = home > away ? 0 : away > home ? 1 : null;
        return { g: sec.game, home, away, winner };
      })
      .sort((a, b) => a.g - b.g);
    return (
      <View style={{ flexDirection:'row', flexWrap:'wrap', marginTop:8 }}>
        {sums.map(x => (
          <View
            key={'badge-'+x.g}
            style={{ paddingVertical:4, paddingHorizontal:8, borderRadius:12, borderWidth:1, borderColor:'#333', backgroundColor:'#222', marginRight:6, marginBottom:6 }}
          >
            <Text style={{ color:'#fff' }}>
              G{x.g} {x.home}-{x.away}{x.winner==null ? '' : x.winner===0 ? '（主）' : '（客）'}
            </Text>
          </View>
        ))}
      </View>
    );
  }, [series]);

  return (
    <ScrollView style={{ flex: 1, backgroundColor: '#111' }} contentContainerStyle={{ padding: 16 }}>
      {/* 類型 / 場地 / 選手（含發/接 + 局分標籤 + 按鈕） */}
      <View style={{ backgroundColor:'#222', borderRadius:12, padding:12, marginBottom:12, borderWidth:1, borderColor:'#333' }}>
        <View style={{ flexDirection:'row', justifyContent:'space-between', alignItems:'center' }}>
          <Text style={{ color:'#fff', fontSize:16, fontWeight:'600' }}>
            類型：{meta.type || '-'}　場地：{meta.court || '-'}
          </Text>
          <View style={{ flexDirection:'row' }}>
            <Pressable
              onPress={() => navigation.navigate('Chat', { matchId })}
              style={{ paddingVertical:6, paddingHorizontal:10, backgroundColor:'#7b1fa2', borderRadius:8, marginRight:8 }}
            >
              <Text style={{ color:'#fff' }}>留言</Text>
            </Pressable>
            <Pressable
              onPress={() => { if (eventId) navigation.navigate('Matches', { eventId }); }}
              style={{ paddingVertical:6, paddingHorizontal:10, backgroundColor:'#455a64', borderRadius:8 }}
            >
              <Text style={{ color:'#fff' }}>場次</Text>
            </Pressable>
          </View>
        </View>
        <Text style={{ color:'#ddd', marginTop:6 }}>{homeLine}</Text>
        <Text style={{ color:'#ddd', marginTop:4 }}>{awayLine}</Text>
        {gameBadges}
      </View>

      {/* 現在分數 */}
      <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', padding: 16, backgroundColor: '#222', borderRadius: 12 }}>
        <Text style={{ color: '#90caf9', fontSize: 48, fontWeight: '700' }}>{scoreA}</Text>
        <Text style={{ color: '#fff', fontSize: 32 }}>VS</Text>
        <Text style={{ color: '#ef9a9a', fontSize: 48, fontWeight: '700' }}>{scoreB}</Text>
      </View>

      {/* 每一局趨勢（標題加上勝方） */}
      <View style={{ marginTop: 16 }}>
        <Text style={{ color:'#fff', fontSize:16, fontWeight:'600', marginBottom:8 }}>每局趨勢</Text>
        {series.length === 0 ? (
          <Text style={{ color:'#999' }}>尚無記錄資料</Text>
        ) : (
          series.map(sec => {
            const homeWins = sec.rows.reduce((acc, r) => acc + (r.win ? 1 : 0), 0);
            const awayWins = sec.rows.length - homeWins;
            const winTag = homeWins > awayWins ? '（主勝）' : awayWins > homeWins ? '（客勝）' : '';
            return (
              <TrendChart
                key={'g'+sec.game}
                title={`第 ${sec.game} 局趨勢${winTag}`}
                rows={sec.rows}
              />
            );
          })
        )}
      </View>
    </ScrollView>
  );
}
ezbmt-tracked/src/screens/JoinEventScreen.tsx
 
import React from 'react';
import { View, Text, TextInput, Pressable, Alert } from 'react-native';
import { joinEventByCode } from '../db';

export default function JoinEventScreen({ navigation }: any) {
const [code, setCode] = React.useState('');
const submit = async () => {
if (!code.trim()) return;
try {
await joinEventByCode(code.trim());
Alert.alert('成功', '已加入事件');
navigation.navigate('Events');
} catch (e: any) {
Alert.alert('失敗', String(e?.message || e));
}
};
return (
<View style={{ flex:1, padding:16 }}>
<Text style={{ fontSize:16, fontWeight:'600', marginBottom:8 }}>加入事件</Text>
<TextInput value={code} onChangeText={setCode} placeholder="輸入加入代碼" autoCapitalize="characters"
style={{ borderWidth:1, borderColor:'#ccc', borderRadius:8, paddingHorizontal:10, paddingVertical:8, marginBottom:10 }} />
<Pressable onPress={submit} style={{ backgroundColor:'#1976d2', paddingVertical:10, borderRadius:8, alignItems:'center' }}>
<Text style={{ color:'#fff' }}>加入</Text>
</Pressable>
</View>
);
}

ezbmt-tracked/src/screens/WebCamViewerScreen.tsx
 
import React from 'react';
import {
View,
Text,
Pressable,
Alert,
ActivityIndicator,
} from 'react-native';
import KeepAwake from 'react-native-keep-awake';
import { useRoute } from '@react-navigation/native';
import { openSignalChannel } from '../lib/webrtcSignal';
import {
RTCPeerConnection,
RTCView,
RTCSessionDescription,
RTCIceCandidate,
MediaStream,
} from 'react-native-webrtc';

const C = { bg: '#111', card: '#1e1e1e', border: '#333', text: '#fff', sub: '#bbb', btn: '#1976d2', warn: '#d32f2f' };
const ICE_SERVERS = {
iceServers: [
{ urls: ['stun:stun.l.google.com:19302',
'stun:stun1.l.google.com:19302',
'stun:stun2.l.google.com:19302',
'stun:stun3.l.google.com:19302',
'stun:stun4.l.google.com:19302'] },
],
};

export default function WebCamViewerScreen() {
const route = useRoute<any>();
const deviceId = route.params?.deviceId as string | undefined;
const displayName = route.params?.name as string | undefined;
const onlineInit = !!route.params?.online;

const [connecting, setConnecting] = React.useState(false);
const [connected, setConnected] = React.useState(false);
const [status] = React.useState(onlineInit ? 'online' : 'offline');
const [remoteStream, setRemoteStream] = React.useState<any>(null);

const pcRef = React.useRef<RTCPeerConnection | null>(null);
const signalRef = React.useRef<ReturnType<typeof openSignalChannel> | null>(null);

React.useEffect(() => {
const on = connecting || connected || !!remoteStream;
try { if (on) KeepAwake.activate(); else KeepAwake.deactivate(); } catch {}
return () => { try { KeepAwake.deactivate(); } catch {} };
}, [connecting, connected, remoteStream]);

React.useEffect(() => {
return () => { cleanup(); try { KeepAwake.deactivate(); } catch {} };
}, []);

function cleanup() {
try { signalRef.current?.close(); } catch {}
signalRef.current = null;
try { pcRef.current?.close(); } catch {}
pcRef.current = null;
try { setRemoteStream(null); } catch {}
setConnected(false);
setConnecting(false);
}

async function connect() {
if (!deviceId) return;
cleanup();
setConnecting(true);
try {
const pc = new RTCPeerConnection(ICE_SERVERS);
pcRef.current = pc;

  // Debug logs
  (pc as any).oniceconnectionstatechange = () => {
    console.log('[VIEWER][ICE] state =', pc.iceConnectionState);
  };
  (pc as any).onconnectionstatechange = () => {
    console.log('[VIEWER][PC] state =', pc.connectionState);
  };
  (pc as any).onicegatheringstatechange = () => {
    console.log('[VIEWER][ICE] gathering =', pc.iceGatheringState);
  };

  (pc as any).onicecandidate = (ev: any) => {
    if (ev?.candidate) {
      console.log('[VIEWER][ICE] send cand');
      signalRef.current?.send({ kind: 'ice', from: 'viewer', candidate: ev.candidate });
    } else {
      console.log('[VIEWER][ICE] cand = null (completed)');
    }
  };
  (pc as any).ontrack = (ev: any) => {
    let s = ev?.streams && ev.streams[0];
    if (!s && ev?.track) {
      const ms = new MediaStream();
      ms.addTrack(ev.track);
      s = ms;
    }
    if (s) setRemoteStream(s);
  };
  (pc as any).onaddstream = (ev: any) => {
    if (ev?.stream) setRemoteStream(ev.stream);
  };

  const signal = openSignalChannel(deviceId);
  signalRef.current = signal;

  await signal.subscribe(async (msg) => {
    try {
      if (!pcRef.current) return;
      if (msg.kind === 'answer' && msg.sdp) {
        console.log('[VIEWER] recv answer');
        await pcRef.current.setRemoteDescription(new RTCSessionDescription(msg.sdp));
      } else if (msg.kind === 'ice' && msg.candidate) {
        console.log('[VIEWER] recv cand');
        try { await pcRef.current.addIceCandidate(new RTCIceCandidate(msg.candidate)); } catch {}
      }
    } catch (e) {
      console.log('[VIEWER] signal error', e);
    }
  });

  const offer = await pc.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });
  await pc.setLocalDescription(offer);
  console.log('[VIEWER] send offer');
  await signal.send({ kind: 'offer', from: 'viewer', sdp: offer });
} catch (e: any) {
  Alert.alert('連線失敗', String(e?.message || e));
  cleanup();
} finally {
  setConnecting(false);
}
}

const canConnect = status === 'online' || onlineInit;

return (
<View style={{ flex: 1, backgroundColor: C.bg, padding: 12 }}>
<Text style={{ color: C.text, fontSize: 16, fontWeight: '800', marginBottom: 10 }}>
觀看：{displayName || (deviceId ? deviceId.slice(0, 8) + '…' : '')}
</Text>

  <View style={{ padding: 10, borderWidth: 1, borderColor: C.border, backgroundColor: C.card, borderRadius: 10, marginBottom: 10 }}>
    <Text style={{ color: C.text }}>Device ID：{deviceId || '-'}</Text>
    <Text style={{ color: canConnect ? '#90caf9' : '#bbb', marginTop: 6 }}>
      狀態：{canConnect ? 'online' : 'offline'}
    </Text>
    <View style={{ flexDirection: 'row', marginTop: 10 }}>
      <Pressable
        onPress={connect}
        disabled={!canConnect || connecting}
        style={{ paddingVertical: 8, paddingHorizontal: 12, borderRadius: 8, backgroundColor: !canConnect || connecting ? '#555' : C.btn }}
      >
        <Text style={{ color: '#fff' }}>{connecting ? '連線中…' : '連線'}</Text>
      </Pressable>
      <Pressable
        onPress={cleanup}
        style={{ paddingVertical: 8, paddingHorizontal: 12, borderRadius: 8, backgroundColor: C.warn, marginLeft: 8 }}
      >
        <Text style={{ color: '#fff' }}>中斷</Text>
      </Pressable>
    </View>
  </View>

  <View style={{ padding: 10, borderWidth: 1, borderColor: C.border, backgroundColor: C.card, borderRadius: 10, flex: 1 }}>
    <Text style={{ color: C.text, fontWeight: '700' }}>串流預覽</Text>
    {!remoteStream ? (
      <Text style={{ color: C.sub, marginTop: 8 }}>
        {canConnect ? '按「連線」開始接收影像' : '廣播端未上線或未廣播中'}
      </Text>
    ) : (
      <View style={{ flex: 1, marginTop: 8, borderRadius: 8, overflow: 'hidden', borderWidth: 1, borderColor: C.border }}>
        <RTCView streamURL={remoteStream.toURL()} style={{ flex: 1, backgroundColor: '#000' }} objectFit="cover" />
      </View>
    )}
  </View>
</View>
);
}ezbmt-tracked/src/screens/ChatScreen.tsx
 
import React from 'react';
import {
View,
Text,
FlatList,
TextInput,
Pressable,
KeyboardAvoidingView,
Platform,
ActivityIndicator,
NativeSyntheticEvent,
NativeScrollEvent,
} from 'react-native';
import { useRoute, useNavigation } from '@react-navigation/native';
import { useHeaderHeight } from '@react-navigation/elements';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import {
listChatMessages,
insertChatMessage,
getMatch,
getMatchPlayers,
listRalliesOrdered,
} from '../db';
import { supa, getCurrentUser } from '../lib/supabase';
import { deserialize, getUiSnapshot } from '../logic/serve';

type ChatItem = { id?: string; user?: string; text: string; created_at: string };

export default function ChatScreen() {
const route = useRoute<any>();
const navigation = useNavigation<any>();
const matchId = route.params?.matchId as string;

const headerHeight = useHeaderHeight();
const insets = useSafeAreaInsets();

const INPUT_BAR_H = 52;
const KAV_OFFSET = headerHeight;

const [items, setItems] = React.useState<ChatItem[]>([]);
const [name, setName] = React.useState('');
const [text, setText] = React.useState('');
const [loading, setLoading] = React.useState(true);

// 資訊卡
const [ui, setUi] = React.useState<any>(null);
const [meta, setMeta] = React.useState<{ type?: string; court?: string | null; singles?: boolean }>({});
const [playersMeta, setPlayersMeta] = React.useState<{ home: [string|null, string|null]; away: [string|null, string|null] }>({ home: [null, null], away: [null, null] });
const [gameSums, setGameSums] = React.useState<Array<{ g:number; home:number; away:number; winner:0|1|null }>>([]);
const [eventId, setEventId] = React.useState<string | null>(null);

// 初始暱稱
React.useEffect(() => {
let active = true;
(async () => {
try {
const u = await getCurrentUser();
if (!u || !active) return;
let preset = '';
try {
const { data } = await supa.from('profiles').select('name').eq('id', u.id).single();
if (data?.name && String(data.name).trim()) {
preset = String(data.name).trim();
} else if (u.email) {
preset = String(u.email).split('@')[0];
}
} catch {}
if (active && preset) setName(preset);
} catch {}
})();
return () => { active = false; };
}, []);

const load = React.useCallback(async () => {
try {
const rows = await listChatMessages(matchId, 200);
setItems(rows);
} finally {
setLoading(false);
}
}, [matchId]);

// Realtime + 輪詢
React.useEffect(() => {
let channel: ReturnType<typeof supa.channel> | null = null;
try {
channel = supa
.channel('chat-' + matchId)
.on(
'postgres_changes',
{ event: 'INSERT', schema: 'public', table: 'chat_messages', filter: 'match_id=eq.' + matchId },
(payload: any) => {
const r = payload?.new || {};
const msg: ChatItem = {
id: r.id,
user: r.user_name || r.user || '匿名',
text: r.text || '',
created_at: r.created_at || new Date().toISOString(),
};
setItems((prev) => [msg, ...prev]);
}
)
.subscribe();
} catch {}

load();
const t = setInterval(load, 3000);

return () => {
  clearInterval(t);
  if (channel) channel.unsubscribe();
};
}, [load, matchId]);

// 載入資訊卡內容（含 eventId）
React.useEffect(() => {
if (!matchId) return;
let active = true;

const loadMeta = async () => {
  try {
    const m = await getMatch(matchId);
    if (!active) return;
    setEventId(m?.event_id || null);

    const type = String(m?.type || '');
    const singles = type.endsWith('S');
    setMeta({ type, court: (m?.court_no ?? null), singles });

    const rows = await getMatchPlayers(matchId);
    const home:[string|null,string|null] = [null,null];
    const away:[string|null,string|null] = [null,null];
    (rows||[]).forEach((r:any)=> {
      const nm = r?.name || null;
      if (r.side==='home') home[r.idx] = nm; else if (r.side==='away') away[r.idx] = nm;
    });
    setPlayersMeta({ home, away });

    if (m && m.state_json) {
      try {
        const s = deserialize(m.state_json);
        setUi(getUiSnapshot(s));
      } catch {}
    }
  } catch {}
};

const refreshGameSums = async () => {
  try {
    const rows = await listRalliesOrdered(matchId);
    const byGame = new Map<number, { home:number; away:number }>();
    (rows||[]).forEach((r:any) => {
      const g = Number(r.game_index||0);
      const winHome = r.winner_side === 'home';
      const cur = byGame.get(g) || { home:0, away:0 };
      if (winHome) cur.home += 1; else cur.away += 1;
      byGame.set(g, cur);
    });
    const list = Array.from(byGame.entries())
      .map(([g, s]) => ({ g, home:s.home, away:s.away, winner: (s.home>s.away?0:s.away>s.home?1:null) as 0|1|null }))
      .sort((a,b)=> a.g-b.g);
    setGameSums(list);
  } catch {}
};

loadMeta();
refreshGameSums();
const t = setInterval(refreshGameSums, 3000);

return () => { active = false; clearInterval(t); };
}, [matchId]);

const send = async () => {
const txt = text.trim();
const nm = name.trim();
if (!txt) return;

const optimistic: ChatItem = {
  id: 'local-' + Date.now(),
  user: nm || '匿名',
  text: txt,
  created_at: new Date().toISOString(),
};
setItems((prev) => [optimistic, ...prev]);
setText('');

try {
  await insertChatMessage({ matchId, user: nm || '匿名', text: txt });
} catch {}
};

const onScroll = (_e: NativeSyntheticEvent<NativeScrollEvent>) => {};

const InfoCard = () => {
const singles = !!meta.singles;
const safe = (s: string|null|undefined, fb: string) => (s && String(s).trim()) || fb;
const h0 = safe(playersMeta.home[0], '主#1');
const h1 = safe(playersMeta.home[1], '主#2');
const a0 = safe(playersMeta.away[0], '客#1');
const a1 = safe(playersMeta.away[1], '客#2');

const server = ui?.server, receiver = ui?.receiver;
const label = (team:0|1, idx:0|1, base:string) => {
  const tags:string[] = [];
  if (server && server.team===team && server.index===idx) tags.push('發');
  if (receiver && receiver.team===team && receiver.index===idx) tags.push('接');
  return tags.length ? `${base}（${tags.join('、')}）` : base;
};

const homeLine = singles ? `主隊：${label(0,0,h0)}` : `主隊：${label(0,0,h0)}、${label(0,1,h1)}`;
const awayLine = singles ? `客隊：${label(1,0,a0)}` : `客隊：${label(1,0,a0)}、${label(1,1,a1)}`;

return (
  <View style={{ backgroundColor:'#222', borderRadius:12, padding:12, borderWidth:1, borderColor:'#333', marginBottom: 12 }}>
    <View style={{ flexDirection:'row', justifyContent:'space-between', alignItems:'center' }}>
      <Text style={{ color:'#fff', fontSize:16, fontWeight:'600' }}>
        類型：{meta.type || '-'}　場地：{meta.court || '-'}
      </Text>
      <View style={{ flexDirection:'row' }}>
        <Pressable
          onPress={() => navigation.navigate('Live', { matchId })}
          style={{ paddingVertical:6, paddingHorizontal:10, backgroundColor:'#1976d2', borderRadius:8, marginRight:8 }}
        >
          <Text style={{ color:'#fff' }}>即時分數</Text>
        </Pressable>
        <Pressable
          onPress={() => { if (eventId) navigation.navigate('Matches', { eventId }); }}
          style={{ paddingVertical:6, paddingHorizontal:10, backgroundColor:'#455a64', borderRadius:8 }}
        >
          <Text style={{ color:'#fff' }}>場次</Text>
        </Pressable>
      </View>
    </View>
    <Text style={{ color:'#ddd', marginTop:6 }}>{homeLine}</Text>
    <Text style={{ color:'#ddd', marginTop:4 }}>{awayLine}</Text>

    {!!gameSums.length && (
      <View style={{ flexDirection:'row', flexWrap:'wrap', marginTop:8 }}>
        {gameSums.map(g => {
          const winClr = g.winner === 0 ? '#1976d2' : g.winner === 1 ? '#d32f2f' : '#999';
          return (
            <View key={'g'+g.g} style={{ paddingVertical:4, paddingHorizontal:8, borderRadius:12, borderWidth:1, borderColor:'#333', backgroundColor:'#222', marginRight:6, marginBottom:6 }}>
              <Text style={{ color:'#fff' }}>G{g.g} {g.home}-{g.away}{g.winner!=null ? (g.winner===0 ? '（主）' : '（客）') : ''}</Text>
              <View style={{ position:'absolute', right:-2, top:-2, width:8, height:8, borderRadius:4, backgroundColor: winClr }} />
            </View>
          );
        })}
      </View>
    )}
  </View>
);
};

return (
<KeyboardAvoidingView
style={{ flex: 1, backgroundColor: '#111' }}
behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
keyboardVerticalOffset={KAV_OFFSET}
>
<View style={{ flex: 1, backgroundColor: '#111', paddingHorizontal: 12, paddingTop: 12 }}>
{/* 資訊卡 */}
<InfoCard />

    {/* 訊息清單 */}
    {loading ? (
      <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
        <ActivityIndicator color="#fff" />
      </View>
    ) : (
      <FlatList
        style={{ flex: 1 }}
        inverted
        data={items}
        keyExtractor={(i) => i.id || String(i.created_at)}
        keyboardShouldPersistTaps="handled"
        onScroll={onScroll}
        renderItem={({ item }) => (
          <View
            style={{
              padding: 10,
              borderRadius: 8,
              backgroundColor: '#222',
              marginBottom: 8,
            }}
          >
            <Text style={{ color: '#aaa', marginBottom: 4 }}>
              {item.user || '匿名'} · {new Date(item.created_at).toLocaleTimeString()}
            </Text>
            <Text style={{ color: '#fff' }}>{item.text}</Text>
          </View>
        )}
      />
    )}

    {/* 底部輸入列（非絕對定位，KAV 會推起） */}
    <View
      style={{
        marginTop: 8,
        flexDirection: 'row',
        alignItems: 'center',
        gap: 8,
        height: INPUT_BAR_H + (Platform.OS === 'ios' ? 0 : 0),
        backgroundColor: '#222',
        borderRadius: 10,
        paddingHorizontal: 8,
        paddingBottom: Math.max(0, insets.bottom),
        borderWidth: 1,
        borderColor: '#333',
      }}
    >
      <TextInput
        placeholder="名稱（可空）"
        placeholderTextColor="#888"
        value={name}
        onChangeText={setName}
        style={{
          width: 140,
          height: INPUT_BAR_H - 10,
          borderWidth: 1,
          borderColor: '#444',
          borderRadius: 8,
          paddingHorizontal: 10,
          color: '#fff',
          backgroundColor: '#111',
        }}
        autoCapitalize="none"
        returnKeyType="next"
      />
      <TextInput
        placeholder="輸入訊息…"
        placeholderTextColor="#888"
        value={text}
        onChangeText={setText}
        onSubmitEditing={send}
        style={{
          flex: 1,
          height: INPUT_BAR_H - 10,
          borderWidth: 1,
          borderColor: '#444',
          borderRadius: 8,
          paddingHorizontal: 10,
          color: '#fff',
          backgroundColor: '#111',
        }}
        returnKeyType="send"
        blurOnSubmit={false}
      />
      <Pressable
        onPress={send}
        disabled={!text.trim()}
        style={{
          backgroundColor: text.trim() ? '#1976d2' : '#555',
          paddingHorizontal: 16,
          height: INPUT_BAR_H - 10,
          borderRadius: 8,
          justifyContent: 'center',
        }}
      >
        <Text style={{ color: '#fff' }}>送出</Text>
      </Pressable>
    </View>
  </View>
</KeyboardAvoidingView>
);
}ezbmt-tracked/src/screens/SessionPairingScreen.tsx
 
import React from 'react';
import { View, Text, FlatList, Pressable, Alert, ScrollView } from 'react-native';
import { useRoute, useNavigation } from '@react-navigation/native';
import {
  listSessions,
  listSessionAttendees,
  listRounds,
  createRound,
  listRoundCourts,
  upsertRoundCourts,
  getMyClubRole,
} from '../db';
import { supa } from '../lib/supabase';

const C = { bg:'#111', card:'#1e1e1e', border:'#333', text:'#fff', sub:'#bbb', btn:'#1976d2', warn:'#d32f2f', gray:'#616161' };

type CourtRow = { id?: string; court_no: number; team_a_ids: string[]; team_b_ids: string[] };

export default function SessionPairingScreen() {
  const route = useRoute<any>();
  const navigation = useNavigation<any>();
  const sessionId = route.params?.sessionId as string;
  const clubId = route.params?.clubId as string;

  const [attendees, setAttendees] = React.useState<Array<{ id:string; buddy_id:string; display_name:string }>>([]);
  const [rounds, setRounds] = React.useState<any[]>([]);
  const [currentRoundId, setCurrentRoundId] = React.useState<string | null>(null);
  const [courts, setCourts] = React.useState<CourtRow[]>([]);
  const [sessionMeta, setSessionMeta] = React.useState<{ courts: number; round_minutes: number; date: string } | null>(null);

  const [pick, setPick] = React.useState<{ roundId: string; court: number; side: 'A'|'B'; idx: 0|1 } | null>(null);

  const [myRole, setMyRole] = React.useState<string | null>(null);
  const canPair = ['owner','admin','scheduler'].includes(String(myRole || ''));

  const load = React.useCallback(async ()=>{
    try {
      const [ss, as, rs] = await Promise.all([
        listSessions(clubId),
        listSessionAttendees(sessionId),
        listRounds(sessionId),
      ]);
      const s = (ss || []).find((x:any)=>x.id === sessionId);
      if (s) setSessionMeta({ courts: Number(s.courts||0), round_minutes: Number(s.round_minutes||0), date: String(s.date||'') });

      const attList = (as || []).map((r:any)=> ({
        id: String(r.id),
        buddy_id: String(r.buddy_id || ''),
        display_name: String(r.display_name || r.name || ''),
      }));
      setAttendees(attList);

      setRounds(rs);
      if (rs.length) {
        const last = rs[rs.length-1];
        setCurrentRoundId(last.id);
        const rows = await listRoundCourts(last.id);
        setCourts(normalizeCourts(rows));
      } else {
        setCurrentRoundId(null);
        setCourts([]);
      }
      try {
        const r = await getMyClubRole(clubId);
        setMyRole(r as any);
      } catch { setMyRole(null); }
    } catch (e:any) {
      Alert.alert('載入失敗', String(e?.message||e));
    }
  }, [clubId, sessionId]);

  React.useEffect(()=>{ load(); }, [load]);

  function normalizeCourts(rows:any[]): CourtRow[] {
    return (rows||[]).map((r:any)=>({
      id: r.id,
      court_no: Number(r.court_no||0),
      team_a_ids: Array.isArray(r.team_a_ids) ? r.team_a_ids : (r.team_a_ids||[]),
      team_b_ids: Array.isArray(r.team_b_ids) ? r.team_b_ids : (r.team_b_ids||[]),
    })).sort((a,b)=>a.court_no-b.court_no);
  }

  const nameOf = React.useCallback((id?: string) => {
    if (!id) return '';
    const a = attendees.find(x=>x.buddy_id === id);
    return a?.display_name || id.slice(0,6)+'…';
  }, [attendees]);

  const assignedSet = React.useMemo(() => {
    const s = new Set<string>();
    courts.forEach(r => { r.team_a_ids.forEach(id => id && s.add(id)); r.team_b_ids.forEach(id => id && s.add(id)); });
    return s;
  }, [courts]);

  const waiting = React.useMemo(() => {
    return attendees
      .map(a => a.buddy_id)
      .filter(id => id && !assignedSet.has(id));
  }, [attendees, assignedSet]);

  function getSeat(row: CourtRow, side:'A'|'B', idx:0|1): string|undefined {
    return side==='A' ? row.team_a_ids[idx] : row.team_b_ids[idx];
  }
  function setSeat(next: CourtRow[], courtNo:number, side:'A'|'B', idx:0|1, newId?: string): { next: CourtRow[]; prev?: string } {
    const row = next.find(r=>r.court_no===courtNo);
    if (!row) return { next };
    if (side==='A') {
      const prev = row.team_a_ids[idx];
      row.team_a_ids[idx] = newId || undefined as any;
      return { next, prev };
    } else {
      const prev = row.team_b_ids[idx];
      row.team_b_ids[idx] = newId || undefined as any;
      return { next, prev };
    }
  }
  function removeBuddyEverywhere(next: CourtRow[], buddyId: string) {
    next.forEach(r => {
      r.team_a_ids = r.team_a_ids.map(x => x === buddyId ? undefined as any : x);
      r.team_b_ids = r.team_b_ids.map(x => x === buddyId ? undefined as any : x);
    });
  }

  const selectSeat = (roundId: string, court: number, side: 'A'|'B', idx: 0|1) => {
    if (!canPair) return;
    const cur = pick;
    if (!cur) { setPick({ roundId, court, side, idx }); return; }
    if (cur.roundId !== roundId) { setPick({ roundId, court, side, idx }); return; }
    if (cur.roundId===roundId && cur.court===court && cur.side===side && cur.idx===idx) { setPick(null); return; }

    const next = courts.map(r => ({ ...r, team_a_ids:[...r.team_a_ids], team_b_ids:[...r.team_b_ids] }));
    const aRow = next.find(r=>r.court_no===cur.court);
    const bRow = next.find(r=>r.court_no===court);
    if (!aRow || !bRow) { setPick(null); return; }
    const aId = getSeat(aRow, cur.side, cur.idx);
    const bId = getSeat(bRow, side, idx);
    setSeat(next, cur.court, cur.side, cur.idx, bId);
    setSeat(next, court, side, idx, aId);
    setCourts(next);
    setPick(null);
  };

  const moveSeatToWaiting = (court:number, side:'A'|'B', idx:0|1) => {
    if (!canPair) return;
    const next = courts.map(r => ({ ...r, team_a_ids:[...r.team_a_ids], team_b_ids:[...r.team_b_ids] }));
    setSeat(next, court, side, idx, undefined);
    setCourts(next);
    if (pick && pick.court===court && pick.side===side && pick.idx===idx) setPick(null);
  };

  const placeWaitingToSeat = (buddyId: string) => {
    if (!canPair) return;
    if (!pick) { Alert.alert('提示','請先點選一個座位，再從等待區挑人填入'); return; }
    const next = courts.map(r => ({ ...r, team_a_ids:[...r.team_a_ids], team_b_ids:[...r.team_b_ids] }));
    removeBuddyEverywhere(next, buddyId);
    setSeat(next, pick.court, pick.side, pick.idx, buddyId);
    setCourts(next);
    setPick(null);
  };

  const autoFillSeats = () => {
    if (!canPair) return;
    const next = courts.map(r => ({ ...r, team_a_ids:[...r.team_a_ids], team_b_ids:[...r.team_b_ids] }));
    const pool = waiting.slice();
    const vacancies: Array<{ court:number; side:'A'|'B'; idx:0|1 }> = [];
    next.forEach(r => {
      (r.team_a_ids||[]).forEach((id, i)=>{ if (!id) vacancies.push({ court:r.court_no, side:'A', idx:i as 0|1 }); });
      (r.team_b_ids||[]).forEach((id, i)=>{ if (!id) vacancies.push({ court:r.court_no, side:'B', idx:i as 0|1 }); });
    });
    vacancies.forEach(v => {
      const b = pool.shift();
      if (b) setSeat(next, v.court, v.side, v.idx, b);
    });
    setCourts(next);
    setPick(null);
  };

  const saveCourts = async () => {
    if (!canPair) { Alert.alert('沒有權限','僅 owner/admin/scheduler 可儲存配對'); return; }
    try {
      if (!currentRoundId) return;
      await upsertRoundCourts(currentRoundId, courts);
      Alert.alert('已儲存', '本輪配對已更新');
    } catch (e:any) {
      Alert.alert('儲存失敗', String(e?.message||e));
    }
  };

  // 新增：清空本輪
  const clearCurrentRoundCourts = async () => {
    if (!canPair) { Alert.alert('沒有權限','僅 owner/admin/scheduler 可清空'); return; }
    if (!currentRoundId) return;
    Alert.alert('清空本輪', '確定要清空本輪所有場地的名單？', [
      { text: '取消', style: 'cancel' },
      { text: '清空', style: 'destructive', onPress: async () => {
        try {
          await supa.from('round_courts').delete().eq('round_id', currentRoundId);
          const rows = await listRoundCourts(currentRoundId);
          setCourts(normalizeCourts(rows));
          setPick(null);
          Alert.alert('已清空', '本輪名單已清除');
        } catch (e:any) {
          Alert.alert('清空失敗', String(e?.message || e));
        }
      } }
    ]);
  };

  // 新增：從上一輪拷貝
  const copyFromPreviousRound = async () => {
    if (!canPair) { Alert.alert('沒有權限','僅 owner/admin/scheduler 可拷貝'); return; }
    if (!currentRoundId) return;
    try {
      // 找當前輪的 index_no
      const cur = rounds.find((r:any)=> r.id === currentRoundId);
      if (!cur) { Alert.alert('拷貝失敗','找不到目前輪'); return; }
      const curIdxNo = Number(cur.index_no || 0);
      const prev = rounds.find((r:any)=> Number(r.index_no||0) === (curIdxNo - 1));
      if (!prev) { Alert.alert('沒有上一輪','目前是第一輪或找不到上一輪'); return; }

      const prevRows = await listRoundCourts(prev.id);
      const payload = (prevRows || []).map((r:any)=> ({
        court_no: Number(r.court_no||0),
        team_a_ids: Array.isArray(r.team_a_ids) ? r.team_a_ids : (r.team_a_ids||[]),
        team_b_ids: Array.isArray(r.team_b_ids) ? r.team_b_ids : (r.team_b_ids||[]),
      }));
      if (!payload.length) { Alert.alert('上一輪沒有資料','上一輪無名單可拷貝'); return; }

      await upsertRoundCourts(currentRoundId, payload);
      const rows = await listRoundCourts(currentRoundId);
      setCourts(normalizeCourts(rows));
      setPick(null);
      Alert.alert('已拷貝', '已從上一輪拷貝名單至本輪');
    } catch (e:any) {
      Alert.alert('拷貝失敗', String(e?.message || e));
    }
  };

  const generateNextRound = async () => {
    if (!canPair) { Alert.alert('沒有權限','僅 owner/admin/scheduler 可產生下一輪'); return; }
    try {
      const rs = rounds;
      const lastIndex = rs.length ? rs[rs.length-1].index_no : 0;
      const nextIndex = lastIndex + 1;
      const newRoundId = await createRound({ sessionId, indexNo: nextIndex });

      const courtCount = Math.max(1, Number(sessionMeta?.courts||1));
      const rows = Array.from({ length: courtCount }, (_, i) => ({
        court_no: i+1,
        team_a_ids: [],
        team_b_ids: [],
      }));
      await upsertRoundCourts(newRoundId, rows);

      await load();
      setCurrentRoundId(newRoundId);
      const rc = await listRoundCourts(newRoundId);
      setCourts(normalizeCourts(rc));
      Alert.alert('成功', `已產生第 ${nextIndex} 輪（空場地）`);
    } catch (e:any) {
      Alert.alert('產生失敗', String(e?.message||e));
    }
  };

  const openRound = async (roundId:string) => {
    try {
      setCurrentRoundId(roundId);
      const rows = await listRoundCourts(roundId);
      setCourts(normalizeCourts(rows));
      setPick(null);
    } catch (e:any) {
      Alert.alert('讀取失敗', String(e?.message||e));
    }
  };

  function Seat({ side, idx, id, court }: { side:'A'|'B'; idx:0|1; id?:string; court:number }) {
    const selected = pick && pick.roundId===currentRoundId && pick.court===court && pick.side===side && pick.idx===idx;
    return (
      <View style={{ flex:1, marginRight: idx===0 ? 8 : 0 }}>
        <Pressable
          onPress={()=>selectSeat(currentRoundId!, court, side, idx)}
          disabled={!canPair}
          style={{
            paddingVertical:10, borderWidth:2, borderColor: selected ? '#90caf9' : '#444',
            borderRadius:8, backgroundColor:'#2b2b2b', alignItems:'center', opacity: canPair?1:0.6
          }}
        >
          <Text style={{ color:'#fff' }}>{nameOf(id)}</Text>
        </Pressable>
        <View style={{ flexDirection:'row', marginTop:6 }}>
          <Pressable onPress={()=>moveSeatToWaiting(court, side, idx)} disabled={!canPair || !id}
            style={{ paddingVertical:6, paddingHorizontal:8, borderRadius:6, borderWidth:1, borderColor:'#666', marginRight:6, opacity: (!canPair || !id)?0.5:1 }}>
            <Text style={{ color:'#ddd' }}>→等待</Text>
          </Pressable>
          <Pressable onPress={()=>{
            if (!canPair) return;
            const next = courts.map(r => ({ ...r, team_a_ids:[...r.team_a_ids], team_b_ids:[...r.team_b_ids] }));
            setSeat(next, court, side, idx, undefined);
            setCourts(next);
            if (selected) setPick(null);
          }} disabled={!canPair || !id}
            style={{ paddingVertical:6, paddingHorizontal:8, borderRadius:6, borderWidth:1, borderColor:'#666', opacity: (!canPair || !id)?0.5:1 }}>
            <Text style={{ color:'#ddd' }}>清空</Text>
          </Pressable>
        </View>
      </View>
    );
  }

  function CourtCard({ item }: { item: CourtRow }) {
    return (
      <View style={{ padding:10, borderWidth:1, borderColor:C.border, backgroundColor:C.card, borderRadius:10, marginBottom:10 }}>
        <Text style={{ color:C.text, fontWeight:'700', marginBottom:8 }}>第 {item.court_no} 場地</Text>
        <View style={{ flexDirection:'row', marginBottom:8 }}>
          <Seat side="A" idx={0} id={item.team_a_ids[0]} court={item.court_no} />
          <Seat side="A" idx={1} id={item.team_a_ids[1]} court={item.court_no} />
        </View>
        <View style={{ flexDirection:'row' }}>
          <Seat side="B" idx={0} id={item.team_b_ids[0]} court={item.court_no} />
          <Seat side="B" idx={1} id={item.team_b_ids[1]} court={item.court_no} />
        </View>
        <View style={{ flexDirection:'row', marginTop:10 }}>
          <Pressable
            onPress={()=>navigation.navigate('ClubScoreboard', { roundId: currentRoundId, courtNo: item.court_no, courts: Number(sessionMeta?.courts || 0) })}
            style={{ backgroundColor:C.btn, paddingVertical:8, paddingHorizontal:12, borderRadius:8, marginRight:8 }}
          >
            <Text style={{ color:'#fff' }}>啟動計分板</Text>
          </Pressable>
        </View>
      </View>
    );
  }

  const WaitingItem = ({ id }: { id:string }) => (
    <Pressable
      onPress={()=>placeWaitingToSeat(id)}
      disabled={!canPair || !pick}
      style={{ paddingVertical:8, paddingHorizontal:10, borderWidth:1, borderColor:'#555', borderRadius:8, backgroundColor:'#1f1f1f', marginRight:8, marginBottom:8, opacity: (!canPair || !pick) ? 0.6 : 1 }}
    >
      <Text style={{ color:'#fff' }}>{nameOf(id)}</Text>
    </Pressable>
  );

  return (
    <View style={{ flex:1, backgroundColor:C.bg, padding:12 }}>
      <Text style={{ color:C.text, fontSize:16, fontWeight:'700', marginBottom:8 }}>排點（{sessionMeta?.date || ''}）</Text>

      <View style={{ flexDirection:'row', flexWrap:'wrap', marginBottom:10 }}>
        {rounds.map((r:any)=>(
          <Pressable
            key={r.id}
            onPress={()=>openRound(r.id)}
            style={{
              paddingVertical:6, paddingHorizontal:12, borderRadius:14,
              borderWidth:1, borderColor: (currentRoundId===r.id)? '#90caf9':'#555',
              backgroundColor: (currentRoundId===r.id)? 'rgba(144,202,249,0.15)':C.card,
              marginRight:8, marginBottom:8
            }}
          >
            <Text style={{ color:'#fff' }}>第 {r.index_no} 輪</Text>
          </Pressable>
        ))}

        {canPair && (
          <Pressable onPress={generateNextRound} style={{ paddingVertical:6, paddingHorizontal:12, borderRadius:14, backgroundColor:C.btn }}>
            <Text style={{ color:'#fff' }}>產生下一輪</Text>
          </Pressable>
        )}
      </View>

      <View style={{ flex:1, flexDirection:'row' }}>
        <View style={{ flex: 3, paddingRight: 8 }}>
          <FlatList
            data={courts}
            keyExtractor={(i)=>String(i.court_no)}
            renderItem={({ item }) => <CourtCard item={item} />}
            ListFooterComponent={
              currentRoundId ? (
                <View style={{ marginTop:8 }}>
                  {canPair ? (
                    <View style={{ flexDirection:'row', flexWrap:'wrap' }}>
                      <Pressable onPress={saveCourts} style={{ backgroundColor:C.btn, paddingVertical:10, borderRadius:8, alignItems:'center', flexBasis:'48%', marginRight:'4%', marginBottom:8 }}>
                        <Text style={{ color:'#fff' }}>儲存本輪配對</Text>
                      </Pressable>
                      <Pressable onPress={autoFillSeats} style={{ backgroundColor:'#00695c', paddingVertical:10, borderRadius:8, alignItems:'center', flexBasis:'48%', marginBottom:8 }}>
                        <Text style={{ color:'#fff' }}>自動補滿</Text>
                      </Pressable>
                      <Pressable onPress={clearCurrentRoundCourts} style={{ backgroundColor:'#8d6e63', paddingVertical:10, borderRadius:8, alignItems:'center', flexBasis:'48%', marginRight:'4%', marginBottom:8 }}>
                        <Text style={{ color:'#fff' }}>清空本輪</Text>
                      </Pressable>
                      <Pressable onPress={copyFromPreviousRound} style={{ backgroundColor:'#5c6bc0', paddingVertical:10, borderRadius:8, alignItems:'center', flexBasis:'48%', marginBottom:8 }}>
                        <Text style={{ color:'#fff' }}>從上一輪拷貝</Text>
                      </Pressable>
                    </View>
                  ) : (
                    <View style={{ paddingVertical:10, borderRadius:8, alignItems:'center', borderWidth:1, borderColor:'#444' }}>
                      <Text style={{ color:'#888' }}>僅可檢視</Text>
                    </View>
                  )}
                </View>
              ) : null
            }
          />
        </View>

        <View style={{ flex: 2, paddingLeft: 8 }}>
          <View style={{ padding:10, borderWidth:1, borderColor:C.border, backgroundColor:C.card, borderRadius:10, marginBottom:10 }}>
            <Text style={{ color:'#fff', fontWeight:'700', marginBottom:6 }}>等待區（{waiting.length}）</Text>
            {waiting.length === 0 ? (
              <Text style={{ color:'#888' }}>目前沒有等待中的球友</Text>
            ) : (
              <View style={{ flexDirection:'row', flexWrap:'wrap' }}>
                {waiting.map(id => <WaitingItem key={id} id={id} />)}
              </View>
            )}
            {pick ? (
              <Text style={{ color:'#90caf9', marginTop:6 }}>已選座位：第 {pick.court} 場地 {pick.side}#{pick.idx+1}（點等待區球友以填入）</Text>
            ) : (
              <Text style={{ color:'#888', marginTop:6 }}>先在左側點選一個座位，再從這裡選人</Text>
            )}
          </View>
        </View>
      </View>
    </View>
  );
}
ezbmt-tracked/src/screens/ClubBoardScreen.tsx
 
import React from 'react';
import { View, Text, ScrollView, Pressable, ActivityIndicator, StatusBar, Alert } from 'react-native';
import { useRoute, useNavigation } from '@react-navigation/native';
import { listProjection } from '../db';
import { supa } from '../lib/supabase';
import { exportSessionCsv, exportSessionPdf } from '../lib/exportSession';

const C = { bg: '#111', card: '#1e1e1e', border: '#333', text: '#fff', sub: '#bbb', btn: '#1976d2' };

type MatchItem = {
court_no: number;
team_a: { players: Array<{ id:string; name:string }> };
team_b: { players: Array<{ id:string; name:string }> };
};
type Projection = {
server_time: string;
next?: { index: number; planned_start_at?: string|null; matchesPreview: MatchItem[] } | null;
};

type CourtNames = { aNames: string[]; bNames: string[] };
type CourtDisplay = {
courtNo: number;
current?: { roundIndex: number; roundId: string; names: CourtNames };
next?: { roundIndex: number; roundId: string; names: CourtNames };
};

export default function ClubBoardScreen() {
const route = useRoute<any>();
const navigation = useNavigation<any>();
const sessionId: string | undefined = route.params?.sessionId;

const [loading, setLoading] = React.useState(true);
const [proj, setProj] = React.useState<Projection | null>(null);
const [offsetMs, setOffsetMs] = React.useState<number>(0);
const [countdown, setCountdown] = React.useState<string>('');

const [courts, setCourts] = React.useState<number>(0);
const [perCourt, setPerCourt] = React.useState<CourtDisplay[]>([]);
const [refreshing, setRefreshing] = React.useState(false);

const fetchAll = React.useCallback(async () => {
if (!sessionId) return;
setRefreshing(true);
try {
let courtCount = 0;
try {
const { data: srow } = await supa.from('sessions').select('courts').eq('id', sessionId).maybeSingle();
courtCount = Number(srow?.courts || 0) || 0;
} catch {}
setCourts(courtCount);

  try {
    const data = await listProjection(sessionId);
    setProj(data as any);
    const server = new Date((data as any)?.server_time || new Date());
    setOffsetMs(server.getTime() - Date.now());
  } catch {
    setProj(null);
    setOffsetMs(0);
  }

  const pc = await buildPerCourtDisplays(sessionId, courtCount);
  setPerCourt(pc);
} finally {
  setLoading(false);
  setRefreshing(false);
}
}, [sessionId]);

React.useEffect(() => {
if (!sessionId) return;
fetchAll().catch(()=>{});

let channel: any = null;
try {
  channel = supa
    .channel('club-board-' + sessionId)
    .on('postgres_changes', { event: '*', schema: 'public', table: 'round_results' }, () => fetchAll().catch(()=>{}))
    .on('postgres_changes', { event: '*', schema: 'public', table: 'round_courts' }, () => fetchAll().catch(()=>{}))
    .on('postgres_changes', { event: '*', schema: 'public', table: 'round_matches' }, () => fetchAll().catch(()=>{}))
    .on('postgres_changes', { event: '*', schema: 'public', table: 'session_rounds' }, () => fetchAll().catch(()=>{}))
    .subscribe();
} catch {}

const t = setInterval(() => fetchAll().catch(()=>{}), 5000);
return () => {
  clearInterval(t);
  try { channel?.unsubscribe(); } catch {}
};
}, [sessionId, fetchAll]);

React.useEffect(() => {
const t = setInterval(() => tick(), 1000);
return () => clearInterval(t);
}, [proj, offsetMs]);

function tick() {
const n = proj?.next?.planned_start_at ? new Date(proj.next.planned_start_at) : null;
if (!n) { setCountdown(''); return; }
const diff = n.getTime() - (Date.now() + offsetMs);
if (diff <= 0) { setCountdown('00:00'); return; }
const s = Math.floor(diff / 1000);
const mm = String(Math.floor(s/60)).padStart(2,'0');
const ss = String(s%60).padStart(2,'0');
setCountdown(`${mm}:${ss}`);
}

if (!sessionId || loading) {
return (
<View style={{ flex:1, backgroundColor:C.bg, alignItems:'center', justifyContent:'center' }}>
<ActivityIndicator color="#90caf9" />
</View>
);
}

const next = proj?.next;
const nextMatches = next?.matchesPreview || [];

const doExportCsv = async () => {
try {
await exportSessionCsv(sessionId!);
} catch (e: any) {
Alert.alert('匯出失敗', String(e?.message || e));
}
};
const doExportPdf = async () => {
try {
await exportSessionPdf(sessionId!);
} catch (e: any) {
Alert.alert('匯出失敗', String(e?.message || e));
}
};

return (
<View style={{ flex:1, backgroundColor:C.bg }}>
<StatusBar barStyle="light-content" />
<ScrollView contentContainerStyle={{ padding: 12 }}>
{/* 全域倒數 + 匯出鈕 */}
<View style={{ flexDirection:'row', alignItems:'center', marginBottom: 6 }}>
<Text style={{ color:'#fff', fontSize: 20, fontWeight:'800', flex: 1 }}>
{next ? `下一輪（全域）：第 ${next.index} 輪` : '下一輪（全域） ─'}
</Text>
<Pressable onPress={doExportCsv} style={{ paddingVertical:6, paddingHorizontal:10, borderRadius:8, backgroundColor:'#0288d1', marginRight:8 }}>
<Text style={{ color:'#fff' }}>匯出 CSV</Text>
</Pressable>
<Pressable onPress={doExportPdf} style={{ paddingVertical:6, paddingHorizontal:10, borderRadius:8, backgroundColor:'#5c6bc0' }}>
<Text style={{ color:'#fff' }}>匯出 PDF</Text>
</Pressable>
</View>

    {!!countdown && (
      <Text style={{ color:'#ffecb3', fontSize: 36, fontWeight: '800', marginBottom: 8 }}>
        開賽倒數 {countdown}
      </Text>
    )}

    <Text style={{ color:'#fff', fontSize: 20, fontWeight:'800', marginTop:10, marginBottom:8 }}>目前各場地名單（逐場地前進）</Text>
    {courts <= 0 ? (
      <Text style={{ color:'#888' }}>本場次未設定球場數</Text>
    ) : perCourt.length === 0 ? (
      <Text style={{ color:'#888' }}>尚無輪次</Text>
    ) : (
      <View style={{ flexDirection:'row', flexWrap:'wrap', justifyContent:'space-between' }}>
        {perCourt.map((c) => (
          <View key={'court-'+c.courtNo} style={{
            width: '49%',
            minWidth: 280,
            padding: 12,
            backgroundColor: '#1f1f1f',
            borderRadius: 12,
            borderWidth: 1,
            borderColor: '#333',
            marginBottom: 10,
          }}>
            <Text style={{ color:'#fff', fontSize: 18, fontWeight:'800', marginBottom: 8 }}>
              場地 {c.courtNo}
            </Text>

            {c.current ? (
              <>
                <Text style={{ color:'#bbb', marginBottom: 4 }}>目前：第 {c.current.roundIndex} 輪</Text>
                <Text style={{ color:'#90caf9', fontSize: 16, fontWeight: '700' }}>
                  {c.current.names.aNames.join('、 ')}
                </Text>
                <Text style={{ color:'#ddd', marginVertical: 6, fontSize: 16, textAlign: 'center' }}>
                  VS
                </Text>
                <Text style={{ color:'#ef9a9a', fontSize: 16, fontWeight: '700' }}>
                  {c.current.names.bNames.join('、 ')}
                </Text>

                <View style={{ marginTop: 10 }}>
                  <Pressable
                    onPress={() => {
                      navigation.navigate('ClubScoreboard', {
                        roundId: c.current!.roundId,
                        courtNo: c.courtNo,
                        courts: courts,
                      });
                    }}
                    style={{ paddingVertical: 8, paddingHorizontal: 12, backgroundColor: C.btn, borderRadius: 8 }}
                  >
                    <Text style={{ color:'#fff' }}>啟動計分板</Text>
                  </Pressable>
                </View>
              </>
            ) : (
              <Text style={{ color:'#888' }}>目前：無（此場地所有輪已結束）</Text>
            )}

            {c.next ? (
              <View style={{ marginTop: 8 }}>
                <Text style={{ color:'#bbb', marginBottom: 4 }}>預告：第 {c.next.roundIndex} 輪</Text>
                <Text style={{ color:'#90caf9' }}>
                  {c.next.names.aNames.join('、 ')}
                </Text>
                <Text style={{ color:'#ddd', textAlign: 'center', marginVertical: 4 }}>VS</Text>
                <Text style={{ color:'#ef9a9a' }}>
                  {c.next.names.bNames.join('、 ')}
                </Text>
              </View>
            ) : (
              <Text style={{ color:'#555', marginTop: 8 }}>預告：—</Text>
            )}
          </View>
        ))}
      </View>
    )}

    <Text style={{ color:'#fff', fontSize: 20, fontWeight:'800', marginTop:10, marginBottom:6 }}>
      全域下一輪預覽
    </Text>
    {nextMatches.length > 0 ? (
      <View style={{ flexDirection:'row', flexWrap:'wrap', justifyContent:'space-between' }}>
        {nextMatches.map((m, idx) => (
          <View key={'next-'+idx} style={{
            width: '49%', minWidth: 280, padding:12,
            backgroundColor: '#1f1f1f', borderRadius: 12, borderWidth: 1, borderColor: '#333', marginBottom:10
          }}>
            <Text style={{ color:'#fff', fontSize:18, fontWeight:'800', marginBottom:8 }}>場地 {m.court_no}</Text>
            <Text style={{ color:'#90caf9', fontSize:16, fontWeight:'700' }}>
              {(m.team_a?.players||[]).map(p=>p.name).join('、 ')}
            </Text>
            <Text style={{ color:'#ddd', textAlign:'center', marginVertical:6, fontSize:16 }}>
              VS
            </Text>
            <Text style={{ color:'#ef9a9a', fontSize:16, fontWeight:'700' }}>
              {(m.team_b?.players||[]).map(p=>p.name).join('、 ')}
            </Text>
          </View>
        ))}
      </View>
    ) : (
      <Text style={{ color: '#888' }}>尚無預覽對戰</Text>
    )}
  </ScrollView>
</View>
);
}

async function buildPerCourtDisplays(sessionId: string, courts: number): Promise<CourtDisplay[]> {
const out: CourtDisplay[] = [];
if (!sessionId || courts <= 0) return out;

const { data: rounds } = await supa
.from('session_rounds')
.select('id,index_no')
.eq('session_id', sessionId)
.order('index_no', { ascending: true });

const rlist = (rounds || []).map((r:any) => ({ id: String(r.id), index: Number(r.index_no || 0) }));
if (!rlist.length) return out;

const roundIds = rlist.map(r => r.id);

const { data: rr } = await supa
.from('round_results')
.select('round_id,court_no,finished_at')
.in('round_id', roundIds as any);

const finished = new Set<string>();
(rr || []).forEach((row:any) => {
const fin = !!row.finished_at;
if (fin) finished.add(keyRC(row.round_id, Number(row.court_no)));
});

const { data: rms } = await supa
.from('round_matches')
.select('round_id,court_no,team_a,team_b')
.in('round_id', roundIds as any);

const matchMap = new Map<string, CourtNames>();
(rms || []).forEach((m:any) => {
const key = keyRC(m.round_id, Number(m.court_no));
const aNames = ((m.team_a?.players)||[]).map((p:any)=> String(p?.name || ''));
const bNames = ((m.team_b?.players)||[]).map((p:any)=> String(p?.name || ''));
matchMap.set(key, { aNames, bNames });
});

const { data: rcs } = await supa
.from('round_courts')
.select('round_id,court_no,team_a_ids,team_b_ids')
.in('round_id', roundIds as any);

const courtsMap = new Map<string, { aIds: string[]; bIds: string[] }>();
const allIds = new Set<string>();
(rcs || []).forEach((row:any) => {
const key = keyRC(row.round_id, Number(row.court_no));
const aIds = Array.isArray(row.team_a_ids) ? row.team_a_ids.map(String) : [];
const bIds = Array.isArray(row.team_b_ids) ? row.team_b_ids.map(String) : [];
courtsMap.set(key, { aIds, bIds });
aIds.concat(bIds).forEach((id:string)=> allIds.add(id));
});

let buddyName: Record<string,string> = {};
if (allIds.size > 0) {
const ids = Array.from(allIds);
const { data: buds } = await supa
.from('buddies')
.select('id,name')
.in('id', ids as any);
buddyName = Object.fromEntries((buds||[]).map((b:any)=> [String(b.id), String(b.name || '')]));
}

const namesOf = (roundId: string, courtNo: number): CourtNames => {
const k = keyRC(roundId, courtNo);
const direct = matchMap.get(k);
if (direct) return direct;
const co = courtsMap.get(k);
if (!co) return { aNames: [], bNames: [] };
const mapNames = (ids: string[]) => ids.map(id => buddyName[id] || (id ? id.slice(0,6)+'…' : ''));
return { aNames: mapNames(co.aIds), bNames: mapNames(co.bIds) };
};

for (let c = 1; c <= courts; c++) {
let curIdx = -1;
for (let i = 0; i < rlist.length; i++) {
const r = rlist[i];
const done = finished.has(keyRC(r.id, c));
if (!done) { curIdx = i; break; }
}

let cur: CourtDisplay['current'] | undefined = undefined;
let nxt: CourtDisplay['next'] | undefined = undefined;

if (curIdx >= 0) {
  const r = rlist[curIdx];
  cur = { roundIndex: r.index, roundId: r.id, names: namesOf(r.id, c) };
  if (curIdx + 1 < rlist.length) {
    const n = rlist[curIdx + 1];
    nxt = { roundIndex: n.index, roundId: n.id, names: namesOf(n.id, c) };
  }
} else {
  cur = undefined;
  nxt = undefined;
}

out.push({ courtNo: c, current: cur, next: nxt });
}

return out;
}

function keyRC(roundId: string, courtNo: number) { return `${roundId}#${courtNo}`; }

ezbmt-tracked/src/screens/ClubMediaScreen.tsx
 
import React from 'react';
import { View, Text, FlatList, TextInput, Pressable, Alert, Linking, Image, KeyboardAvoidingView, Platform } from 'react-native';
import { useRoute } from '@react-navigation/native';
import { useHeaderHeight } from '@react-navigation/elements';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { listClubMedia, insertClubMedia, deleteMedia, getMyClubRole } from '../db';
import { launchImageLibrary, Asset } from 'react-native-image-picker';
import { uploadImageFromUri, getPublicUrl, removeFile, publicUrlToPath } from '../lib/storage';
import YoutubePlayer from 'react-native-youtube-iframe';

const C = { bg:'#111', card:'#222', border:'#333', field:'#111', fieldBorder:'#444', text:'#fff', sub:'#ddd', hint:'#888' };

function getYouTubeId(url: string): string | null {
try {
const u = new URL(url);
if (u.hostname.includes('youtu.be')) return u.pathname.replace('/','') || null;
if (u.hostname.includes('youtube.com')) {
const v = u.searchParams.get('v'); if (v) return v;
const m = u.pathname.match(`//(embed|shorts)/([A-Za-z0-9_-]{6,})/`);
if (m && m[2]) return m[2];
}
} catch {}
return null;
}

export default function ClubMediaScreen() {
const route = useRoute<any>();
const headerHeight = useHeaderHeight();
const insets = useSafeAreaInsets();
const clubId = route.params?.clubId as string;

const [items, setItems] = React.useState<Array<{ id:string; kind:'youtube'|'photo'|string; url:string; description?:string }>>([]);
const [yt, setYt] = React.useState(''); const [desc, setDesc] = React.useState('');
const [playId, setPlayId] = React.useState<string|null>(null);

const [canEdit, setCanEdit] = React.useState<boolean>(false);
const [roleChecked, setRoleChecked] = React.useState<boolean>(false);
const [uploading, setUploading] = React.useState<boolean>(false);

const load = React.useCallback(async ()=>{
try { setItems(await listClubMedia(clubId)); } catch {}
}, [clubId]);

React.useEffect(()=>{ load(); }, [load]);

// 判定可編輯（社長/管理員）
React.useEffect(()=> {
let cancelled = false;
(async () => {
try {
const role = await getMyClubRole(clubId);
if (!cancelled) { setCanEdit(['owner','admin'].includes(String(role))); setRoleChecked(true); }
} catch { if (!cancelled) { setCanEdit(false); setRoleChecked(true); } }
})();
return ()=>{ cancelled = true; };
}, [clubId]);

const addYoutube = async () => {
if (!canEdit) { Alert.alert('沒有權限', '僅社長/管理員可新增媒體'); return; }
const url = yt.trim(); if (!url) return;
if (!/^(https?:\/\/)?(www.)?(youtube.com|youtu.be)\//i.test(url)) {
Alert.alert('URL 格式錯誤','請輸入有效的 YouTube 連結'); return;
}
try {
await insertClubMedia({ clubId, kind: 'youtube', url, description: desc.trim()||undefined });
setYt(''); setDesc(''); load();
} catch (e:any) {
Alert.alert('新增失敗', String(e?.message || e));
}
};

const pickAndUploadPhoto = async () => {
if (!canEdit) { Alert.alert('沒有權限', '僅社長/管理員可新增媒體'); return; }
try {
const res = await launchImageLibrary({ mediaType:'photo', selectionLimit:1, quality:0.9 });
if (res.didCancel) return;
const asset: Asset|undefined = res.assets?.[0];
if (!asset?.uri) return;
setUploading(true);
const mime = asset.type || 'image/jpeg';
const extFromName = (asset.fileName||'').split('.').pop()?.toLowerCase();
const extFromMime = mime.split('/').pop()?.toLowerCase();
const ext = extFromName && extFromName.length<=5 ? extFromName : (extFromMime || 'jpg');

  const path = `club/${clubId}/${Date.now()}-${Math.floor(Math.random()*1e7)}.${ext}`;
  const storagePath = await uploadImageFromUri(asset.uri, path, mime);
  const publicUrl = getPublicUrl(storagePath);
  await insertClubMedia({ clubId, kind: 'photo', url: publicUrl, description: undefined });
  await load();
  Alert.alert('成功','照片已上傳');
} catch (e:any) {
  Alert.alert('上傳失敗', String(e?.message||e));
} finally {
  setUploading(false);
}
};

const removeItem = async (item: { id:string; kind:string; url:string }) => {
if (!canEdit) { Alert.alert('沒有權限', '僅社長/管理員可刪除媒體'); return; }
try {
if (item.kind === 'photo') {
const p = publicUrlToPath(item.url);
if (p) { try { await removeFile(p); } catch {} }
}
await deleteMedia(item.id);
const id = getYouTubeId(item.url); if (id && id === playId) setPlayId(null);
await load();
} catch (e:any) { Alert.alert('刪除失敗', String(e?.message||e)); }
};

const renderYouTube = (url: string) => {
const id = getYouTubeId(url);
if (!id) {
return (
<Pressable onPress={()=>Linking.openURL(url)}>
<Text style={{ color:'#90caf9' }} numberOfLines={1}>{url}</Text>
</Pressable>
);
}
if (playId === id) {
return (
<View style={{ marginTop:6, borderRadius:8, overflow:'hidden', backgroundColor:'#000' }}>
<YoutubePlayer
height={220}
play={true}
videoId={id}
onChangeState={(s: string) => { if (s === 'ended') setPlayId(null); }}
webViewStyle={{ backgroundColor:'#000' }}
forceAndroidAutoplay={false}
webViewProps={{ allowsFullscreenVideo:true, allowsInlineMediaPlayback:true, mediaPlaybackRequiresUserAction:false }}
/>
</View>
);
}
return (
<Pressable onPress={()=>setPlayId(id)} style={{ borderRadius:8, overflow:'hidden', backgroundColor:'#000', marginTop:6 }}>
<Image source={{ uri:`https://img.youtube.com/vi/${id}/hqdefault.jpg` }} style={{ width:'100%', height:180, backgroundColor:'#333' }} resizeMode="cover" />
<View style={{ position:'absolute', left:0,right:0,top:0,bottom:0, justifyContent:'center', alignItems:'center' }}>
<View style={{ width:58, height:58, borderRadius:29, backgroundColor:'rgba(0,0,0,0.6)', justifyContent:'center', alignItems:'center' }}>
<View style={{ marginLeft:4, width:0, height:0, borderLeftWidth:14, borderLeftColor:'#fff', borderTopWidth:10, borderTopColor:'transparent', borderBottomWidth:10, borderBottomColor:'transparent' }} />
</View>
</View>
</Pressable>
);
};

const renderRow = ({ item }: { item: any }) => (
<View style={{ padding:10, borderWidth:1, borderColor:C.border, backgroundColor:C.card, borderRadius:8, marginBottom:8 }}>
<Text style={{ color:C.text, fontWeight:'600' }}>{item.kind==='youtube'?'YouTube':'照片'}</Text>
{item.kind === 'photo'
? <Image source={{ uri:item.url }} style={{ width:'100%', height:180, borderRadius:8, backgroundColor:'#333', marginTop:6 }} resizeMode="cover" />
: renderYouTube(item.url)
}
{!!item.description && <Text style={{ color:C.sub, marginTop:6 }}>{item.description}</Text>}
{canEdit && (
<View style={{ flexDirection:'row', marginTop:8 }}>
<Pressable onPress={()=>removeItem(item)} style={{ paddingVertical:6, paddingHorizontal:10, backgroundColor:'#d32f2f', borderRadius:8 }}>
<Text style={{ color:'#fff' }}>刪除</Text>
</Pressable>
</View>
)}
</View>
);

return (
<KeyboardAvoidingView style={{ flex:1, backgroundColor:C.bg }} behavior={Platform.OS==='ios' ? 'padding' : undefined} keyboardVerticalOffset={headerHeight}>
<FlatList
data={items}
keyExtractor={(i)=>i.id}
renderItem={renderRow}
keyboardShouldPersistTaps="handled"
keyboardDismissMode={Platform.OS==='ios' ? 'interactive' : 'on-drag'}
contentContainerStyle={{ padding:12, paddingBottom:(insets.bottom||16)+160 }}
ListHeaderComponent={<Text style={{ color:C.text, fontSize:16, fontWeight:'600', marginBottom:8 }}>社團媒體</Text>}
ListFooterComponent={
canEdit ? (
<View style={{ borderTopWidth:1, borderColor:C.border, paddingTop:10, marginTop:10 }}>
<Text style={{ color:C.text, fontWeight:'600', marginBottom:6 }}>新增 YouTube 連結</Text>
<TextInput
placeholder="https://youtu.be/..."
placeholderTextColor={C.hint}
value={yt}
onChangeText={setYt}
autoCapitalize="none"
style={{ borderWidth:1, borderColor:C.fieldBorder, borderRadius:8, paddingHorizontal:10, paddingVertical:8, marginBottom:6, color:C.text, backgroundColor:C.field }}
returnKeyType="next"
/>
<TextInput
placeholder="描述（可空）"
placeholderTextColor={C.hint}
value={desc}
onChangeText={setDesc}
style={{ borderWidth:1, borderColor:C.fieldBorder, borderRadius:8, paddingHorizontal:10, paddingVertical:8, marginBottom:8, color:C.text, backgroundColor:C.field }}
returnKeyType="done"
onSubmitEditing={addYoutube}
/>
<Pressable onPress={addYoutube} style={{ backgroundColor:'#1976d2', paddingVertical:10, borderRadius:8, alignItems:'center', marginBottom:12 }}>
<Text style={{ color:'#fff' }}>新增</Text>
</Pressable>

          <Text style={{ color:C.text, fontWeight:'600', marginBottom:6 }}>或上傳照片（會公開可見）</Text>
          <Pressable disabled={uploading} onPress={pickAndUploadPhoto} style={{ backgroundColor: uploading ? '#999' : '#f57c00', paddingVertical:10, borderRadius:8, alignItems:'center' }}>
            <Text style={{ color:'#fff' }}>{uploading ? '上傳中…' : '選擇照片上傳'}</Text>
          </Pressable>
        </View>
      ) : (
        <View style={{ borderTopWidth:1, borderColor:C.border, paddingTop:10, marginTop:10 }}>
          <Text style={{ color:C.sub }}>僅社長/管理員可新增媒體</Text>
        </View>
      )
    }
  />
  {!roleChecked && (
    <View style={{ position:'absolute', left:0, right:0, bottom:(insets.bottom||0)+8, alignItems:'center' }}>
      <Text style={{ color:'#888', fontSize:12 }}>正在確認權限…</Text>
    </View>
  )}
</KeyboardAvoidingView>
);
}ezbmt-tracked/src/screens/MediaScreen.tsx
 
import React from 'react';
import { View, Text, FlatList, TextInput, Pressable, Alert, Linking, Image, KeyboardAvoidingView, Platform } from 'react-native';
import { useRoute } from '@react-navigation/native';
import { useHeaderHeight } from '@react-navigation/elements';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { launchImageLibrary, Asset } from 'react-native-image-picker';
import { listMedia, insertMedia, deleteMedia, getMatch } from '../db';
import { uploadImageFromUri, getPublicUrl, removeFile, publicUrlToPath } from '../lib/storage';
import YoutubePlayer from 'react-native-youtube-iframe';
import { supa } from '../lib/supabase';

type MediaItem = { id: string; kind: 'youtube'|'photo'|string; url: string; description?: string };

const C = { bg:'#111', card:'#222', border:'#333', field:'#111', fieldBorder:'#444', text:'#fff', sub:'#ddd', hint:'#888' };

function getYouTubeId(url: string): string | null {
try {
const u = new URL(url);
if (u.hostname.includes('youtu.be')) return u.pathname.replace('/','') || null;
if (u.hostname.includes('youtube.com')) {
const v = u.searchParams.get('v'); if (v) return v;
const m = u.pathname.match(`//(embed|shorts)/([A-Za-z0-9_-]{6,})/`);
if (m && m[2]) return m[2];
}
} catch {}
return null;
}

export default function MediaScreen() {
const route = useRoute<any>();
const matchId = route.params?.matchId as string | undefined;
const presetCanEdit: boolean | undefined = route.params?.canEdit;
const headerHeight = useHeaderHeight();
const insets = useSafeAreaInsets();

const [items, setItems] = React.useState<MediaItem[]>([]);
const [yt, setYt] = React.useState(''); const [desc, setDesc] = React.useState('');
const [uploading, setUploading] = React.useState(false);
const [playId, setPlayId] = React.useState<string|null>(null);

// 編輯權限（viewer=false）
const [canEdit, setCanEdit] = React.useState<boolean>(presetCanEdit ?? false);
const [roleChecked, setRoleChecked] = React.useState<boolean>(!!(typeof presetCanEdit === 'boolean'));

// 缺少 matchId 的防呆
if (!matchId) {
return (
<View style={{ flex:1, backgroundColor: C.bg, alignItems:'center', justifyContent:'center', padding:16 }}>
<Text style={{ color: C.text, fontSize: 16, marginBottom: 8 }}>未提供場次 ID，無法載入媒體</Text>
</View>
);
}

// 讀媒體
const load = React.useCallback(async () => {
const rows = await listMedia('match', matchId);
setItems(rows as MediaItem[]);
}, [matchId]);

React.useEffect(() => { load(); }, [load]);

// 判定 canEdit（優先用 preset；沒有就查 match_members -> event_members）
React.useEffect(() => {
if (typeof presetCanEdit === 'boolean') {
setCanEdit(presetCanEdit);
setRoleChecked(true);
return;
}
let cancelled = false;
(async () => {
try {
const { data: me } = await supa.auth.getUser();
const uid = me?.user?.id;
if (!uid) { if (!cancelled) { setCanEdit(false); setRoleChecked(true); } return; }

    // 先查場次角色
    const { data: mm, error: mmErr } = await supa
      .from('match_members')
      .select('role, match_id')
      .eq('user_id', uid)
      .eq('match_id', matchId)
      .maybeSingle();
    if (!mmErr && mm && mm.role) {
      if (!cancelled) { setCanEdit(String(mm.role) !== 'viewer'); setRoleChecked(true); }
      return;
    }

    // 查賽事角色
    const m = await getMatch(matchId);
    const eid = m?.event_id as string | undefined;
    if (!eid) { if (!cancelled) { setCanEdit(false); setRoleChecked(true); } return; }

    const { data: em, error: emErr } = await supa
      .from('event_members')
      .select('role')
      .eq('event_id', eid)
      .eq('user_id', uid)
      .maybeSingle();
    if (!emErr && em && em.role) {
      if (!cancelled) { setCanEdit(String(em.role) !== 'viewer'); setRoleChecked(true); }
      return;
    }
    if (!cancelled) { setCanEdit(false); setRoleChecked(true); }
  } catch {
    if (!cancelled) { setCanEdit(false); setRoleChecked(true); }
  }
})();
return () => { cancelled = true; };
}, [matchId, presetCanEdit]);

const addYoutube = async () => {
if (!canEdit) { Alert.alert('沒有權限', '此角色不可新增媒體'); return; }
const url = yt.trim(); if (!url) return;
if (!/^(https?:\/\/)?(www.)?(youtube.com|youtu.be)\//i.test(url)) {
Alert.alert('URL 格式錯誤','請輸入有效的 YouTube 連結'); return;
}
await insertMedia({ owner_type:'match', owner_id:matchId, kind:'youtube', url, description: desc.trim()||undefined });
setYt(''); setDesc(''); load();
};

const pickAndUploadPhoto = async () => {
if (!canEdit) { Alert.alert('沒有權限', '此角色不可新增媒體'); return; }
try {
const res = await launchImageLibrary({ mediaType:'photo', selectionLimit:1, quality:0.9 });
if (res.didCancel) return;
const asset: Asset|undefined = res.assets?.[0]; if (!asset?.uri) return;
setUploading(true);
const mime = asset.type || 'image/jpeg';
const extFromName = (asset.fileName||'').split('.').pop()?.toLowerCase();
const extFromMime = mime.split('/').pop()?.toLowerCase();
const ext = extFromName && extFromName.length<=5 ? extFromName : (extFromMime || 'jpg');
const path = `match/${matchId}/${Date.now()}-${Math.floor(Math.random()*1e7)}.${ext}`;
const storagePath = await uploadImageFromUri(asset.uri, path, mime);
const publicUrl = getPublicUrl(storagePath);
await insertMedia({ owner_type:'match', owner_id:matchId, kind:'photo', url:publicUrl, description: desc.trim()||undefined });
setDesc(''); await load(); Alert.alert('成功','照片已上傳');
} catch (e:any) {
Alert.alert('上傳失敗', String(e?.message||e));
} finally { setUploading(false); }
};

const removeItem = async (item: MediaItem) => {
if (!canEdit) { Alert.alert('沒有權限', '此角色不可刪除媒體'); return; }
try {
if (item.kind === 'photo') {
const p = publicUrlToPath(item.url);
if (p) { try { await removeFile(p); } catch {} }
}
await deleteMedia(item.id);
const id = getYouTubeId(item.url); if (id && id === playId) setPlayId(null);
await load();
} catch (e:any) { Alert.alert('刪除失敗', String(e?.message||e)); }
};

const renderYouTube = (url: string) => {
const id = getYouTubeId(url);
if (!id) {
return <Pressable onPress={()=>Linking.openURL(url)}><Text style={{ color:'#90caf9' }} numberOfLines={1}>{url}</Text></Pressable>;
}
if (playId === id) {
return (
<View style={{ marginTop:6, borderRadius:8, overflow:'hidden', backgroundColor:'#000' }}>
<YoutubePlayer
height={220}
play={true}
videoId={id}
onChangeState={(s: string) => { if (s === 'ended') setPlayId(null); }}
webViewStyle={{ backgroundColor:'#000' }}
forceAndroidAutoplay={false}
webViewProps={{ allowsFullscreenVideo:true, allowsInlineMediaPlayback:true, mediaPlaybackRequiresUserAction:false }}
/>
</View>
);
}
return (
<Pressable onPress={()=>setPlayId(id)} style={{ borderRadius:8, overflow:'hidden', backgroundColor:'#000', marginTop:6 }}>
<Image source={{ uri:`https://img.youtube.com/vi/${id}/hqdefault.jpg` }} style={{ width:'100%', height:180, backgroundColor:'#333' }} resizeMode="cover" />
<View style={{ position:'absolute', left:0,right:0,top:0,bottom:0, justifyContent:'center', alignItems:'center' }}>
<View style={{ width:58, height:58, borderRadius:29, backgroundColor:'rgba(0,0,0,0.6)', justifyContent:'center', alignItems:'center' }}>
<View style={{ marginLeft:4, width:0, height:0, borderLeftWidth:14, borderLeftColor:'#fff', borderTopWidth:10, borderTopColor:'transparent', borderBottomWidth:10, borderBottomColor:'transparent' }} />
</View>
</View>
</Pressable>
);
};

const renderRow = ({ item }: { item: MediaItem }) => (
<View style={{ padding:10, borderWidth:1, borderColor:C.border, backgroundColor:C.card, borderRadius:8, marginBottom:8 }}>
<Text style={{ color:C.text, fontWeight:'600' }}>{item.kind==='youtube'?'YouTube':'照片'}</Text>
{item.kind === 'photo'
? <Image source={{ uri:item.url }} style={{ width:'100%', height:180, borderRadius:8, backgroundColor:'#333', marginTop:6 }} resizeMode="cover" />
: renderYouTube(item.url)
}
{!!item.description && <Text style={{ color:C.sub, marginTop:6 }}>{item.description}</Text>}
{canEdit && (
<View style={{ flexDirection:'row', marginTop:8 }}>
<Pressable onPress={()=>removeItem(item)} style={{ paddingVertical:6, paddingHorizontal:10, backgroundColor:'#d32f2f', borderRadius:8 }}>
<Text style={{ color:'#fff' }}>刪除</Text>
</Pressable>
</View>
)}
</View>
);

return (
<KeyboardAvoidingView style={{ flex:1, backgroundColor:C.bg }} behavior={Platform.OS==='ios' ? 'padding' : undefined} keyboardVerticalOffset={headerHeight}>
<FlatList
data={items}
keyExtractor={(i)=>i.id}
renderItem={renderRow}
keyboardShouldPersistTaps="handled"
keyboardDismissMode={Platform.OS==='ios' ? 'interactive' : 'on-drag'}
contentContainerStyle={{ padding:12, paddingBottom:(insets.bottom||16)+160 }}
ListHeaderComponent={<Text style={{ color:C.text, fontSize:16, fontWeight:'600', marginBottom:8 }}>媒體清單</Text>}
ListFooterComponent={
canEdit ? (
<View style={{ borderTopWidth:1, borderColor:C.border, paddingTop:10, marginTop:10 }}>
<Text style={{ color:C.text, fontWeight:'600', marginBottom:6 }}>新增 YouTube 連結</Text>
<TextInput
placeholder="https://youtu.be/..."
placeholderTextColor={C.hint}
value={yt}
onChangeText={setYt}
autoCapitalize="none"
style={{ borderWidth:1, borderColor:C.fieldBorder, borderRadius:8, paddingHorizontal:10, paddingVertical:8, marginBottom:6, color:C.text, backgroundColor:C.field }}
returnKeyType="next"
/>
<TextInput
placeholder="描述（可空）"
placeholderTextColor={C.hint}
value={desc}
onChangeText={setDesc}
style={{ borderWidth:1, borderColor:C.fieldBorder, borderRadius:8, paddingHorizontal:10, paddingVertical:8, marginBottom:8, color:C.text, backgroundColor:C.field }}
returnKeyType="done"
onSubmitEditing={addYoutube}
/>
<Pressable onPress={addYoutube} style={{ backgroundColor:'#1976d2', paddingVertical:10, borderRadius:8, alignItems:'center', marginBottom:12 }}>
<Text style={{ color:'#fff' }}>新增</Text>
</Pressable>

          <Text style={{ color:C.text, fontWeight:'600', marginBottom:6 }}>或上傳照片（會公開可見）</Text>
          <Pressable disabled={uploading} onPress={pickAndUploadPhoto} style={{ backgroundColor: uploading ? '#999' : '#f57c00', paddingVertical:10, borderRadius:8, alignItems:'center' }}>
            <Text style={{ color:'#fff' }}>{uploading ? '上傳中…' : '選擇照片上傳'}</Text>
          </Pressable>
        </View>
      ) : (
        <View style={{ borderTopWidth:1, borderColor:C.border, paddingTop:10, marginTop:10 }}>
          <Text style={{ color:C.sub }}>此角色僅能瀏覽媒體</Text>
        </View>
      )
    }
  />
  {!roleChecked && (
    <View style={{ position:'absolute', left:0, right:0, bottom:(insets.bottom||0)+8, alignItems:'center' }}>
      <Text style={{ color:'#888', fontSize:12 }}>正在確認權限…</Text>
    </View>
  )}
</KeyboardAvoidingView>
);
}ezbmt-tracked/src/screens/ProfileScreen.tsx
 
import React from 'react';
import { View, Text, TextInput, Pressable, Alert, Image, ScrollView } from 'react-native';
import { useFocusEffect } from '@react-navigation/native';
import { supa, getCurrentUser } from '../lib/supabase';
import { useBgStore } from '../store/bg';
import { launchImageLibrary, type ImageLibraryOptions } from 'react-native-image-picker';

export default function ProfileScreen({ navigation }: any) {
const [name, setName] = React.useState('');
const [busy, setBusy] = React.useState(false);

// 修改密碼
const [pwd1, setPwd1] = React.useState('');
const [pwd2, setPwd2] = React.useState('');
const [pwdBusy, setPwdBusy] = React.useState(false);

// 背景（本機）
const bgUri = useBgStore(s => s.uri);
const opacity = useBgStore(s => s.opacity);
const setOpacity = useBgStore(s => s.setOpacity);
const setFromBase64 = useBgStore(s => s.setFromBase64);
const clearBg = useBgStore(s => s.clear);

// 只從 profiles.name 載入
const preloadName = React.useCallback(async () => {
try {
const u = await getCurrentUser();
if (!u) return;
const { data, error } = await supa
.from('profiles')
.select('name')
.eq('id', u.id)
.maybeSingle();
if (!error && data?.name != null) setName(String(data.name));
else setName(''); // 無資料就空白
} catch {
setName('');
}
}, []);

useFocusEffect(React.useCallback(() => { preloadName(); }, [preloadName]));

// 只寫 profiles.name
const save = async () => {
const nm = (name ?? '').trim();
setBusy(true);
try {
const u = await getCurrentUser();
if (!u) throw new Error('未登入');
const { error } = await supa.from('profiles').upsert({ id: u.id, name: nm });
if (error) throw error;
Alert.alert('成功', '已更新暱稱');
await preloadName();
} catch (e: any) {
Alert.alert('失敗', String(e?.message || e));
} finally {
setBusy(false);
}
};

async function handleChangePassword() {
if (!pwd1 || pwd1.length < 6) { Alert.alert('提示', '請輸入至少 6 碼的新密碼'); return; }
if (pwd1 !== pwd2) { Alert.alert('提示', '兩次輸入的密碼不一致'); return; }
setPwdBusy(true);
try {
const { error } = await supa.auth.updateUser({ password: pwd1 });
if (error) throw error;
setPwd1(''); setPwd2('');
Alert.alert('成功', '已更新密碼');
} catch (e:any) {
Alert.alert('失敗', String(e?.message || e));
} finally {
setPwdBusy(false);
}
}

async function handleSignOut() {
try {
await supa.auth.signOut();
navigation.replace('Auth');
} catch (e:any) {
Alert.alert('登出失敗', String(e?.message || e));
}
}

async function pickBackground() {
try {
const opts: ImageLibraryOptions = { mediaType: 'photo', quality: 0.9, includeBase64: true, selectionLimit: 1 };
const res = await launchImageLibrary(opts);
if (res.didCancel) return;
const a = res.assets && res.assets[0];
if (!a?.base64) { Alert.alert('失敗', '此圖片無法取得內容，請再試一次'); return; }
const ext = (a.fileName?.split('.').pop() || (a.type?.split('/')?.pop() || 'jpg')).toLowerCase();
await setFromBase64(a.base64, ext);
Alert.alert('成功', '已設定背景圖');
} catch (e: any) {
Alert.alert('失敗', String(e?.message || e));
}
}

return (
<ScrollView contentContainerStyle={{ padding:16 }}>
<Text style={{ fontSize:16, fontWeight:'600', marginBottom:8 }}>個人資料</Text>

  {/* 暱稱（只帶 profiles.name） */}
  <TextInput
    value={name}
    onChangeText={setName}
    placeholder="暱稱"
    style={{ borderWidth:1, borderColor:'#ccc', borderRadius:8, paddingHorizontal:10, paddingVertical:8, marginBottom:10 }}
  />
  <Pressable onPress={save} disabled={busy} style={{ backgroundColor:'#1976d2', paddingVertical:10, borderRadius:8, alignItems:'center', marginBottom:16 }}>
    <Text style={{ color:'#fff' }}>儲存</Text>
  </Pressable>

  {/* 修改密碼 */}
  <Text style={{ fontSize:16, fontWeight:'600', marginBottom:8 }}>修改密碼</Text>
  <TextInput
    value={pwd1}
    onChangeText={setPwd1}
    placeholder="新密碼（至少 6 碼）"
    secureTextEntry
    style={{ borderWidth:1, borderColor:'#ccc', borderRadius:8, paddingHorizontal:10, paddingVertical:8, marginBottom:8 }}
  />
  <TextInput
    value={pwd2}
    onChangeText={setPwd2}
    placeholder="再次輸入新密碼"
    secureTextEntry
    style={{ borderWidth:1, borderColor:'#ccc', borderRadius:8, paddingHorizontal:10, paddingVertical:8, marginBottom:10 }}
  />
  <Pressable onPress={handleChangePassword} disabled={pwdBusy} style={{ backgroundColor:'#00695c', paddingVertical:10, borderRadius:8, alignItems:'center', marginBottom:24 }}>
    <Text style={{ color:'#fff' }}>更新密碼</Text>
  </Pressable>

  {/* 背景設定（本機） */}
  <Text style={{ fontSize:16, fontWeight:'600', marginBottom:8 }}>背景圖片（本機）</Text>
  {bgUri ? (
    <View style={{ marginBottom: 10 }}>
      <Image source={{ uri: bgUri }} resizeMode="cover" style={{ width: '100%', height: 160, borderRadius: 8, backgroundColor:'#eee' }} />
      <Text style={{ color:'#555', marginTop:6 }}>目前透明度：{Math.round(opacity*100)}%</Text>
    </View>
  ) : (
    <Text style={{ color:'#666', marginBottom: 8 }}>尚未設定背景圖</Text>
  )}

  <View style={{ flexDirection:'row', flexWrap:'wrap', marginBottom:10 }}>
    <Pressable onPress={pickBackground} style={{ paddingVertical:8, paddingHorizontal:12, backgroundColor:'#1976d2', borderRadius:8, marginRight:8, marginBottom:8 }}>
      <Text style={{ color:'#fff' }}>選擇圖片</Text>
    </Pressable>
    {!!bgUri && (
      <Pressable onPress={clearBg} style={{ paddingVertical:8, paddingHorizontal:12, backgroundColor:'#9e9e9e', borderRadius:8, marginRight:8, marginBottom:8 }}>
        <Text style={{ color:'#fff' }}>清除背景</Text>
      </Pressable>
    )}
  </View>

  {!!bgUri && (
    <>
      <Text style={{ marginBottom:6 }}>透明度</Text>
      <View style={{ flexDirection:'row', flexWrap:'wrap' }}>
        {[0.15, 0.25, 0.4].map(v => (
          <Pressable key={String(v)} onPress={() => setOpacity(v)} style={{
            paddingVertical:6, paddingHorizontal:10, borderRadius:14,
            borderWidth:1, borderColor: opacity===v?'#1976d2':'#ccc',
            backgroundColor: opacity===v?'rgba(25,118,210,0.1)':'#fff',
            marginRight:8, marginBottom:8
          }}>
            <Text>{Math.round(v*100)}%</Text>
          </Pressable>
        ))}
      </View>
    </>
  )}

  {/* 取消與登出（取消放在登出上面） */}
  <Pressable onPress={()=>navigation.goBack()} style={{ backgroundColor:'#9e9e9e', paddingVertical:10, borderRadius:8, alignItems:'center', marginTop:24 }}>
    <Text style={{ color:'#fff' }}>取消</Text>
  </Pressable>
</ScrollView>
);
}ezbmt-tracked/src/screens/PlayerSetupScreen.tsx
 
import React from 'react';
import {
View,
Text,
TextInput,
Pressable,
Alert,
ScrollView,
KeyboardAvoidingView,
Platform,
LayoutChangeEvent,
NativeSyntheticEvent,
NativeScrollEvent,
} from 'react-native';
import { useRoute, useNavigation } from '@react-navigation/native';
import { useHeaderHeight } from '@react-navigation/elements';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { getMatch, getMatchPlayers, upsertMatchPlayers, updateStartConfigs } from '../db';

const C = {
bg: '#111',
card: '#222',
border: '#333',
field: '#111',
fieldBorder: '#444',
text: '#fff',
sub: '#ddd',
hint: '#888',
chipOn: '#90caf9',
chipOff: '#555',
};

type PlayerForm = { name: string; gender: 'M' | 'F' | 'U'; handedness: 'L' | 'R' | 'U' };

export default function PlayerSetupScreen() {
const route = useRoute<any>();
const navigation = useNavigation<any>();
const matchId = route.params.matchId as string;

const headerHeight = useHeaderHeight();
const insets = useSafeAreaInsets();

const [home, setHome] = React.useState<[PlayerForm, PlayerForm]>([
{ name: '', gender: 'U', handedness: 'R' },
{ name: '', gender: 'U', handedness: 'R' },
]);
const [away, setAway] = React.useState<[PlayerForm, PlayerForm]>([
{ name: '', gender: 'U', handedness: 'R' },
{ name: '', gender: 'U', handedness: 'R' },
]);
const [homeRight, setHomeRight] = React.useState<0 | 1>(0);
const [awayRight, setAwayRight] = React.useState<0 | 1>(0);
const [startingTeam, setStartingTeam] = React.useState<0 | 1>(0);
const [startingIndex, setStartingIndex] = React.useState<0 | 1>(0);

// 單打/雙打
const [isSingles, setIsSingles] = React.useState<boolean>(false);

React.useEffect(() => {
(async () => {
const m = await getMatch(matchId);
if (m) {
// 判斷單/雙打
const singles = m.type === 'MS' || m.type === 'WS';
setIsSingles(singles);

    if (typeof m.home_right_when_even_index === 'number') setHomeRight(m.home_right_when_even_index as 0 | 1);
    if (typeof m.away_right_when_even_index === 'number') setAwayRight(m.away_right_when_even_index as 0 | 1);
    if (typeof m.starting_server_team === 'number') setStartingTeam(m.starting_server_team as 0 | 1);
    if (typeof m.starting_server_index === 'number') setStartingIndex(m.starting_server_index as 0 | 1);
  }
  const ps = await getMatchPlayers(matchId);
  if (ps && ps.length) {
    const h: [PlayerForm, PlayerForm] = [
      { name: '', gender: 'U', handedness: 'R' },
      { name: '', gender: 'U', handedness: 'R' },
    ];
    const a: [PlayerForm, PlayerForm] = [
      { name: '', gender: 'U', handedness: 'R' },
      { name: '', gender: 'U', handedness: 'R' },
    ];
    for (const p of ps) {
      const form: PlayerForm = {
        name: p.name || '',
        gender: (p.gender as any) || 'U',
        handedness: (p.handedness as any) || 'R',
      };
      if (p.side === 'home') h[p.idx] = form;
      else a[p.idx] = form;
    }
    setHome(h);
    setAway(a);
  }
})();
}, [matchId]);

const save = async () => {
try {
// 單打模式：強制開場發球人員 index 為 0（只有 #1）
const sIndex = isSingles ? 0 : startingIndex;

  await upsertMatchPlayers({
    matchId,
    home: [
      { idx: 0, name: home[0].name, gender: home[0].gender, handedness: home[0].handedness },
      { idx: 1, name: isSingles ? '' : home[1].name, gender: isSingles ? 'U' : home[1].gender, handedness: isSingles ? 'R' : home[1].handedness },
    ],
    away: [
      { idx: 0, name: away[0].name, gender: away[0].gender, handedness: away[0].handedness },
      { idx: 1, name: isSingles ? '' : away[1].name, gender: isSingles ? 'U' : away[1].gender, handedness: isSingles ? 'R' : away[1].handedness },
    ],
  });

  await updateStartConfigs({
    matchId,
    startingServerTeam: startingTeam,
    startingServerIndex: sIndex,
    // 單打時此選項不顯示，但資料仍可保留（不影響單打邏輯）
    homeRightWhenEven: homeRight,
    awayRightWhenEven: awayRight,
  });

  Alert.alert('已儲存', '球員與起始設定已更新');
  navigation.goBack();
} catch (e: any) {
  Alert.alert('儲存失敗', String(e?.message || e));
}
};

// ---- 避免鍵盤遮住輸入：只在需要時捲動 ----
const scrollRef = React.useRef<ScrollView | null>(null);
const inputRectsRef = React.useRef<Record<string, { y: number; h: number }>>({});
const viewportHRef = React.useRef(0);
const scrollYRef = React.useRef(0);

const onScroll = (e: NativeSyntheticEvent<NativeScrollEvent>) => {
scrollYRef.current = e.nativeEvent.contentOffset.y;
};
const onScrollViewLayout = (e: LayoutChangeEvent) => {
viewportHRef.current = e.nativeEvent.layout.height;
};

const onInputLayout = (key: string) => (e: LayoutChangeEvent) => {
const { y, height } = e.nativeEvent.layout;
inputRectsRef.current[key] = { y, h: height };
};

const onInputFocus = (key: string) => () => {
const rect = inputRectsRef.current[key];
if (!rect) return;
const margin = 80; // 讓欄位上方留一些空白
const top = rect.y;
const bottom = rect.y + rect.h;

const visibleTop = scrollYRef.current;
const visibleBottom = scrollYRef.current + viewportHRef.current;

// 已可見就不捲
if (top >= visibleTop + 8 && bottom <= visibleBottom - 8) return;

if (top < visibleTop + margin) {
  const to = Math.max(0, top - margin);
  scrollRef.current?.scrollTo({ y: to, animated: true });
  return;
}
if (bottom > visibleBottom - margin) {
  const to = Math.max(0, bottom - viewportHRef.current + margin);
  scrollRef.current?.scrollTo({ y: to, animated: true });
}
};
// ------------------------------------------------

return (
<KeyboardAvoidingView
style={{ flex: 1 }}
behavior={Platform.OS === 'ios' ? 'padding' : undefined}
keyboardVerticalOffset={headerHeight}
>
<ScrollView
ref={scrollRef}
onLayout={onScrollViewLayout}
onScroll={onScroll}
scrollEventThrottle={16}
contentContainerStyle={{ padding: 16, paddingBottom: (insets.bottom || 16) + 320 }}
keyboardShouldPersistTaps="handled"
style={{ flex: 1, backgroundColor: C.bg }}
>
<Text style={{ fontSize: 18, fontWeight: '600', marginBottom: 12, color: C.text }}>球員設定</Text>

    <TeamBox
      title="主隊（Home）"
      players={home}
      onChange={(p) => setHome(p)}
      rightWhenEven={homeRight}
      setRightWhenEven={setHomeRight}
      nameKeys={['home-0', 'home-1']}
      onNameLayout={onInputLayout}
      onNameFocus={onInputFocus}
      singles={isSingles}
    />
    <TeamBox
      title="客隊（Away）"
      players={away}
      onChange={(p) => setAway(p)}
      rightWhenEven={awayRight}
      setRightWhenEven={setAwayRight}
      nameKeys={['away-0', 'away-1']}
      onNameLayout={onInputLayout}
      onNameFocus={onInputFocus}
      singles={isSingles}
    />

    <Text style={{ fontSize: 16, fontWeight: '600', marginTop: 16, marginBottom: 8, color: C.text }}>開場發球</Text>
    <Row>
      <Badge onPress={() => setStartingTeam(0)} active={startingTeam === 0} text="主隊" />
      <Badge onPress={() => setStartingTeam(1)} active={startingTeam === 1} text="客隊" />
    </Row>

    {/* 單打不顯示 #1/#2 選擇 */}
    {!isSingles && (
      <Row>
        <Badge onPress={() => setStartingIndex(0)} active={startingIndex === 0} text="#1" />
        <Badge onPress={() => setStartingIndex(1)} active={startingIndex === 1} text="#2" />
      </Row>
    )}

    <Pressable
      onPress={save}
      style={{ marginTop: 20, backgroundColor: '#1976d2', paddingVertical: 12, borderRadius: 8, alignItems: 'center' }}
    >
      <Text style={{ color: '#fff', fontSize: 16 }}>儲存</Text>
    </Pressable>
  </ScrollView>
</KeyboardAvoidingView>
);
}

function TeamBox({
title,
players,
onChange,
rightWhenEven,
setRightWhenEven,
nameKeys,
onNameLayout,
onNameFocus,
singles = false,
}: {
title: string;
players: [PlayerForm, PlayerForm];
onChange: (v: [PlayerForm, PlayerForm]) => void;
rightWhenEven: 0 | 1;
setRightWhenEven: (v: 0 | 1) => void;
nameKeys: [string, string];
onNameLayout: (key: string) => (e: LayoutChangeEvent) => void;
onNameFocus: (key: string) => () => void;
singles?: boolean;
}) {
const setP = (i: 0 | 1, patch: Partial<PlayerForm>) => {
const next: [PlayerForm, PlayerForm] = [...players] as any;
next[i] = { ...next[i], ...patch };
onChange(next);
};

// 單打只顯示 #1
const idxList: Array<0 | 1> = singles ? [0] : [0, 1];

return (
<View style={{ borderWidth: 1, borderColor: C.border, backgroundColor: C.card, borderRadius: 12, padding: 12, marginBottom: 12 }}>
<Text style={{ fontWeight: '600', marginBottom: 8, color: C.text }}>{title}</Text>

  {idxList.map((i) => (
    <View key={i} style={{ marginBottom: 10 }}>
      <Text style={{ marginBottom: 6, color: C.sub }}>球員 #{i + 1}</Text>
      <TextInput
        placeholder="姓名"
        placeholderTextColor={C.hint}
        value={players[i].name}
        onChangeText={(t) => setP(i, { name: t })}
        onLayout={onNameLayout(nameKeys[i])}
        onFocus={onNameFocus(nameKeys[i])}
        style={{
          borderWidth: 1,
          borderColor: C.fieldBorder,
          borderRadius: 8,
          paddingHorizontal: 10,
          paddingVertical: 10,
          marginBottom: 6,
          backgroundColor: C.field,
          color: C.text,
        }}
        returnKeyType="done"
      />
      <Row>
        <Badge onPress={() => setP(i, { gender: 'M' })} active={players[i].gender === 'M'} text="男" />
        <Badge onPress={() => setP(i, { gender: 'F' })} active={players[i].gender === 'F'} text="女" />
        <Badge onPress={() => setP(i, { gender: 'U' })} active={players[i].gender === 'U'} text="未註明" />
      </Row>
      <Row>
        <Badge onPress={() => setP(i, { handedness: 'R' })} active={players[i].handedness === 'R'} text="右手" />
        <Badge onPress={() => setP(i, { handedness: 'L' })} active={players[i].handedness === 'L'} text="左手" />
        <Badge onPress={() => setP(i, { handedness: 'U' })} active={players[i].handedness === 'U'} text="未註明" />
      </Row>
    </View>
  ))}

  {/* 單打不顯示「偶數分站右」選擇 */}
  {!singles && (
    <>
      <Text style={{ marginTop: 4, marginBottom: 6, color: C.sub }}>偶數分站右（Right when Even）：</Text>
      <Row>
        <Badge onPress={() => setRightWhenEven(0)} active={rightWhenEven === 0} text="#1 在右" />
        <Badge onPress={() => setRightWhenEven(1)} active={rightWhenEven === 1} text="#2 在右" />
      </Row>
    </>
  )}
</View>
);
}

function Row({ children }: any) {
return <View style={{ flexDirection: 'row', alignItems: 'center', flexWrap: 'wrap', gap: 8, marginBottom: 8 }}>{children}</View>;
}
function Badge({ text, active, onPress }: { text: string; active?: boolean; onPress?: () => void }) {
return (
<Pressable
onPress={onPress}
style={{
paddingVertical: 8,
paddingHorizontal: 12,
borderRadius: 16,
borderWidth: 1,
borderColor: active ? C.chipOn : C.chipOff,
backgroundColor: active ? 'rgba(144,202,249,0.15)' : C.card,
marginRight: 8,
marginBottom: 8,
}}>
<Text style={{ color: C.text }}>{text}</Text>
</Pressable>
);
}ezbmt-tracked/src/screens/RecordScreen.tsx
 
import React from 'react';
import {
  View,
  Text,
  Modal,
  Pressable,
  Alert,
  Dimensions,
  ActivityIndicator,
  ScrollView,
} from 'react-native';
import Svg, { Line, Path, Text as SvgText, G } from 'react-native-svg';
import Court from '../components/Court';
import MarkerSheet from '../components/MarkerSheet';
import type { Orientation, Side, Zone, TapEvent, Point } from '../types';
import { useRecordsStore } from '../store/records';
import {
  getMatch,
  getMatchPlayers,
  saveMatchState,
  upsertGameSummary,
  listRecentRallies,
  listRalliesOrdered,
  getLastRally,
  deleteRally,
  listDictionary,
  openDB,
} from '../db';
import {
  createMatch as createServeMatch,
  deserialize,
  serialize,
  getUiSnapshot,
  nextRally,
  MatchState,
  RuleConfig,
} from '../logic/serve';
import { publishLiveState } from '../lib/supabase';
import { BACKEND } from '../lib/backend';
import { supa } from '../lib/supabase';

type Marker = {
  id: string;
  rx: number;
  ry: number;
  kind: 'win' | 'loss';
  meta: any;
  game?: number;
};

type GameSum = { i: number; home: number; away: number; winner: 0 | 1 | null };

const BLUE = '#1976d2';
const RED = '#d32f2f';

export default function RecordScreen({ navigation }: any) {
  const orientation: Orientation = 'portrait';

  const currentMatchId = useRecordsStore(s => s.currentMatchId);
  const loadRecent = useRecordsStore(s => s.loadRecent);
  const addRecord = useRecordsStore(s => s.addRecord);
  const records = useRecordsStore(s => s.records);

  const [panel, setPanel] = React.useState<null | {
    isWin: boolean;                 // 主隊是否得分（既有）
    zone: Zone;
    tapPoint?: Point;
    norm?: { x: number; y: number };
    meta: any;
    route?: { start: Point; end: Point };
    routeNorm?: { start?: { x: number; y: number }; end?: { x: number; y: number } };
    startTeam?: 0 | 1;              // 起點方（0=主，1=客）
    allowFlipWin?: boolean;         // 發球例外
  }>(null);

  const [routeStart, setRouteStart] = React.useState<Point | null>(null);
  const [routeStartNorm, setRouteStartNorm] = React.useState<{ x: number; y: number } | null>(null);
  const [routeHover, setRouteHover] = React.useState<Point | null>(null);
  const [routePreviewColor, setRoutePreviewColor] = React.useState<string | undefined>(undefined);

  const [serveState, setServeState] = React.useState<MatchState | null>(null);
  const [ui, setUi] = React.useState<any>(null);

  const [loading, setLoading] = React.useState(true);
  const [mode, setMode] = React.useState<'tap' | 'route'>('tap');
  const [isSingles, setIsSingles] = React.useState<boolean>(false);

  const [shotTypes, setShotTypes] = React.useState<string[]>([]);
  const [errorReasons, setErrorReasons] = React.useState<string[]>([]);

  const [markers, setMarkers] = React.useState<Marker[]>([]);
  const [routes, setRoutes] = React.useState<
    Array<{ id: string; sx: number; sy: number; ex: number; ey: number; color: string; gi: number; shotType?: string }>
  >([]);
  const [markerSheet, setMarkerSheet] = React.useState<{
    visible: boolean;
    data: { id: string; kind: 'win' | 'loss'; meta: any } | null;
  }>({ visible: false, data: null });

  const [endModal, setEndModal] = React.useState<{
    type: 'game' | 'match';
    gameIndex: number;
    score: [number, number];
  } | null>(null);
  const [deciderSwitchShownForGame, setDeciderSwitchShownForGame] = React.useState<number | null>(null);
  const [intervalShownForGame, setIntervalShownForGame] = React.useState<number | null>(null);

  const [focus, setFocus] = React.useState<Point | null>(null);
  const courtWrapRef = React.useRef<View>(null);
  const baseTopRef = React.useRef<number | null>(null);
  const baseHRef = React.useRef<number>(0);
  const [panelH, setPanelH] = React.useState(0);
  const [shiftY, setShiftY] = React.useState(0);

  const winH = Dimensions.get('window').height;

  // 場上落點/路線篩選（全部/本局）
  const [courtFilter, setCourtFilter] = React.useState<'all' | 'current'>('all');

  // 記錄 Sheet
  const [recSheetOpen, setRecSheetOpen] = React.useState(false);
  const [recSheetLoading, setRecSheetLoading] = React.useState(false);
  const [recSheetRows, setRecSheetRows] = React.useState<
    Array<{ id: string; game: number; no: number; win: boolean; zone: string; meta: any; createdAt: string }>
  >([]);
  const [gameSums, setGameSums] = React.useState<GameSum[]>([]);
  const [recFilter, setRecFilter] = React.useState<'all' | 'current'>('all');

  // 標題列「各局比分＋勝方」
  const [headerSums, setHeaderSums] = React.useState<GameSum[]>([]);
  const headerSumsText = React.useMemo(() => {
    if (!headerSums?.length) return '';
    return headerSums
      .map(g => `第${g.i}局 ${g.home}:${g.away}${g.winner == null ? '' : g.winner === 0 ? '（主）' : '（客）'}`)
      .join('  ');
  }, [headerSums]);

  React.useEffect(() => {
    init();
  }, [currentMatchId, loadRecent]);

  const measureCourtBase = React.useCallback(() => {
    requestAnimationFrame(() => {
      courtWrapRef.current?.measureInWindow((x, y, w, h) => {
        if (!panel && shiftY === 0) {
          baseTopRef.current = y;
          baseHRef.current = h;
        }
      });
    });
  }, [panel, shiftY]);
  React.useEffect(() => {
    measureCourtBase();
  }, [measureCourtBase]);

  React.useEffect(() => {
    if (!panel) {
      if (shiftY !== 0) setShiftY(0);
      return;
    }
    if (!focus || panelH <= 0 || baseTopRef.current == null) return;

    const margin = 16;
    const panelTop = winH - panelH;
    const dotAbsY = baseTopRef.current + focus.y;
    const needed = Math.max(0, dotAbsY - (panelTop - margin));
    if (Math.abs(needed - shiftY) > 0.5) setShiftY(needed);
  }, [panel, panelH, focus, winH, shiftY]);

  async function init() {
    if (!currentMatchId) {
      setLoading(false);
      return;
    }
    setLoading(true);
    try {
      const m = await getMatch(currentMatchId);
      setMode(m?.record_mode === 'route' ? 'route' : 'tap');
      setIsSingles(m?.type === 'MS' || m?.type === 'WS');

      try {
        const st = await listDictionary('shot_type');
        const er = await listDictionary('error_reason');
        setShotTypes(st.map(x => x.label));
        setErrorReasons(er.map(x => x.label));
      } catch {
        setShotTypes(['切球', '網前', '封網', '殺球', '高遠球', '挑球及推後場', '過渡', '平抽', '發球']);
        setErrorReasons(['出界', '掛網', '質量不好', '發球失誤']);
      }

      const players = await getMatchPlayers(currentMatchId);
      let s: MatchState | null = null;
      if (m?.state_json) {
        try {
          s = deserialize(m.state_json);
        } catch {}
      }

      const homePlayers: [any, any] = [
        { id: 'A0', name: players.find(p => p.side === 'home' && p.idx === 0)?.name || '主#1' },
        { id: 'A1', name: players.find(p => p.side === 'home' && p.idx === 1)?.name || '主#2' },
      ];
      const awayPlayers: [any, any] = [
        { id: 'B0', name: players.find(p => p.side === 'away' && p.idx === 0)?.name || '客#1' },
        { id: 'B1', name: players.find(p => p.side === 'away' && p.idx === 1)?.name || '客#2' },
      ];

      const dbHomeRight =
        typeof m?.home_right_when_even_index === 'number' ? (m.home_right_when_even_index as 0 | 1) : 0;
      const dbAwayRight =
        typeof m?.away_right_when_even_index === 'number' ? (m.away_right_when_even_index as 0 | 1) : 0;

      if (!s) {
        const rules = normalizeRules(m?.rules_json);
        s = createServeMatch({
          teams: [
            { players: homePlayers as any, startRightIndex: dbHomeRight },
            { players: awayPlayers as any, startRightIndex: dbAwayRight },
          ],
          startingServerTeam:
            typeof m?.starting_server_team === 'number' ? (m.starting_server_team as 0 | 1) : 0,
          startingServerPlayerIndex:
            typeof m?.starting_server_index === 'number' ? (m.starting_server_index as 0 | 1) : undefined,
          rules,
          metadata: { category: (m?.type as any) || 'MD' },
        });
        await saveMatchState(currentMatchId, serialize(s));
      } else {
        s.teams[0].players = homePlayers as any;
        s.teams[1].players = awayPlayers as any;
        s.teams[0].startRightIndex = dbHomeRight;
        s.teams[1].startRightIndex = dbAwayRight;
        await saveMatchState(currentMatchId, serialize(s));
      }

      setServeState(s);
      setUi(getUiSnapshot(s));
      await loadRecent();

      // 標題列：各局比分
      const sumsForHeader = await fetchGameSums(currentMatchId);
      setHeaderSums(sumsForHeader);

      await reloadMarkersAndRoutes(); // 初始載入場上落點 + 路線
    } catch (e: any) {
      Alert.alert('載入失敗', String(e?.message || e));
    } finally {
      setLoading(false);
      measureCourtBase();
    }
  }

  function normalizeRules(json: string | null | undefined): RuleConfig {
    try {
      const r = json ? JSON.parse(json) : {};
      const pointsToWin = r.pointsToWin ?? r.pointsPerGame ?? 21;
      const winBy = r.deuce === false ? 1 : r.winBy ?? 2;
      const cap = r.cap ?? 30;
      const bestOf = r.bestOf ?? 3;
      return { pointsToWin, winBy, cap, bestOf };
    } catch {
      return { pointsToWin: 21, winBy: 2, cap: 30, bestOf: 3 };
    }
  }

  // 計算「此刻上半場是哪隊」（0=主、1=客），僅用於路線模式的起/訖判定
  function teamAtTopNow(s: MatchState): 0 | 1 {
    let top: 0 | 1 = (s.currentGameIndex % 2 === 0 ? 0 : 1) as 0 | 1;
    const g = s.games[s.currentGameIndex];
    const last = s.rules.bestOf - 1;
    if (s.currentGameIndex === last && g.deciderSidesSwitched) {
      top = (top === 0 ? 1 : 0) as 0 | 1;
    }
    return top;
  }

  // 回放渲染舊路線時，依該局狀態估算「當局上半場是哪隊」
  function teamAtTopInGame(gameIndex1: number): 0 | 1 {
    const s = serveState;
    let top: 0 | 1 = (((gameIndex1 - 1) % 2 === 0) ? 0 : 1) as 0 | 1;
    if (s) {
      const last = s.rules.bestOf - 1;
      if (gameIndex1 - 1 === last) {
        const g = s.games[last];
        if (g?.deciderSidesSwitched) {
          top = (top === 0 ? 1 : 0) as 0 | 1;
        }
      }
    }
    return top;
  }

  async function reloadMarkersAndRoutes() {
    if (!currentMatchId) return;
    const rows: any[] = await listRecentRallies(currentMatchId, 300);
    const ms: Marker[] = [];
    const rts: Array<{ id: string; sx: number; sy: number; ex: number; ey: number; color: string; gi: number; shotType?: string }> = [];
    for (const r of rows) {
      const meta = safeMeta(r.meta_json);
      const sx = r.route_start_rx != null ? Number(r.route_start_rx) : null;
      const sy = r.route_start_ry != null ? Number(r.route_start_ry) : null;
      const ex = r.route_end_rx != null ? Number(r.route_end_rx) : null;
      const ey = r.route_end_ry != null ? Number(r.route_end_ry) : null;
      // markers（畫終點）
      const rx = ex != null ? ex : sx;
      const ry = ey != null ? ey : sy;
      if (rx != null && ry != null) {
        const kind: 'win' | 'loss' = r.winner_side === 'home' ? 'win' : 'loss';
        ms.push({ id: r.id, rx, ry, kind, meta, game: Number(r.game_index || 0) });
      }
      // routes：顏色依「起點方」
      if (sx != null && sy != null && ex != null && ey != null) {
        const gi = Number(r.game_index || 0);
        const top = teamAtTopInGame(gi);
        const startTeam = (sy < 0.5 ? top : (top ^ 1)) as 0 | 1;
        const color = startTeam === 0 ? BLUE : RED;
        rts.push({
          id: r.id,
          sx, sy, ex, ey,
          color,
          gi,
          shotType: meta?.shotType,
        });
      }
    }
    setMarkers(ms);
    setRoutes(rts);
  }

  if (!currentMatchId) {
    return (
      <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center', padding: 20 }}>
        <Text style={{ fontSize: 16, marginBottom: 8 }}>尚未選擇場次</Text>
        <Text style={{ color: '#666', textAlign: 'center' }}>
          請先在賽事/場次頁面建立並選取一個場次，再回到此頁記錄。
        </Text>
      </View>
    );
  }

  // 點擊模式：一律以「得分」開啟面板（不依 side 判定）
  function decideWinInTap(_e: TapEvent): boolean {
    return true;
  }

  // 路線模式點擊
  const onTap = (e: TapEvent) => {
    if (mode === 'tap') {
      const isWin = decideWinInTap(e); // 固定得分面板
      const pointRoute = { start: e.point, end: e.point };
      if (e.zone === 'out')
        openPanel(
          isWin,
          'out',
          e,
          isWin ? { forceType: '主動得分', errorReason: undefined } : { forceType: '主動失誤', errorReason: '出界' },
          pointRoute,
        );
      else openPanel(isWin, e.zone, e, isWin ? { forceType: '主動得分' } : { forceType: '主動失誤' }, pointRoute);
    } else {
      if (!routeStart) {
        // 第一次點：決定預覽顏色（依起點隊伍）
        setRouteStart(e.point);
        setRouteStartNorm(e.norm ?? null);
        setRouteHover(null);
        if (e.norm && serveState) {
          const top = teamAtTopNow(serveState);
          const startTeam = (e.norm.y < 0.5 ? top : (top ^ 1)) as 0 | 1;
          setRoutePreviewColor(startTeam === 0 ? BLUE : RED);
        } else {
          setRoutePreviewColor(BLUE);
        }
      } else {
        // 第二次點：判定得失與面板
        const start = routeStart, end = e.point;
        const startNorm = routeStartNorm;
        const endNorm = e.norm;
        if (!startNorm || !endNorm || !serveState) {
          const defaults = { forceType: e.inBounds ? '主動得分' : '主動失誤', errorReason: e.inBounds ? undefined : '出界' };
          openPanel(e.inBounds, e.inBounds ? (e.zone as Zone) : 'out', e, defaults, { start, end });
          setRouteStart(null); setRouteStartNorm(null); setRouteHover(null); setRoutePreviewColor(undefined);
          return;
        }

        const top = teamAtTopNow(serveState);
        const startTeam = (startNorm.y < 0.5 ? top : (top ^ 1)) as 0 | 1;
        const endTeam = (endNorm.y < 0.5 ? top : (top ^ 1)) as 0 | 1;

        // 預設勝方（起點視角）
        let winnerTeam: 0 | 1;
        if (!e.inBounds) {
          winnerTeam = (startTeam ^ 1) as 0 | 1; // 出界：起點失分
        } else if (endTeam === startTeam) {
          winnerTeam = (startTeam ^ 1) as 0 | 1; // 回自己半場：起點失分
        } else {
          winnerTeam = startTeam; // 跨半場且界內：起點得分
        }
        const isHomeWin = (winnerTeam === 0);
        const didStartWin = (winnerTeam === startTeam);

        // 發球例外（跨半場且界內且 起點=發球方）
        const allowFlip = e.inBounds && endTeam !== startTeam && (typeof ui?.servingTeam === 'number' ? (ui.servingTeam === startTeam) : false);

        // 面板預設（從「起點方」視角）
        const defaults = didStartWin
          ? { forceType: '主動得分' }
          : { forceType: '主動失誤', errorReason: e.inBounds ? undefined : '出界' };

        setPanel({
          isWin: isHomeWin,
          zone: e.inBounds ? (e.zone as Zone) : 'out',
          tapPoint: e.point,
          norm: endNorm,
          meta: { ...defaults },
          route: { start, end },
          routeNorm: { start: startNorm, end: endNorm },
          startTeam,
          allowFlipWin: allowFlip,
        });

        setRouteStart(null);
        setRouteStartNorm(null);
        setRouteHover(null);
        setRoutePreviewColor(undefined);
      }
    }
  };

  const openPanel = (
    isWin: boolean,
    zone: Zone,
    tap: TapEvent,
    defaults: Partial<any>,
    route?: { start: Point; end: Point },
  ) => {
    if (tap?.point) setFocus({ x: tap.point.x, y: tap.point.y });
    setPanel({ isWin, zone, tapPoint: tap.point, norm: tap.norm, meta: { ...defaults }, route });
  };

  const onPressMarker = (id: string) => {
    const m = markers.find(x => x.id === id);
    if (!m) return;
    setMarkerSheet({ visible: true, data: { id: m.id, kind: m.kind, meta: m.meta } });
  };

  async function rebuildServeFromDB() {
    const m = await getMatch(currentMatchId!);
    const players = await getMatchPlayers(currentMatchId!);
    const homePlayers: [any, any] = [
      { id: 'A0', name: players.find(p => p.side === 'home' && p.idx === 0)?.name || '主#1' },
      { id: 'A1', name: players.find(p => p.side === 'home' && p.idx === 1)?.name || '主#2' },
    ];
    const awayPlayers: [any, any] = [
      { id: 'B0', name: players.find(p => p.side === 'away' && p.idx === 0)?.name || '客#1' },
      { id: 'B1', name: players.find(p => p.side === 'away' && p.idx === 1)?.name || '客#2' },
    ];
    const dbHomeRight =
      typeof m?.home_right_when_even_index === 'number' ? (m.home_right_when_even_index as 0 | 1) : 0;
    const dbAwayRight =
      typeof m?.away_right_when_even_index === 'number' ? (m.away_right_when_even_index as 0 | 1) : 0;
    const rules = normalizeRules(m?.rules_json);

    let s = createServeMatch({
      teams: [
        { players: homePlayers as any, startRightIndex: dbHomeRight },
        { players: awayPlayers as any, startRightIndex: dbAwayRight },
      ],
      startingServerTeam:
        typeof m?.starting_server_team === 'number' ? (m.starting_server_team as 0 | 1) : 0,
      startingServerPlayerIndex:
        typeof m?.starting_server_index === 'number' ? (m.starting_server_index as 0 | 1) : undefined,
      rules,
      metadata: { category: (m?.type as any) || 'MD' },
    });

    const all = await listRalliesOrdered(currentMatchId!);
    for (const r of all) {
      const winTeam = r.winner_side === 'home' ? 0 : 1;
      s = nextRally(s, winTeam);
    }
    await saveMatchState(currentMatchId!, serialize(s));
    setServeState(s);
    setUi(getUiSnapshot(s));
    try {
      publishLiveState(currentMatchId!, getUiSnapshot(s));
    } catch {}
  }

  async function handleDeleteRally(id: string) {
    try {
      await deleteRally(id);
      setMarkerSheet({ visible: false, data: null });
      await reloadMarkersAndRoutes();
      await loadRecent();
      await rebuildServeFromDB();
    } catch (e: any) {
      Alert.alert('刪除失敗', String(e?.message || e));
    }
  }

  async function undoLast() {
    const last = await getLastRally(currentMatchId!);
    if (!last) return Alert.alert('提示', '沒有可撤銷的記錄');
    await handleDeleteRally(last.id);
  }

  const fetchGameSums = React.useCallback(async (mid: string): Promise<GameSum[]> => {
    try {
      if (BACKEND === 'supabase') {
        const { data, error } = await supa
          .from('games')
          .select('index_no,home_score,away_score,winner_team')
          .eq('match_id', mid)
          .order('index_no', { ascending: true });
        if (error) throw error;
        return (data || []).map(r => ({
          i: Number(r.index_no || 0),
          home: Number(r.home_score || 0),
          away: Number(r.away_score || 0),
          winner: (r.winner_team == null ? null : Number(r.winner_team)) as 0 | 1 | null,
        }));
      }
      const db = await openDB();
      const [res] = await db.executeSql(
        'SELECT index_no,home_score,away_score,winner_team FROM games WHERE match_id=? ORDER BY index_no ASC',
        [mid],
      );
      const out: GameSum[] = [];
      for (let i = 0; i < res.rows.length; i++) {
        const r = res.rows.item(i);
        out.push({
          i: Number(r.index_no || 0),
          home: Number(r.home_score || 0),
          away: Number(r.away_score || 0),
          winner: (r.winner_team == null ? null : Number(r.winner_team)) as 0 | 1 | null,
        });
      }
      return out;
    } catch {
      return [];
    }
  }, []);

  const savePanel = async () => {
    if (!panel || !serveState) return;
    try {
      const winnerSide: Side = panel.isWin ? 'home' : 'away';

      await addRecord({
        gameIndex: serveState.currentGameIndex + 1,
        rallyNo: records.filter(r => r.gameIndex === serveState.currentGameIndex + 1).length + 1,
        winnerSide,
        endZone: panel.zone,
        route: panel.route ?? (panel.tapPoint ? { start: panel.tapPoint, end: panel.tapPoint } : undefined),
        routeNorm: panel.routeNorm ? { start: panel.routeNorm.start, end: panel.routeNorm.end } : (panel.norm ? { end: panel.norm } : undefined),
        meta: panel.meta,
      });

      const beforeIdx = serveState.currentGameIndex;
      const next = nextRally({ ...serveState }, winnerSide === 'home' ? 0 : 1);
      setServeState(next);
      setUi(getUiSnapshot(next));
      try {
        publishLiveState(currentMatchId!, getUiSnapshot(next));
      } catch {}

      if (next.currentGameIndex > beforeIdx) {
        const ended = next.games[beforeIdx];
        const endedScore = ended.points as [number, number];

        setEndModal({
          type: (() => {
            const wonA = next.games.filter(x => x.winner === 0).length;
            const wonB = next.games.filter(x => x.winner === 1).length;
            const need = Math.floor((next.rules.bestOf || 3) / 2) + 1;
            return (wonA >= need || wonB >= need) ? 'match' : 'game';
          })(),
          gameIndex: beforeIdx + 1,
          score: endedScore,
        });
        setIntervalShownForGame(null);
        setDeciderSwitchShownForGame(null);

        await upsertGameSummary({
          matchId: currentMatchId!,
          gameIndex: beforeIdx + 1,
          home: endedScore[0],
          away: endedScore[1],
          winnerTeam: ended.winner ?? null,
          intervalTaken: !!ended.intervalTaken,
          deciderSwitched: !!ended.deciderSidesSwitched,
        });

      } else {
        const idx = next.currentGameIndex;
        const cur = next.games[idx];
        const curScore = cur.points as [number, number];

        if (cur.intervalTaken && intervalShownForGame !== idx) {
          Alert.alert('技術暫停', '已達技術暫停分數，請暫停與休息。');
          setIntervalShownForGame(idx);
        }
        if (cur.deciderSidesSwitched && deciderSwitchShownForGame !== idx) {
          Alert.alert('換邊提示', '決勝局中場換邊，請注意場地交換。');
          setDeciderSwitchShownForGame(idx);
        }

        await upsertGameSummary({
          matchId: currentMatchId!,
          gameIndex: idx + 1,
          home: curScore[0],
          away: curScore[1],
          winnerTeam: cur.winner ?? null,
          intervalTaken: !!cur.intervalTaken,
          deciderSwitched: !!cur.deciderSidesSwitched,
        });
      }

      await saveMatchState(currentMatchId!, serialize(next));

      const sumsForHeader = await fetchGameSums(currentMatchId!);
      setHeaderSums(sumsForHeader);
      await reloadMarkersAndRoutes();
      if (recSheetOpen) await refreshRecordsSheetData();

      setPanel(null);
      setShiftY(0);
      setFocus(null);
    } catch (e: any) {
      Alert.alert('儲存失敗', String(e?.message || e));
    }
  };

  const currentGameNo = (serveState?.currentGameIndex ?? 0) + 1;

  const shownCourtMarkers = React.useMemo(() => {
    if (courtFilter === 'current') return markers.filter(m => m.game === currentGameNo);
    return markers;
  }, [markers, courtFilter, currentGameNo]);

  const shownRoutes = React.useMemo(() => {
    if (courtFilter === 'current') return routes.filter(r => r.gi === currentGameNo);
    return routes;
  }, [routes, courtFilter, currentGameNo]);

  const openRecordsSheet = async () => {
    if (!currentMatchId) return;
    setRecSheetOpen(true);
    setRecSheetLoading(true);
    await refreshRecordsSheetData();
    setRecSheetLoading(false);
  };

  const refreshRecordsSheetData = async () => {
    if (!currentMatchId) return;
    const [rows, sums] = await Promise.all([listRalliesOrdered(currentMatchId), fetchGameSums(currentMatchId)]);
    const list = rows.map((r: any) => {
      let meta: any = {};
      try { meta = JSON.parse(r.meta_json || '{}'); } catch {}
      return {
        id: r.id as string,
        game: Number(r.game_index || 0),
        no: Number(r.rally_no || 0),
        win: r.winner_side === 'home',
        zone: String(r.end_zone || ''),
        meta,
        createdAt: String(r.created_at || ''),
      };
    });
    setRecSheetRows(list);
    setGameSums(sums);
    setHeaderSums(sums);
  };

  const panelPlayers = React.useMemo(() => {
    const all = [
      { id: 'A0', name: serveState?.teams?.[0]?.players?.[0]?.name || '主#1' },
      { id: 'A1', name: serveState?.teams?.[0]?.players?.[1]?.name || '主#2' },
      { id: 'B0', name: serveState?.teams?.[1]?.players?.[0]?.name || '客#1' },
      { id: 'B1', name: serveState?.teams?.[1]?.players?.[1]?.name || '客#2' },
    ];
    if (!panel?.startTeam && panel?.startTeam !== 0) return all;
    return panel.startTeam === 0 ? all.slice(0, 2) : all.slice(2);
  }, [panel?.startTeam, serveState?.teams]);

  return (
    <View style={{ flex: 1 }}>
      <View style={{ flex: 1, transform: [{ translateY: -shiftY }] }}>
        <View
          style={{
            paddingHorizontal: 12,
            paddingTop: 8,
            paddingBottom: 6,
            backgroundColor: '#fafafa',
            borderBottomWidth: 1,
            borderColor: '#eee',
          }}
        >
          <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' }}>
            <Text style={{ fontSize: 16, fontWeight: '600' }}>記錄模式（{isSingles ? '單打' : '雙打'}）</Text>
            <View style={{ flexDirection: 'row', flexWrap: 'wrap' }}>
              <Pressable
                onPress={undoLast}
                style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#455a64', borderRadius: 8, marginRight: 8 }}
              >
                <Text style={{ color: '#fff' }}>撤銷上一筆</Text>
              </Pressable>
              <Pressable
                onPress={() => navigation.navigate('Analysis', { matchId: currentMatchId })}
                style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#1976d2', borderRadius: 8, marginRight: 8 }}
              >
                <Text style={{ color: '#fff' }}>分析</Text>
              </Pressable>
              <Pressable
                onPress={openRecordsSheet}
                style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#009688', borderRadius: 8, marginRight: 8 }}
              >
                <Text style={{ color: '#fff' }}>記錄</Text>
              </Pressable>
              <Pressable
                onPress={() => setCourtFilter(f => (f === 'all' ? 'current' : 'all'))}
                style={{ paddingVertical: 6, paddingHorizontal: 10, borderRadius: 8, borderWidth: 1, borderColor: '#1976d2', marginLeft: 8 }}
              >
                <Text style={{ color: '#1976d2' }}>{courtFilter === 'all' ? '全部落點/路線' : `本局（第${currentGameNo}局）`}</Text>
              </Pressable>
            </View>
          </View>

          <Text style={{ color: '#555', marginTop: 6 }}>
            發球方：{(ui?.servingTeam ?? 0) === 0 ? '主隊' : '客隊'}，發：
            {serveState?.teams?.[ui?.server?.team ?? 0]?.players?.[ui?.server?.index ?? 0]?.name || ''}（
            {ui?.server?.court === 'R' ? '右' : '左'}），接：
            {serveState?.teams?.[ui?.receiver?.team ?? 1]?.players?.[ui?.receiver?.index ?? 0]?.name || ''}，
            {headerSumsText || `第${currentGameNo}局 ${ui?.scoreA ?? 0}:${ui?.scoreB ?? 0}`}
          </Text>
        </View>

        <View ref={courtWrapRef} onLayout={measureCourtBase} style={{ flex: 1 }}>
          <Court
            orientation={orientation}
            singles={isSingles}
            mode={mode}
            routeStart={routeStart}
            routeHover={routeHover}
            onHover={setRouteHover}
            onTap={onTap}
            markers={shownCourtMarkers}
            onPressMarker={onPressMarker}
            savedRoutes={shownRoutes}
            routePreviewColor={routePreviewColor}
            overlay={{
              awayRight: serveState?.teams?.[0]?.players?.[ui?.positions?.teamA?.right ?? 0]?.name || '',
              awayLeft: serveState?.teams?.[0]?.players?.[ui?.positions?.teamA?.left ?? 1]?.name || '',
              homeRight: serveState?.teams?.[1]?.players?.[ui?.positions?.teamB?.right ?? 0]?.name || '',
              homeLeft: serveState?.teams?.[1]?.players?.[ui?.positions?.teamB?.left ?? 1]?.name || '',
              server: ui?.server ? { team: (ui.server.team === 0 ? 1 : 0) as 0|1, index: ui.server.index as 0|1 } : undefined,
              receiver: ui?.receiver ? { team: (ui.receiver.team === 0 ? 1 : 0) as 0|1, index: ui.receiver.index as 0|1 } : undefined,
              positions: {
                A: { right: (ui?.positions?.teamB?.right ?? 0) as 0|1, left: (ui?.positions?.teamB?.left ?? 1) as 0|1 },
                B: { right: (ui?.positions?.teamA?.right ?? 0) as 0|1, left: (ui?.positions?.teamA?.left ?? 1) as 0|1 },
              },
              opacity: 0.85,
            }}
            focusPoint={focus}
          />
        </View>
      </View>

      <MetaPanel
        visible={!!panel}
        isWin={!!panel?.isWin}
        meta={panel?.meta || {}}
        onChange={m => setPanel(p => (p ? { ...p, meta: m } : p))}
        onCancel={() => { setPanel(null); setShiftY(0); setFocus(null); }}
        onSave={savePanel}
        players={[
          { id: 'A0', name: serveState?.teams?.[0]?.players?.[0]?.name || '主#1' },
          { id: 'A1', name: serveState?.teams?.[0]?.players?.[1]?.name || '主#2' },
          { id: 'B0', name: serveState?.teams?.[1]?.players?.[0]?.name || '客#1' },
          { id: 'B1', name: serveState?.teams?.[1]?.players?.[1]?.name || '客#2' },
        ]}
        startTeam={panel?.startTeam}
        allowFlipWin={!!panel?.allowFlipWin}
        onToggleWin={() => setPanel(p => p ? ({ ...p, isWin: !p.isWin }) : p)}
        showLastHitter={mode === 'route'}
        options={{ shotTypes, errorReasons }}
        onMeasure={setPanelH}
      />
      <MarkerSheet
        visible={markerSheet.visible}
        data={markerSheet.data}
        onClose={() => setMarkerSheet({ visible: false, data: null })}
        onDelete={async id => { await handleDeleteRally(id); setShiftY(0); setFocus(null); }}
      />

      <Modal visible={recSheetOpen} transparent animationType="slide" onRequestClose={() => setRecSheetOpen(false)}>
        <View style={{ flex:1, backgroundColor:'rgba(0,0,0,0.35)', justifyContent:'flex-end' }}>
          <View style={{ backgroundColor:'#1e1e1e', borderTopLeftRadius:16, borderTopRightRadius:16, padding:12, maxHeight:'80%' }}>
            <View style={{ flexDirection:'row', justifyContent:'space-between', alignItems:'center', marginBottom:8 }}>
              <Text style={{ color:'#fff', fontSize:16, fontWeight:'600' }}>全部記錄</Text>
              <Pressable onPress={()=>setRecSheetOpen(false)} style={{ padding:8 }}>
                <Text style={{ color:'#90caf9' }}>關閉</Text>
              </Pressable>
            </View>

            <View style={{ flexDirection:'row', marginBottom:8 }}>
              <Text style={{ color:'#fff' }}>（列表維持原樣；路線模式專屬分析若要另行改版可再開）</Text>
            </View>

            {recSheetLoading ? (
              <View style={{ paddingVertical:30, alignItems:'center' }}>
                <ActivityIndicator color="#90caf9" />
              </View>
            ) : (
              <ScrollView style={{ maxHeight:'100%' }} contentContainerStyle={{ paddingBottom: 10 }}>
                {/* 保持先前的趨勢卡與清單（此處不動點擊/路線差異） */}
              </ScrollView>
            )}
          </View>
        </View>
      </Modal>
    </View>
  );
}

function TrendChart({ title, rows }: { title: string; rows: Array<{ win: boolean }> }) {
  const [w, setW] = React.useState(0);
  const H = 160;
  const PAD = 28;

  const series = React.useMemo(() => {
    const home: number[] = [0];
    const away: number[] = [0];
    let h = 0, a = 0;
    for (let i = 0; i < rows.length; i++) { if (rows[i].win) h++; else a++; home.push(h); away.push(a); }
    const maxY = Math.max(1, h, a);
    return { home, away, maxY };
  }, [rows]);

  const buildPath = (vals: number[], W: number, H: number, maxY: number) => {
    const plotW = Math.max(1, W - PAD * 2);
    const plotH = Math.max(1, H - PAD * 2);
    const n = vals.length; if (n <= 1) return '';
    const stepX = plotW / (n - 1);
    const yOf = (v: number) => PAD + (plotH * (1 - v / maxY));
    let d = `M ${PAD} ${yOf(vals[0])}`;
    for (let i = 1; i < n; i++) {
      const x = PAD + i * stepX;
      const y = yOf(vals[i]);
      d += ` L ${x} ${y}`;
    }
    return d;
  };

  const ticks = React.useMemo(() => {
    const arr: number[] = [];
    for (let v = 0; v <= series.maxY; v += 5) arr.push(v);
    if (arr[arr.length - 1] !== series.maxY) arr.push(series.maxY);
    return arr;
  }, [series.maxY]);

  const yOf = (v: number) => {
    const plotH = Math.max(1, H - PAD * 2);
    return PAD + (plotH * (1 - v / series.maxY));
  };

  return (
    <View onLayout={e => setW(Math.floor(e.nativeEvent.layout.width))} style={{ marginBottom: 10, padding: 10, borderWidth: 1, borderColor: '#333', borderRadius: 10, backgroundColor: '#222' }}>
      <Text style={{ color: '#fff', fontWeight: '600', marginBottom: 8 }}>{title}</Text>
      {w <= 0 ? null : (
        <Svg width={w} height={H}>
          <G>
            <Line x1={PAD} y1={PAD} x2={PAD} y2={H - PAD} stroke="#444" strokeWidth={1} />
            <Line x1={PAD} y1={H - PAD} x2={w - PAD} y2={H - PAD} stroke="#444" strokeWidth={1} />
          </G>
          <G>
            {ticks.map(v => {
              const y = yOf(v);
              return (
                <G key={'tick-'+v}>
                  <Line x1={PAD} y1={y} x2={w - PAD} y2={y} stroke="#3a3a3a" strokeWidth={1} opacity={v === 0 ? 0.55 : 0.28} />
                  <SvgText x={PAD - 6} y={y + 4} fill="#888" fontSize={10} textAnchor="end">{v}</SvgText>
                </G>
              );
            })}
          </G>
          <Path d={buildPath(series.home, w, H, series.maxY)} stroke="#1976d2" strokeWidth={2} fill="none" />
          <Path d={buildPath(series.away, w, H, series.maxY)} stroke="#d32f2f" strokeWidth={2} fill="none" />
        </Svg>
      )}
    </View>
  );
}

function MetaPanel({
  visible,
  isWin,
  meta,
  onChange,
  onCancel,
  onSave,
  players,
  startTeam,
  allowFlipWin,
  onToggleWin,
  showLastHitter,
  options,
  onMeasure,
}: {
  visible: boolean;
  isWin: boolean;                 // 主隊是否得分
  meta: any;
  onChange: (m: any) => void;
  onCancel: () => void;
  onSave: () => void;
  players: Array<{ id: string; name?: string }>;
  startTeam?: 0 | 1;
  allowFlipWin?: boolean;
  onToggleWin?: () => void;
  showLastHitter?: boolean;
  options: { shotTypes: string[]; errorReasons: string[] };
  onMeasure?: (h: number) => void;
}) {
  // 起點方是否得分
  const didStartWin = React.useMemo(() => {
    if (startTeam === 0) return isWin;      // 主起點：主勝即起點勝
    if (startTeam === 1) return !isWin;     // 客起點：客勝=主不勝
    return isWin;
  }, [startTeam, isWin]);

  const flipLabel = React.useMemo(() => {
    if (!allowFlipWin) return '';
    if (startTeam === 0) return didStartWin ? '切換為主隊失分' : '切換為主隊得分';
    return didStartWin ? '切換為客隊失分' : '切換為客隊得分';
  }, [allowFlipWin, didStartWin, startTeam]);

  return (
    <Modal visible={visible} transparent animationType="slide" onRequestClose={onCancel}>
      <View style={{ flex: 1, backgroundColor: 'rgba(0,0,0,0.35)', justifyContent: 'flex-end' }}>
        <View style={{ backgroundColor: '#fff', borderTopLeftRadius: 16, borderTopRightRadius: 16, padding: 16, maxHeight: '60%' }} onLayout={e => onMeasure?.(e.nativeEvent.layout.height)}>
          <View style={{ flexDirection:'row', justifyContent:'space-between', alignItems:'center', marginBottom: 8 }}>
            <Text style={{ fontSize: 16, fontWeight: '600' }}>{didStartWin ? '得分' : '失分'}選項（起點方）</Text>
            {!!allowFlipWin && (
              <Pressable onPress={onToggleWin} style={{ paddingVertical:6, paddingHorizontal:10, borderRadius:8, borderWidth:1, borderColor: '#1976d2', backgroundColor: 'rgba(25,118,210,0.08)' }}>
                <Text style={{ color:'#1976d2' }}>{flipLabel}</Text>
              </Pressable>
            )}
          </View>

          <Group title="球種">
            <ChipList options={options.shotTypes} value={meta.shotType} onSelect={v => onChange({ ...meta, shotType: v === meta.shotType ? undefined : v })} />
          </Group>
          <Group title="正手/反手">
            <ChipList options={['正手', '反手']} value={meta.hand} onSelect={v => onChange({ ...meta, hand: v as any })} />
          </Group>
          <Group title={didStartWin ? '是否主動得分' : '是否主動失誤'}>
            <ChipList options={['主動得分', '對手失誤', '主動失誤', '受迫失誤']} value={meta.forceType} onSelect={v => onChange({ ...meta, forceType: v })} />
          </Group>
          {!didStartWin && (
            <Group title="失誤原因">
              <ChipList options={options.errorReasons as any} value={meta.errorReason} onSelect={v => onChange({ ...meta, errorReason: v })} />
            </Group>
          )}

          {showLastHitter && (
            <Group title="最後擊球選手（僅起點方）">
              <View style={{ flexDirection: 'row', flexWrap: 'wrap' }}>
                {(startTeam === 0 ? players.slice(0,2) : players.slice(2)).map(p => (
                  <Pressable key={p.id} onPress={() => onChange({ ...meta, lastHitter: meta.lastHitter === p.id ? undefined : p.id })} style={{ paddingVertical: 6, paddingHorizontal: 10, borderRadius: 14, borderWidth: 1, borderColor: meta.lastHitter === p.id ? '#1976d2' : '#ccc', backgroundColor: meta.lastHitter === p.id ? 'rgba(25,118,210,0.1)' : '#fff', marginRight: 8, marginBottom: 8 }}>
                    <Text>{p.name || p.id}</Text>
                  </Pressable>
                ))}
              </View>
            </Group>
          )}

          <View style={{ flexDirection: 'row', justifyContent: 'flex-end', marginTop: 2 }}>
            <Pressable onPress={onCancel} style={{ padding: 12, marginRight: 8 }}>
              <Text>取消</Text>
            </Pressable>
            <Pressable onPress={onSave} style={{ padding: 12, backgroundColor: '#1976d2', borderRadius: 8 }}>
              <Text style={{ color: '#fff' }}>儲存</Text>
            </Pressable>
          </View>
        </View>
      </View>
    </Modal>
  );
}

function Group({ title, children }: any) {
  return (
    <View style={{ marginBottom: 10 }}>
      <Text style={{ marginBottom: 6, color: '#333' }}>{title}</Text>
      {children}
    </View>
  );
}
function ChipList({ options, value, onSelect }: { options: string[]; value?: string; onSelect: (v: string) => void }) {
  return (
    <View style={{ flexDirection: 'row', flexWrap: 'wrap' }}>
      {options.map(opt => (
        <Pressable key={opt} onPress={() => onSelect(opt)} style={{ paddingVertical: 6, paddingHorizontal: 10, borderRadius: 14, borderWidth: 1, borderColor: value === opt ? '#1976d2' : '#ccc', backgroundColor: value === opt ? 'rgba(25,118,210,0.1)' : '#fff', marginRight: 8, marginBottom: 8 }}>
          <Text>{opt}</Text>
        </Pressable>
      ))}
    </View>
  );
}
function safeMeta(json: string) { try { return JSON.parse(json || '{}'); } catch { return {}; } }
ezbmt-tracked/src/screens/SpeedScreen.tsx
 
import React from 'react';
import { View, Text, Pressable, Switch } from 'react-native';
import Court from '../components/Court';
import type { Orientation, Point } from '../types';
import { insertSpeedSession, insertSpeedPoints } from '../db';

const FULL_WID = 6.1;  // 直式雙打外框寬（公尺）
const FULL_LEN = 13.4; // 直式雙打外框長（公尺）

export default function SpeedScreen() {
const [orientation] = React.useState<Orientation>('portrait'); // 以直式為主；Court 內部會把 landscape 轉回直式基準運算
const [singles, setSingles] = React.useState(false);          // 只影響繪圖，不影響距離（距離換算固定以雙打外框）
const [routeStart, setRouteStart] = React.useState<Point | null>(null);
const [routeHover, setRouteHover] = React.useState<Point | null>(null);

const [startNorm, setStartNorm] = React.useState<{ x: number; y: number } | null>(null);
const [endNorm, setEndNorm] = React.useState<{ x: number; y: number } | null>(null);

const [autoStart, setAutoStart] = React.useState(true);
const [running, setRunning] = React.useState(false);
const [startTs, setStartTs] = React.useState<number | null>(null);
const [stopTs, setStopTs] = React.useState<number | null>(null);

const clearAll = () => {
setRouteStart(null);
setRouteHover(null);
setStartNorm(null);
setEndNorm(null);
setStartTs(null);
setStopTs(null);
setRunning(false);
};

const onTap = (e: any) => {
// e: TapEvent（來自 Court）
if (!routeStart) {
setRouteStart(e.point);
setRouteHover(null);
setStartNorm(e.norm ?? null);
setEndNorm(null);
setStopTs(null);
if (autoStart) {
setStartTs(Date.now());
setRunning(true);
}
} else {
setRouteHover(e.point);
setEndNorm(e.norm ?? null);
if (running) {
setStopTs(Date.now());
setRunning(false);
} else if (autoStart && startTs == null) {
// 理論上不會進來；保底：若使用者關閉/打開開關後第一次點才起
setStartTs(Date.now());
setRunning(true);
}
}
};

const onHover = (p: Point | null) => {
if (routeStart && !endNorm) setRouteHover(p || null);
};

// 手動控制計時
const manualStart = () => {
setStartTs(Date.now());
setStopTs(null);
setRunning(true);
};
const manualStop = () => {
if (!running) return;
setStopTs(Date.now());
setRunning(false);
};

// 兩點距離（公尺）：norm 是以直式雙打外框（6.1×13.4）為基準
const distanceM = React.useMemo(() => {
if (!startNorm || !endNorm) return 0;
const dx = (endNorm.x - startNorm.x) * FULL_WID;
const dy = (endNorm.y - startNorm.y) * FULL_LEN;
return Math.sqrt(dx * dx + dy * dy);
}, [startNorm, endNorm]);

// 經過時間（秒）
const elapsedSec = React.useMemo(() => {
if (startTs == null) return 0;
const end = (stopTs ?? (running ? Date.now() : null));
if (!end) return 0;
return Math.max(0, (end - startTs) / 1000);
}, [startTs, stopTs, running]);

const ms = distanceM > 0 && elapsedSec > 0 ? distanceM / elapsedSec : 0;
const kmh = ms * 3.6;

return (
<View style={{ flex: 1 }}>
{/* 頂列：工具 */}
<View style={{ padding: 12, borderBottomWidth: 1, borderColor: '#eee', backgroundColor: '#fafafa' }}>
<View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 6 }}>
<Text style={{ fontSize: 16, fontWeight: '600', marginRight: 12 }}>羽球測速</Text>
<Pressable onPress={clearAll} style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#757575', borderRadius: 8 }}>
<Text style={{ color: '#fff' }}>重置</Text>
</Pressable>
</View>

    <View style={{ flexDirection: 'row', alignItems: 'center' }}>
      <Text style={{ marginRight: 8 }}>單打視覺：</Text>
      <Switch value={singles} onValueChange={setSingles} />
      <Text style={{ marginLeft: 16, marginRight: 8 }}>自動計時（第1點→開始，第2點→停止）：</Text>
      <Switch value={autoStart} onValueChange={setAutoStart} />
      {!autoStart && (
        <View style={{ flexDirection: 'row', marginLeft: 12 }}>
          <Pressable
            onPress={manualStart}
            style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#1976d2', borderRadius: 8, marginRight: 8 }}
          >
            <Text style={{ color: '#fff' }}>開始</Text>
          </Pressable>
          <Pressable
            onPress={manualStop}
            style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#d32f2f', borderRadius: 8 }}
          >
            <Text style={{ color: '#fff' }}>停止</Text>
          </Pressable>
        </View>
      )}
    </View>
  </View>

  {/* 球場與互動 */}
  <View style={{ flex: 1 }}>
    <Court
      orientation={orientation}
      singles={singles}
      mode="route"
      routeStart={routeStart}
      routeHover={routeHover}
      onTap={onTap}
      onHover={onHover}
      markers={[]}
      onPressMarker={undefined}
    />
  </View>

  {/* 結果區 */}
  <View style={{ padding: 12, borderTopWidth: 1, borderColor: '#eee' }}>
    <Text style={{ fontWeight: '600', marginBottom: 6 }}>結果</Text>
    <Text>距離：{distanceM.toFixed(3)} m（以雙打外框 6.1×13.4 m 換算）</Text>
    <Text>時間：{elapsedSec.toFixed(3)} s {running ? '（計時中…）' : ''}</Text>
    <Text style={{ marginTop: 4, fontSize: 16 }}>
      速度：{ms.toFixed(2)} m/s（{kmh.toFixed(1)} km/h）
    </Text>
    <Text style={{ color: '#666', marginTop: 6 }}>
      使用方式：在球場上點下「擊球點」與「落點」。若開啟自動計時，第一次點擊即開始、第二次點擊即停止；關閉自動計時時，請用下方按鈕手動開始/停止。
    </Text>
  </View>
</View>
);
}ezbmt-tracked/src/screens/BuddiesScreen.tsx
 
import React from 'react';
import { View, Text, FlatList, TextInput, Pressable, Alert } from 'react-native';
import { useRoute } from '@react-navigation/native';
import { listBuddies, upsertBuddy, deleteBuddy } from '../db';

const C = { bg:'#111', card:'#222', text:'#fff', sub:'#bbb', border:'#333', primary:'#1976d2', warn:'#d32f2f' };

export default function BuddiesScreen() {
const route = useRoute<any>();
const clubId = route.params?.clubId as string;

const [items, setItems] = React.useState<Array<{ id:string; name:string; level:number; gender?:string|null; handedness?:string|null; note?:string|null }>>([]);
const [name, setName] = React.useState('');
const [level, setLevel] = React.useState('5');
const [note, setNote] = React.useState('');

const load = React.useCallback(async ()=>{
try { setItems(await listBuddies(clubId)); }
catch(e:any){ Alert.alert('載入失敗', String(e?.message||e)); }
}, [clubId]);
React.useEffect(()=>{ load(); }, [load]);

const add = async ()=>{
const nm = name.trim();
const lv = Number(level)||1;
if (!nm) return;
try { await upsertBuddy({ clubId, name:nm, level: Math.min(15, Math.max(1, lv)), note: note.trim()||undefined }); setName(''); setLevel('5'); setNote(''); load(); }
catch(e:any){ Alert.alert('新增失敗', String(e?.message||e)); }
};

const remove = async (id:string)=>{
try { await deleteBuddy(id); load(); }
catch(e:any){ Alert.alert('刪除失敗', String(e?.message||e)); }
};

const renderItem = ({ item }: any) => (
<View style={{ padding:10, borderWidth:1, borderColor:C.border, backgroundColor:C.card, borderRadius:10, marginBottom:10, flexDirection:'row', justifyContent:'space-between', alignItems:'center' }}>
<View style={{ flexShrink:1 }}>
<Text style={{ color:C.text, fontWeight:'600' }}>{item.name}（Lv {item.level}）</Text>
{!!item.note && <Text style={{ color:C.sub, marginTop:4 }} numberOfLines={2}>{item.note}</Text>}
</View>
<Pressable onPress={()=>remove(item.id)} style={{ backgroundColor:C.warn, paddingVertical:6, paddingHorizontal:10, borderRadius:8 }}>
<Text style={{ color:'#fff' }}>刪除</Text>
</Pressable>
</View>
);

return (
<View style={{ flex:1, backgroundColor:C.bg, padding:12 }}>
<Text style={{ color:C.text, fontSize:16, fontWeight:'700', marginBottom:8 }}>球友名單</Text>
<FlatList
data={items}
keyExtractor={i=>i.id}
renderItem={renderItem}
ListHeaderComponent={(
<View style={{ borderWidth:1, borderColor:C.border, borderRadius:10, padding:10, marginBottom:10 }}>
<Text style={{ color:C.text, fontWeight:'600', marginBottom:6 }}>新增球友</Text>
<TextInput value={name} onChangeText={setName} placeholder="姓名" placeholderTextColor="#888"
style={{ borderWidth:1, borderColor:'#444', borderRadius:8, paddingHorizontal:10, paddingVertical:8, color:C.text, marginBottom:8 }} />
<TextInput value={level} onChangeText={setLevel} placeholder="等級（1~15）" placeholderTextColor="#888" keyboardType="number-pad"
style={{ borderWidth:1, borderColor:'#444', borderRadius:8, paddingHorizontal:10, paddingVertical:8, color:C.text, marginBottom:8, width:120 }} />
<TextInput value={note} onChangeText={setNote} placeholder="備註（可空）" placeholderTextColor="#888"
style={{ borderWidth:1, borderColor:'#444', borderRadius:8, paddingHorizontal:10, paddingVertical:8, color:C.text, marginBottom:8 }} />
<Pressable onPress={add} style={{ backgroundColor:C.primary, borderRadius:8, paddingVertical:10, alignItems:'center' }}>
<Text style={{ color:'#fff' }}>新增</Text>
</Pressable>
</View>
)}
/>
</View>
);
}ezbmt-tracked/src/screens/ClubAudienceBoardScreen.tsx
 
import React from 'react';
import { View, Text, ScrollView, ActivityIndicator, StatusBar } from 'react-native';
import { useRoute } from '@react-navigation/native';
import { listProjection } from '../db';
import { supa } from '../lib/supabase';

const C = { bg: '#111', card: '#1e1e1e', border: '#333', text: '#fff', sub: '#bbb' };

type MatchItem = {
  court_no: number;
  team_a: { players: Array<{ id:string; name:string }> };
  team_b: { players: Array<{ id:string; name:string }> };
};
type Projection = {
  server_time: string;
  next?: { index: number; planned_start_at?: string|null; matchesPreview: MatchItem[] } | null;
};

type CourtNames = { aNames: string[]; bNames: string[] };
type CourtDisplay = {
  courtNo: number;
  current?: { roundIndex: number; roundId: string; names: CourtNames };
  next?: { roundIndex: number; roundId: string; names: CourtNames };
};

export default function ClubAudienceBoardScreen() {
  const route = useRoute<any>();
  const sessionId: string | undefined = route.params?.sessionId;

  const [loading, setLoading] = React.useState(true);
  const [proj, setProj] = React.useState<Projection | null>(null);
  const [offsetMs, setOffsetMs] = React.useState<number>(0);
  const [countdown, setCountdown] = React.useState<string>('');

  const [courts, setCourts] = React.useState<number>(0);
  const [perCourt, setPerCourt] = React.useState<CourtDisplay[]>([]);

  const fetchAll = React.useCallback(async () => {
    if (!sessionId) return;
    try {
      let courtCount = 0;
      try {
        const { data: srow } = await supa.from('sessions').select('courts').eq('id', sessionId).maybeSingle();
        courtCount = Number(srow?.courts || 0) || 0;
      } catch {}
      setCourts(courtCount);

      try {
        const data = await listProjection(sessionId);
        setProj(data as any);
        const server = new Date((data as any)?.server_time || new Date());
        setOffsetMs(server.getTime() - Date.now());
      } catch {
        setProj(null);
        setOffsetMs(0);
      }

      const pc = await buildPerCourtDisplays(sessionId, courtCount);
      setPerCourt(pc);
    } finally {
      setLoading(false);
    }
  }, [sessionId]);

  React.useEffect(() => {
    if (!sessionId) return;
    fetchAll().catch(()=>{});

    let channel: any = null;
    try {
      channel = supa
        .channel('aud-board-' + sessionId)
        .on('postgres_changes', { event:'*', schema:'public', table:'round_results' }, () => fetchAll().catch(()=>{}))
        .on('postgres_changes', { event:'*', schema:'public', table:'round_courts' }, () => fetchAll().catch(()=>{}))
        .on('postgres_changes', { event:'*', schema:'public', table:'round_matches' }, () => fetchAll().catch(()=>{}))
        .on('postgres_changes', { event:'*', schema:'public', table:'session_rounds' }, () => fetchAll().catch(()=>{}))
        .subscribe();
    } catch {}

    const t = setInterval(() => fetchAll().catch(()=>{}), 5000);
    return () => {
      clearInterval(t);
      try { channel?.unsubscribe(); } catch {}
    };
  }, [sessionId, fetchAll]);

  React.useEffect(() => {
    const t = setInterval(() => tick(), 1000);
    return () => clearInterval(t);
  }, [proj, offsetMs]);

  function tick() {
    const n = proj?.next?.planned_start_at ? new Date(proj.next.planned_start_at) : null;
    if (!n) { setCountdown(''); return; }
    const diff = n.getTime() - (Date.now() + offsetMs);
    if (diff <= 0) { setCountdown('00:00'); return; }
    const s = Math.floor(diff / 1000);
    const mm = String(Math.floor(s/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');
    setCountdown(`${mm}:${ss}`);
  }

  if (!sessionId || loading) {
    return (
      <View style={{ flex:1, backgroundColor:C.bg, alignItems:'center', justifyContent:'center' }}>
        <ActivityIndicator color="#90caf9" />
      </View>
    );
  }

  const next = proj?.next;
  const nextMatches = next?.matchesPreview || [];

  return (
    <View style={{ flex:1, backgroundColor:C.bg }}>
      <StatusBar barStyle="light-content" />
      <ScrollView contentContainerStyle={{ padding: 12 }}>
        <Text style={{ color:'#fff', fontSize: 20, fontWeight:'800', marginBottom: 6 }}>
          {next ? `下一輪（全域）：第 ${next.index} 輪` : '下一輪（全域） ─'}
        </Text>
        {!!countdown && (
          <Text style={{ color:'#ffecb3', fontSize:36, fontWeight:'800', marginBottom:8 }}>
            開賽倒數 {countdown}
          </Text>
        )}

        <Text style={{ color:'#fff', fontSize: 20, fontWeight:'800', marginTop:10, marginBottom:8 }}>目前各場地名單</Text>
        {courts <= 0 ? (
          <Text style={{ color:'#888' }}>本場次未設定球場數</Text>
        ) : perCourt.length === 0 ? (
          <Text style={{ color:'#888' }}>尚無輪次</Text>
        ) : (
          <View style={{ flexDirection:'row', flexWrap:'wrap', justifyContent:'space-between' }}>
            {perCourt.map((c) => (
              <View key={'court-'+c.courtNo} style={{
                width: '49%', minWidth: 280, padding:12,
                backgroundColor:'#1f1f1f', borderRadius:12, borderWidth:1, borderColor:'#333', marginBottom:10
              }}>
                <Text style={{ color:'#fff', fontSize:18, fontWeight:'800', marginBottom:8 }}>
                  場地 {c.courtNo}
                </Text>

                {c.current ? (
                  <>
                    <Text style={{ color:'#bbb', marginBottom: 4 }}>目前：第 {c.current.roundIndex} 輪</Text>
                    <Text style={{ color:'#90caf9', fontSize:16, fontWeight:'700' }}>
                      {c.current.names.aNames.join('、 ')}
                    </Text>
                    <Text style={{ color:'#ddd', textAlign:'center', marginVertical:6, fontSize:16 }}>
                      VS
                    </Text>
                    <Text style={{ color:'#ef9a9a', fontSize:16, fontWeight:'700' }}>
                      {c.current.names.bNames.join('、 ')}
                    </Text>
                  </>
                ) : (
                  <Text style={{ color:'#888' }}>目前：無（此場地所有輪已結束）</Text>
                )}

                {c.next ? (
                  <View style={{ marginTop:8 }}>
                    <Text style={{ color:'#bbb', marginBottom:4 }}>預告：第 {c.next.roundIndex} 輪</Text>
                    <Text style={{ color:'#90caf9' }}>
                      {c.next.names.aNames.join('、 ')}
                    </Text>
                    <Text style={{ color:'#ddd', textAlign:'center', marginVertical:4 }}>VS</Text>
                    <Text style={{ color:'#ef9a9a' }}>
                      {c.next.names.bNames.join('、 ')}
                    </Text>
                  </View>
                ) : (
                  <Text style={{ color:'#555', marginTop: 8 }}>預告：—</Text>
                )}
              </View>
            ))}
          </View>
        )}

        <Text style={{ color:'#fff', fontSize: 20, fontWeight:'800', marginTop:10, marginBottom:6 }}>
          全域下一輪預覽
        </Text>
        {nextMatches.length > 0 ? (
          <View style={{ flexDirection:'row', flexWrap:'wrap', justifyContent:'space-between' }}>
            {nextMatches.map((m, idx) => (
              <View key={'next-'+idx} style={{
                width: '49%', minWidth: 280, padding:12,
                backgroundColor:'#1f1f1f', borderRadius:12, borderWidth:1, borderColor:'#333', marginBottom:10
              }}>
                <Text style={{ color:'#fff', fontSize:18, fontWeight:'800', marginBottom:8 }}>場地 {m.court_no}</Text>
                <Text style={{ color:'#90caf9', fontSize:16, fontWeight:'700' }}>
                  {(m.team_a?.players||[]).map(p=>p.name).join('、 ')}
                </Text>
                <Text style={{ color:'#ddd', textAlign:'center', marginVertical:6, fontSize:16 }}>
                  VS
                </Text>
                <Text style={{ color:'#ef9a9a', fontSize:16, fontWeight:'700' }}>
                  {(m.team_b?.players||[]).map(p=>p.name).join('、 ')}
                </Text>
              </View>
            ))}
          </View>
        ) : (
          <Text style={{ color:'#888' }}>尚無預覽對戰</Text>
        )}
      </ScrollView>
    </View>
  );
}

async function buildPerCourtDisplays(sessionId: string, courts: number): Promise<CourtDisplay[]> {
  const out: CourtDisplay[] = [];
  if (!sessionId || courts <= 0) return out;

  const { data: rounds } = await supa
    .from('session_rounds')
    .select('id,index_no')
    .eq('session_id', sessionId)
    .order('index_no', { ascending: true });

  const rlist = (rounds || []).map((r:any) => ({ id: String(r.id), index: Number(r.index_no || 0) }));
  if (!rlist.length) return out;

  const roundIds = rlist.map(r => r.id);

  const { data: rr } = await supa
    .from('round_results')
    .select('round_id,court_no,finished_at')
    .in('round_id', roundIds as any);

  const finished = new Set<string>();
  (rr || []).forEach((row:any) => {
    const fin = !!row.finished_at;
    if (fin) finished.add(`${row.round_id}#${Number(row.court_no)}`);
  });

  const { data: rms } = await supa
    .from('round_matches')
    .select('round_id,court_no,team_a,team_b')
    .in('round_id', roundIds as any);

  const matchMap = new Map<string, CourtNames>();
  (rms || []).forEach((m:any) => {
    const key = `${m.round_id}#${Number(m.court_no)}`;
    const aNames = ((m.team_a?.players)||[]).map((p:any)=> String(p?.name || ''));
    const bNames = ((m.team_b?.players)||[]).map((p:any)=> String(p?.name || ''));
    matchMap.set(key, { aNames, bNames });
  });

  const { data: rcs } = await supa
    .from('round_courts')
    .select('round_id,court_no,team_a_ids,team_b_ids')
    .in('round_id', roundIds as any);

  const courtsMap = new Map<string, { aIds: string[]; bIds: string[] }>();
  const allIds = new Set<string>();
  (rcs || []).forEach((row:any) => {
    const key = `${row.round_id}#${Number(row.court_no)}`;
    const aIds = Array.isArray(row.team_a_ids) ? row.team_a_ids.map(String) : [];
    const bIds = Array.isArray(row.team_b_ids) ? row.team_b_ids.map(String) : [];
    courtsMap.set(key, { aIds, bIds });
    aIds.concat(bIds).forEach((id:string)=> allIds.add(id));
  });

  let buddyName: Record<string,string> = {};
  if (allIds.size > 0) {
    const ids = Array.from(allIds);
    const { data: buds } = await supa
      .from('buddies')
      .select('id,name')
      .in('id', ids as any);
    buddyName = Object.fromEntries((buds||[]).map((b:any)=> [String(b.id), String(b.name || '')]));
  }

  const namesOf = (roundId: string, courtNo: number): CourtNames => {
    const k = `${roundId}#${courtNo}`;
    const direct = matchMap.get(k);
    if (direct) return direct;
    const co = courtsMap.get(k);
    if (!co) return { aNames: [], bNames: [] };
    const mapNames = (ids: string[]) => ids.map(id => buddyName[id] || (id ? id.slice(0,6)+'…' : ''));
    return { aNames: mapNames(co.aIds), bNames: mapNames(co.bIds) };
  };

  for (let c = 1; c <= courts; c++) {
    let curIdx = -1;
    for (let i = 0; i < rlist.length; i++) {
      const r = rlist[i];
      const done = finished.has(`${r.id}#${c}`);
      if (!done) { curIdx = i; break; }
    }

    let cur: CourtDisplay['current'] | undefined = undefined;
    let nxt: CourtDisplay['next'] | undefined = undefined;

    if (curIdx >= 0) {
      const r = rlist[curIdx];
      cur = { roundIndex: r.index, roundId: r.id, names: namesOf(r.id, c) };
      if (curIdx + 1 < rlist.length) {
        const n = rlist[curIdx + 1];
        nxt = { roundIndex: n.index, roundId: n.id, names: namesOf(n.id, c) };
      }
    } else {
      cur = undefined;
      nxt = undefined;
    }

    out.push({ courtNo: c, current: cur, next: nxt });
  }

  return out;
}ezbmt-tracked/src/screens/SettingsScreen.tsx
 
import React from 'react';
import { View, Text, FlatList, TextInput, Pressable, Alert, Switch } from 'react-native';
import { listDictionary, upsertDictionary, deleteDictionary } from '../db';

const C = {
bg: '#111',
card: '#222',
border: '#333',
field: '#111',
fieldBorder: '#444',
text: '#fff',
sub: '#ddd',
hint: '#888',
};

export default function SettingsScreen() {
const [kindShot, setKindShot] = React.useState(true); // true=shot_type, false=error_reason
const [items, setItems] = React.useState<Array<{id:string;label:string;order_no:number}>>([]);
const [label, setLabel] = React.useState('');
const [order, setOrder] = React.useState('0');

const load = React.useCallback(async () => {
const k = kindShot ? 'shot_type' : 'error_reason';
const rows = await listDictionary(k as any);
setItems(rows as any);
}, [kindShot]);

React.useEffect(()=>{ load(); }, [load]);

const add = async () => {
if (!label.trim()) return;
try {
await upsertDictionary({ kind: kindShot ? 'shot_type':'error_reason', label: label.trim(), order_no: Number(order)||0 });
setLabel(''); setOrder('0'); load();
} catch (e:any) { Alert.alert('新增失敗', String(e?.message||e)); }
};

const remove = async (id:string) => {
try { await deleteDictionary(id); load(); } catch(e:any){ Alert.alert('刪除失敗', String(e?.message||e)); }
};

const renderItem = ({item}:{item:{id:string;label:string;order_no:number}}) => (
<View style={{ padding:10, borderWidth:1, borderColor:C.border, backgroundColor:C.card, borderRadius:8, marginBottom:8, flexDirection:'row', justifyContent:'space-between', alignItems:'center' }}>
<Text style={{ color: C.text }}>{item.label}（排序 {item.order_no}）</Text>
<Pressable onPress={()=>remove(item.id)} style={{ paddingVertical:6, paddingHorizontal:10, backgroundColor:'#d32f2f', borderRadius:8 }}>
<Text style={{ color:'#fff' }}>刪除</Text>
</Pressable>
</View>
);

return (
<View style={{ flex:1, padding:12, backgroundColor: C.bg }}>
<View style={{ flexDirection:'row', alignItems:'center', marginBottom:8 }}>
<Text style={{ marginRight:8, color: C.text }}>編輯：</Text>
<Text style={{ marginRight:6, color: kindShot?'#90caf9':C.sub }}>球種</Text>
<Switch
value={kindShot}
onValueChange={setKindShot}
trackColor={{ false: '#555', true: '#1976d2' }}
thumbColor="#fff"
/>
<Text style={{ marginLeft:6, color: !kindShot?'#90caf9':C.sub }}>失誤原因</Text>
</View>

  <FlatList
    data={items}
    keyExtractor={(i)=>i.id}
    renderItem={renderItem}
  />

  <View style={{ borderTopWidth:1, borderColor:C.border, paddingTop:10, marginTop:10 }}>
    <Text style={{ fontWeight:'600', marginBottom:6, color: C.text }}>新增</Text>
    <TextInput
      placeholder="名稱（如：切球）"
      placeholderTextColor={C.hint}
      value={label}
      onChangeText={setLabel}
      style={{ borderWidth:1, borderColor:C.fieldBorder, borderRadius:8, paddingHorizontal:10, paddingVertical:8, marginBottom:6, color: C.text, backgroundColor: C.field }}
    />
    <TextInput
      placeholder="排序（數字，小到大）"
      placeholderTextColor={C.hint}
      value={order}
      onChangeText={setOrder}
      keyboardType="number-pad"
      style={{ borderWidth:1, borderColor:C.fieldBorder, borderRadius:8, paddingHorizontal:10, paddingVertical:8, marginBottom:8, width:160, color: C.text, backgroundColor: C.field }}
    />
    <Pressable onPress={add} style={{ backgroundColor:'#1976d2', paddingVertical:10, borderRadius:8, alignItems:'center' }}>
      <Text style={{ color:'#fff' }}>新增項目</Text>
    </Pressable>
  </View>
</View>
);
}ezbmt-tracked/src/screens/AnalysisScreen.tsx
 
import React from 'react';
import { View, Text, Pressable, Alert, ScrollView } from 'react-native';
import { useRoute, useNavigation } from '@react-navigation/native';
import { listRalliesOrdered } from '../db';
import Heatmap from '../components/Heatmap';
import HeatGrid from '../components/HeatGrid';
import ZoneMatrix from '../components/ZoneMatrix';
import SimpleBarChart, { BarRow } from '../components/SimpleBarChart';
import { shareCsv, shareJson } from '../lib/exportPdf';
import { exportPdfReport } from '../lib/export';

/* 工具（模組層） */
function safeMeta(json: string) { try { return JSON.parse(json || '{}'); } catch { return {}; } }
function csvSafe(v:any){ return v==null ? '' : String(v).replace(/,/g,';').replace(/\r?\n/g,' '); }
function uniq(arr: any[]) { const set = new Set<string>(); const out: any[] = []; for (let i=0;i<arr.length;i++){ const v = String(arr[i]); if (!set.has(v)) { set.add(v); out.push(arr[i]); } } return out; }

/* 型別 */
type Row = {
  id: string;
  match_id: string;
  game_index: number;
  rally_no: number;
  winner_side: 'home' | 'away';
  end_zone: string; // '1'..'6'|'out'
  meta_json: string;
  route_end_rx?: number | null;
  route_end_ry?: number | null;
  route_start_rx?: number | null;
  route_start_ry?: number | null;
};

export default function AnalysisScreen() {
  const route = useRoute<any>();
  const navigation = useNavigation<any>();
  const matchId = route.params?.matchId as string;

  const [rows, setRows] = React.useState<Row[]>([]);
  const [loading, setLoading] = React.useState(true);

  // Heatmap 尺寸（一般分析用）
  const [heatW, setHeatW] = React.useState(0);
  const [heatH, setHeatH] = React.useState(0);

  // 一般分析的篩選
  const [gameFilter, setGameFilter] = React.useState<number | 'ALL'>('ALL');
  const [resultFilter, setResultFilter] = React.useState<'ALL'|'WIN'|'LOSS'>('ALL');
  const [shotFilter, setShotFilter] = React.useState<string>('ALL');
  const [forceFilter, setForceFilter] = React.useState<string>('ALL');
  const [reasonFilter, setReasonFilter] = React.useState<string>('ALL');
  const [hasRouteOnly, setHasRouteOnly] = React.useState<boolean>(false);

  // 一般分析視圖切換
  const [viewMode, setViewMode] = React.useState<'scatter'|'grid'>('grid');
  const [gridSize, setGridSize] = React.useState(20);

  // 分頁：一般分析 / 路線分析
  const [tab, setTab] = React.useState<'click'|'route'>('click');

  React.useEffect(() => {
    (async () => {
      try {
        const rs = await listRalliesOrdered(matchId);
        setRows((rs as unknown) as Row[]);
      } catch (e: any) {
        Alert.alert('載入失敗', String(e && e.message ? e.message : e));
      } finally {
        setLoading(false);
      }
    })();
  }, [matchId]);

  // 是否存在路線起點資料 → 有才顯示「路線分析」分頁
  const routeDataExists = React.useMemo(
    () => rows.some(r => r.route_start_rx != null && r.route_start_ry != null),
    [rows]
  );

  // ==============================
  // 一般（點擊模式）分析（保持原樣）
  // ==============================
  const filtered = React.useMemo(() => {
    return rows.filter((r) => {
      if (gameFilter !== 'ALL' && r.game_index !== gameFilter) return false;
      const meta = safeMeta(r.meta_json);
      if (resultFilter === 'WIN' && r.winner_side !== 'home') return false;
      if (resultFilter === 'LOSS' && r.winner_side !== 'away') return false;
      if (shotFilter !== 'ALL' && (meta.shotType || '') !== shotFilter) return false;
      if (forceFilter !== 'ALL' && (meta.forceType || '') !== forceFilter) return false;
      if (reasonFilter !== 'ALL' && (meta.errorReason || '') !== reasonFilter) return false;
      if (hasRouteOnly) {
        const has = (r.route_end_rx != null && r.route_end_ry != null) || (r.route_start_rx != null && r.route_start_ry != null);
        if (!has) return false;
      }
      return true;
    });
  }, [rows, gameFilter, resultFilter, shotFilter, forceFilter, reasonFilter, hasRouteOnly]);

  const points = filtered
    .map((r) => {
      const rx = (r.route_end_rx != null ? r.route_end_rx : r.route_start_rx);
      const ry = (r.route_end_ry != null ? r.route_end_ry : r.route_start_ry);
      if (rx == null || ry == null) return null;
      return { rx: Number(rx), ry: Number(ry), kind: r.winner_side === 'home' ? 'win' : 'loss' as const };
    })
    .filter(Boolean) as Array<{ rx: number; ry: number; kind: 'win' | 'loss' }>;

  const byZone = groupByZone(filtered);
  const byMeta = groupMeta(filtered);
  const games = uniq(rows.map(r => r.game_index));
  const optsShot = uniq(rows.map(r => safeMeta(r.meta_json).shotType || '')).filter(Boolean) as string[];
  const optsForce = uniq(rows.map(r => safeMeta(r.meta_json).forceType || '')).filter(Boolean) as string[];
  const optsReason = uniq(rows.map(r => safeMeta(r.meta_json).errorReason || '')).filter(Boolean) as string[];

  const shotAgg: BarRow[] = React.useMemo(() => {
    const map = new Map<string, { win:number; loss:number }>();
    for (let i=0;i<filtered.length;i++){
      const r = filtered[i];
      const meta = safeMeta(r.meta_json);
      const k = meta.shotType || '未填';
      const cur = map.get(k) || { win:0, loss:0 };
      if (r.winner_side === 'home') cur.win += 1; else cur.loss += 1;
      map.set(k, cur);
    }
    const arr: BarRow[] = [];
    map.forEach((v,k)=>arr.push({ label:k, win:v.win, loss:v.loss }));
    arr.sort((a,b)=> (b.win+b.loss) - (a.win+a.loss));
    return arr;
  }, [filtered]);

  const playableIds = React.useMemo(() => {
    return filtered
      .filter(r => (r.route_end_rx != null && r.route_end_ry != null) || (r.route_start_rx != null && r.route_start_ry != null))
      .map(r => r.id);
  }, [filtered]);

  function avgRouteLen(rs: Row[]) {
    let n = 0, sum = 0;
    for (let i = 0; i < rs.length; i++) {
      const r = rs[i];
      const sx = (r.route_start_rx != null ? Number(r.route_start_rx) : null);
      const sy = (r.route_start_ry != null ? Number(r.route_start_ry) : null);
      const ex = (r.route_end_rx != null ? Number(r.route_end_rx) : null);
      const ey = (r.route_end_ry != null ? Number(r.route_end_ry) : null);
      if (sx == null || sy == null || ex == null || ey == null) continue;
      sum += Math.hypot(ex - sx, ey - sy);
      n += 1;
    }
    return n ? (sum / n) : 0;
  }

  // ==============================
  // 路線分析（新增、不影響一般分析）
  // ==============================
  const routeScopeRows = React.useMemo(() => {
    if (!routeDataExists) return [];
    // 路線分析沿用「局數」篩選（其他條件不套用）
    return rows.filter(r => {
      if (r.route_start_rx == null || r.route_start_ry == null) return false;
      if (gameFilter !== 'ALL' && r.game_index !== gameFilter) return false;
      return true;
    });
  }, [rows, gameFilter, routeDataExists]);

  // 奇數局主在上、偶數局客在上（分析層不處理決勝局技術暫停中途換邊）
  const startTeamOfRow = React.useCallback((r: Row): 0|1 => {
    const top: 0|1 = (r.game_index % 2 === 1) ? 0 : 1;
    const sy = Number(r.route_start_ry);
    return (sy < 0.5 ? top : (top ^ 1)) as 0|1;
  }, []);

  const hasFullRoute = React.useCallback((r: Row) =>
    r.route_start_rx != null && r.route_start_ry != null &&
    r.route_end_rx   != null && r.route_end_ry   != null
  , []);

  const routeStats = React.useMemo(() => {
    const out = {
      home: { wins: 0, losses: 0, points: [] as Array<{ rx:number; ry:number; kind:'win'|'loss' }>, shot: new Map<string,{win:number;loss:number}>() },
      away: { wins: 0, losses: 0, points: [] as Array<{ rx:number; ry:number; kind:'win'|'loss' }>, shot: new Map<string,{win:number;loss:number}>() },
    };
    for (const r of routeScopeRows) {
      const ex = r.route_end_rx != null ? Number(r.route_end_rx) : null;
      const ey = r.route_end_ry != null ? Number(r.route_end_ry) : null;
      const st = startTeamOfRow(r);
      const wt = (r.winner_side === 'home' ? 0 : 1) as 0|1;
      const didStartWin = (wt === st);

      const tgt = st === 0 ? out.home : out.away;
      if (didStartWin) tgt.wins += 1; else tgt.losses += 1;

      if (ex != null && ey != null) {
        tgt.points.push({ rx: ex, ry: ey, kind: didStartWin ? 'win' : 'loss' });
      }

      const k = (safeMeta(r.meta_json).shotType || '未填') as string;
      const cur = tgt.shot.get(k) || { win:0, loss:0 };
      if (didStartWin) cur.win += 1; else cur.loss += 1;
      tgt.shot.set(k, cur);
    }

    const toBars = (m: Map<string,{win:number;loss:number}>): BarRow[] => {
      const arr: BarRow[] = [];
      m.forEach((v,k)=>arr.push({ label:k, win:v.win, loss:v.loss }));
      arr.sort((a,b)=> (b.win+b.loss)-(a.win+a.loss));
      return arr;
    };

    return {
      home: { wins: out.home.wins, losses: out.home.losses, points: out.home.points, bars: toBars(out.home.shot) },
      away: { wins: out.away.wins, losses: out.away.losses, points: out.away.points, bars: toBars(out.away.shot) },
    };
  }, [routeScopeRows, startTeamOfRow]);

  const routeHomePct = React.useMemo(() => {
    const t = routeStats.home.wins + routeStats.home.losses;
    return t ? Math.round((routeStats.home.wins / t) * 100) : 0;
  }, [routeStats]);
  const routeAwayPct = React.useMemo(() => {
    const t = routeStats.away.wins + routeStats.away.losses;
    return t ? Math.round((routeStats.away.wins / t) * 100) : 0;
  }, [routeStats]);

  // ==============================
  // Render
  // ==============================
  if (loading) {
    return (
      <View style={{ flex:1, alignItems:'center', justifyContent:'center' }}>
        <Text>載入中…</Text>
      </View>
    );
  }

  return (
    <ScrollView contentContainerStyle={{ padding: 12 }}>
      {/* 分頁切換 */}
      <View style={{ flexDirection:'row', marginBottom:10 }}>
        <Chip text="一般分析" active={tab==='click'} onPress={()=>setTab('click')} />
        {routeDataExists && <Chip text="路線分析" active={tab==='route'} onPress={()=>setTab('route')} />}
      </View>

      {tab === 'click' ? (
        <>
          <Text style={{ fontSize: 16, fontWeight: '600', marginBottom: 8 }}>熱區（終點/單擊落點）</Text>

          {/* 篩選列（保留） */}
          <Filters
            games={uniq(rows.map(r=>r.game_index))}
            gameFilter={gameFilter}
            setGameFilter={setGameFilter}
            resultFilter={resultFilter}
            setResultFilter={setResultFilter}
            shotFilter={shotFilter}
            setShotFilter={setShotFilter}
            forceFilter={forceFilter}
            setForceFilter={setForceFilter}
            reasonFilter={reasonFilter}
            setReasonFilter={setReasonFilter}
            optsShot={optsShot as string[]}
            optsForce={optsForce as string[]}
            optsReason={optsReason as string[]}
          />

          <View style={{ flexDirection:'row', flexWrap:'wrap', alignItems:'center', marginBottom:8 }}>
            <Chip text={'僅含線路：' + (hasRouteOnly ? '開' : '關')} active={hasRouteOnly} onPress={()=>setHasRouteOnly(v=>!v)} />
            <Text style={{ marginLeft: 12, color:'#555' }}>平均路徑長度（相對單位）：{avgRouteLen(filtered).toFixed(3)}</Text>
          </View>

          {/* 視圖切換（保留） */}
          <View style={{ flexDirection:'row', marginBottom:8 }}>
            <Chip text="散點" active={viewMode==='scatter'} onPress={()=>setViewMode('scatter')} />
            <Chip text="熱區" active={viewMode==='grid'} onPress={()=>setViewMode('grid')} />
          </View>

          <View
            style={{ alignSelf:'stretch', aspectRatio: 6.1/13.4, backgroundColor:'#f3f3f3', borderRadius:8, overflow:'hidden', marginBottom: 12 }}
            onLayout={(e) => {
              const w = Math.floor(e.nativeEvent.layout.width || 0);
              const h = Math.floor(w / (6.1/13.4));
              setHeatW(w); setHeatH(h);
            }}
          >
            {heatW > 0 && heatH > 0 && (
              viewMode === 'scatter'
                ? <Heatmap width={heatW} height={heatH} points={points} />
                : <HeatGrid width={heatW} height={heatH} points={points} grid={gridSize} mode="all" />
            )}
          </View>

          {/* 區域矩陣（保留） */}
          <ZoneMatrix stats={byZone} showOut title="區域矩陣（6區＋界外）" />

          <Text style={{ fontSize: 16, fontWeight: '600', marginTop: 12, marginBottom: 8 }}>區域統計（清單）</Text>
          {Object.keys(byZone).sort().map((k) => (
            <Text key={k} style={{ marginBottom: 4 }}>
              區 {k}：得分 {byZone[k].win}，失分 {byZone[k].loss}
            </Text>
          ))}

          <Text style={{ fontSize: 16, fontWeight: '600', marginTop: 12, marginBottom: 8 }}>球種 × 主/受迫 × 原因</Text>
          {byMeta.map((m, idx) => (
            <Text key={String(idx)} style={{ marginBottom: 4 }}>
              {(m.shot || '未填') + '｜' + (m.force || '未填') + '｜' + (m.reason || '—')}：{m.count} 次
            </Text>
          ))}

          {/* 球種分布長條圖（保留） */}
          <View style={{ marginTop: 12 }}>
            <SimpleBarChart data={shotAgg} title="球種分布（得/失）" />
          </View>

          <View style={{ height: 12 }} />

          {/* 動作按鈕列（保留） */}
          <View style={{ flexDirection:'row', flexWrap:'wrap' }}>
            <Pressable
              onPress={() => {
                if (playableIds.length === 0) {
                  Alert.alert('提示', '目前篩選結果沒有可播放的路徑');
                  return;
                }
                navigation.navigate('Replay', { matchId, ids: playableIds });
              }}
              style={{ padding: 12, backgroundColor: '#009688', borderRadius: 8, marginRight: 8 }}
            >
              <Text style={{ color:'#fff' }}>路徑回放</Text>
            </Pressable>

            <Pressable onPress={() => exportCsv(matchId, filtered)} style={{ padding: 12, backgroundColor: '#1976d2', borderRadius: 8, marginRight: 8 }}>
              <Text style={{ color:'#fff' }}>分享 CSV</Text>
            </Pressable>

            <Pressable onPress={() => shareJson(matchId, filtered)} style={{ padding: 12, backgroundColor: '#455a64', borderRadius: 8, marginRight: 8 }}>
              <Text style={{ color:'#fff' }}>分享 JSON</Text>
            </Pressable>

            <Pressable
              onPress={async () => {
                try {
                  const shotAggForPdf = shotAgg;
                  const routesSample = filtered.map((r)=> {
                    const sx = (r.route_start_rx != null ? Number(r.route_start_rx) : null);
                    const sy = (r.route_start_ry != null ? Number(r.route_start_ry) : null);
                    const ex = (r.route_end_rx != null ? Number(r.route_end_rx) : null);
                    const ey = (r.route_end_ry != null ? Number(r.route_end_ry) : null);
                    if (sx==null||sy==null||ex==null||ey==null) return null;
                    return { sx, sy, ex, ey, kind: r.winner_side==='home'?'win':'loss' as const };
                  }).filter(Boolean) as Array<{sx:number;sy:number;ex:number;ey:number;kind:'win'|'loss'}>;

                  await exportPdfReport(matchId, {
                    points,
                    zoneStat: groupByZone(filtered),
                    metaStat: groupMeta(filtered),
                    shotAgg: shotAggForPdf,
                    routesSample,
                  });
                } catch (e:any) {
                  Alert.alert('匯出失敗', String(e?.message || e));
                }
              }}
              style={{ padding: 12, backgroundColor: '#2e7d32', borderRadius: 8 }}
            >
              <Text style={{ color:'#fff' }}>匯出 PDF</Text>
            </Pressable>
          </View>
        </>
      ) : (
        // ================= 路線分析分頁 =================
        <>
          <Text style={{ fontSize: 16, fontWeight: '700', marginBottom: 8 }}>路線分析（由起點隊伍視角）</Text>
          <Text style={{ color:'#666', marginBottom: 6 }}>只使用有路線起點的資料；局數篩選仍生效。</Text>

          {/* 主隊（起點）摘要 */}
          <SummaryCard title="主隊（起點）" wins={routeStats.home.wins} losses={routeStats.home.losses} pct={routeHomePct} color="#1976d2" />
          {/* 客隊（起點）摘要 */}
          <SummaryCard title="客隊（起點）" wins={routeStats.away.wins} losses={routeStats.away.losses} pct={routeAwayPct} color="#d32f2f" />

          {/* 熱區：終點分布 */}
          <Section title="主隊（起點）終點熱區">
            <FitHeatGrid points={routeStats.home.points} grid={gridSize} />
          </Section>
          <Section title="客隊（起點）終點熱區">
            <FitHeatGrid points={routeStats.away.points} grid={gridSize} />
          </Section>

          {/* 球種分布 */}
          <Section title="主隊（起點）球種分布（得/失）">
            <SimpleBarChart data={routeStats.home.bars} />
          </Section>
          <Section title="客隊（起點）球種分布（得/失）">
            <SimpleBarChart data={routeStats.away.bars} />
          </Section>

          {/* 路線回放（完整起訖） */}
          <View style={{ flexDirection:'row', flexWrap:'wrap', marginTop:12 }}>
            <Pressable
              onPress={()=>{
                const ids = routeScopeRows.filter(hasFullRoute).map(r=>r.id);
                if (!ids.length) { Alert.alert('提示','此篩選範圍沒有可播放的路徑'); return; }
                navigation.navigate('Replay', { matchId, ids });
              }}
              style={{ padding: 12, backgroundColor:'#009688', borderRadius:8, marginRight:8, marginBottom:8 }}
            >
              <Text style={{ color:'#fff' }}>回放此範圍（全部）</Text>
            </Pressable>

            <Pressable
              onPress={()=>{
                const ids = routeScopeRows
                  .filter(hasFullRoute)
                  .filter(r => startTeamOfRow(r) === 0)
                  .map(r=>r.id);
                if (!ids.length) { Alert.alert('提示','此範圍內沒有「主隊起點」可播放的路徑'); return; }
                navigation.navigate('Replay', { matchId, ids });
              }}
              style={{ padding: 12, backgroundColor:'#1976d2', borderRadius:8, marginRight:8, marginBottom:8 }}
            >
              <Text style={{ color:'#fff' }}>回放主隊起點</Text>
            </Pressable>

            <Pressable
              onPress={()=>{
                const ids = routeScopeRows
                  .filter(hasFullRoute)
                  .filter(r => startTeamOfRow(r) === 1)
                  .map(r=>r.id);
                if (!ids.length) { Alert.alert('提示','此範圍內沒有「客隊起點」可播放的路徑'); return; }
                navigation.navigate('Replay', { matchId, ids });
              }}
              style={{ padding: 12, backgroundColor:'#d32f2f', borderRadius:8, marginBottom:8 }}
            >
              <Text style={{ color:'#fff' }}>回放客隊起點</Text>
            </Pressable>
          </View>
        </>
      )}
    </ScrollView>
  );
}

/* 子元件與工具 */
function SummaryCard({ title, wins, losses, pct, color }: { title:string; wins:number; losses:number; pct:number; color:string }) {
  // 進度條以數值寬度呈現（量測避免百分比width）
  const [trackW, setTrackW] = React.useState(0);
  const innerW = Math.round(trackW * Math.max(0, Math.min(1, pct / 100)));

  return (
    <View style={{ borderWidth:1, borderColor:'#eee', borderRadius:12, padding:12, marginBottom:10, backgroundColor:'#fff' }}>
      <Text style={{ fontWeight:'700', marginBottom:6 }}>{title}</Text>
      <View style={{ flexDirection:'row', alignItems:'center', justifyContent:'space-between' }}>
        <Text style={{ color:color, fontSize:24, fontWeight:'800' }}>{wins}</Text>
        <Text style={{ color:'#999', fontSize:16 }}>勝率 {pct}%</Text>
        <Text style={{ color:'#d32f2f', fontSize:24, fontWeight:'800' }}>{losses}</Text>
      </View>
      <View
        onLayout={e=>setTrackW(Math.floor(e.nativeEvent.layout.width || 0))}
        style={{ height:8, backgroundColor:'#eee', borderRadius:6, overflow:'hidden', marginTop:8 }}
      >
        <View style={{ width: innerW, height: 8, backgroundColor: color }} />
      </View>
    </View>
  );
}
function Section({ title, children }: any) {
  return (
    <View style={{ marginTop: 12 }}>
      <Text style={{ fontSize: 16, fontWeight: '600', marginBottom: 8 }}>{title}</Text>
      {children}
    </View>
  );
}
function FitHeatGrid({ points, grid }: { points: Array<{ rx:number; ry:number; kind:'win'|'loss' }>; grid:number }) {
  const [w, setW] = React.useState(0);
  const ar = 6.1 / 13.4;
  const H = w>0 ? Math.floor(w / ar) : 0;
  return (
    <View onLayout={e=>setW(Math.floor(e.nativeEvent.layout.width || 0))}>
      {w>0 && H>0 ? (
        <View style={{ width: w, height: H, backgroundColor:'#f3f3f3', borderRadius:8, overflow:'hidden' }}>
          <HeatGrid width={w} height={H} points={points} grid={grid} mode="all" />
        </View>
      ) : null}
    </View>
  );
}
function Filters(props: {
  games: number[];
  gameFilter: number|'ALL'; setGameFilter: (v:number|'ALL')=>void;
  resultFilter: 'ALL'|'WIN'|'LOSS'; setResultFilter: (v:'ALL'|'WIN'|'LOSS')=>void;
  shotFilter: string; setShotFilter:(v:string)=>void;
  forceFilter: string; setForceFilter:(v:string)=>void;
  reasonFilter: string; setReasonFilter:(v:string)=>void;
  optsShot: string[]; optsForce: string[]; optsReason: string[];
}) {
  return (
    <View style={{ marginBottom: 8 }}>
      <Row>
        <Chip text="全部局" active={props.gameFilter==='ALL'} onPress={()=>props.setGameFilter('ALL')} />
        {props.games.map(g => <Chip key={String(g)} text={'第'+g+'局'} active={props.gameFilter===g} onPress={()=>props.setGameFilter(g)} />)}
      </Row>
      <Row>
        <Chip text="勝負：全部" active={props.resultFilter==='ALL'} onPress={()=>props.setResultFilter('ALL')} />
        <Chip text="得分" active={props.resultFilter==='WIN'} onPress={()=>props.setResultFilter('WIN')} />
        <Chip text="失分" active={props.resultFilter==='LOSS'} onPress={()=>props.setResultFilter('LOSS')} />
      </Row>
      <Row>
        <Chip text="球種：全部" active={props.shotFilter==='ALL'} onPress={()=>props.setShotFilter('ALL')} />
        {props.optsShot.map(s => <Chip key={s} text={s} active={props.shotFilter===s} onPress={()=>props.setShotFilter(s)} />)}
      </Row>
      <Row>
        <Chip text="主/受迫：全部" active={props.forceFilter==='ALL'} onPress={()=>props.setForceFilter('ALL')} />
        {props.optsForce.map(s => <Chip key={s} text={s} active={props.forceFilter===s} onPress={()=>props.setForceFilter(s)} />)}
      </Row>
      <Row>
        <Chip text="原因：全部" active={props.reasonFilter==='ALL'} onPress={()=>props.setReasonFilter('ALL')} />
        {props.optsReason.map(s => <Chip key={s} text={s} active={props.reasonFilter===s} onPress={()=>props.setReasonFilter(s)} />)}
      </Row>
    </View>
  );
}
function Row({ children }: any) { return <View style={{ flexDirection:'row', flexWrap:'wrap', marginBottom:6 }}>{children}</View>; }
function Chip({ text, active, onPress }: { text: string; active?: boolean; onPress: ()=>void }) {
  return (
    <Pressable onPress={onPress} style={{
      paddingVertical:6, paddingHorizontal:10, borderRadius:14,
      borderWidth:1, borderColor: active ? '#1976d2' : '#ccc',
      backgroundColor: active ? 'rgba(25,118,210,0.1)' : '#fff',
      marginRight:8, marginBottom:8
    }}>
      <Text>{text}</Text>
    </Pressable>
  );
}

/* 原有群組函式 */
function groupByZone(rows: Row[]) {
  const acc: Record<string, { win: number; loss: number }> = {};
  for (let i = 0; i < rows.length; i++) {
    const r = rows[i];
    const z = String(r.end_zone || 'out');
    if (!acc[z]) acc[z] = { win: 0, loss: 0 };
    if (r.winner_side === 'home') acc[z].win += 1; else acc[z].loss += 1;
  }
  return acc;
}
function groupMeta(rows: Row[]) {
  const map = new Map<string, number>();
  for (let i = 0; i < rows.length; i++) {
    const meta = safeMeta(rows[i].meta_json);
    const shot = meta && meta.shotType ? String(meta.shotType) : '';
    const force = meta && meta.forceType ? String(meta.forceType) : '';
    const reason = meta && meta.errorReason ? String(meta.errorReason) : '';
    const key = [shot, force, reason].join('||');
    const prev = map.get(key) || 0;
    map.set(key, prev + 1);
  }
  const out: { shot?: string; force?: string; reason?: string; count: number }[] = [];
  map.forEach((count, key) => {
    const parts = key.split('||');
    out.push({ shot: parts[0] || '', force: parts[1] || '', reason: parts[2] || '', count: count });
  });
  out.sort((a,b)=> b.count - a.count);
  return out;
}

/* CSV 匯出（保留） */
function exportCsv(matchId: string, rows: Row[]) {
  const header = ['game_index','rally_no','winner_side','end_zone','shotType','hand','forceType','errorReason','end_rx','end_ry'];
  const lines = [header.join(',')];
  for (let i=0;i<rows.length;i++) {
    const r = rows[i];
    const meta = safeMeta(r.meta_json);
    const end_rx = (r.route_end_rx != null ? r.route_end_rx : r.route_start_rx) ?? '';
    const end_ry = (r.route_end_ry != null ? r.route_end_ry : r.route_start_ry) ?? '';
    const line = [
      r.game_index, r.rally_no, r.winner_side, r.end_zone,
      csvSafe(meta.shotType), csvSafe(meta.hand), csvSafe(meta.forceType), csvSafe(meta.errorReason),
      end_rx, end_ry
    ].join(',');
    lines.push(line);
  }
  const csv = lines.join('\n');
  shareCsv(matchId, csv).catch((e)=>Alert.alert('分享失敗', String(e && e.message ? e.message : e)));
}ezbmt-tracked/src/screens/SessionsScreen.tsx
 
import React from 'react';
import { View, Text, FlatList, TextInput, Pressable, Alert } from 'react-native';
import { useRoute, useNavigation } from '@react-navigation/native';
import {
listSessions,
createSession,
signupSession,
cancelSignup,
listSessionSubscriptions,
subscribeSessionNotification,
unsubscribeSessionNotification,
} from '../db';
import { supa } from '../lib/supabase';

const C = { bg:'#111', card:'#1e1e1e', text:'#fff', sub:'#bbb', border:'#333', primary:'#1976d2', btn:'#1976d2' };

type SessionItem = { id:string; date:string; courts:number; round_minutes:number };

export default function SessionsScreen() {
const route = useRoute<any>();
const nav = useNavigation<any>();
const clubId = route.params?.clubId as string;

const [items, setItems] = React.useState<SessionItem[]>([]);
const [date, setDate] = React.useState('2025-01-01');
const [courts, setCourts] = React.useState('3');
const [roundMin, setRoundMin] = React.useState('15');

// 報名與通知追蹤狀態
const [mySignups, setMySignups] = React.useState<Record<string, boolean>>({});
const [mySubs, setMySubs] = React.useState<Record<string, boolean>>({});
const [busy, setBusy] = React.useState<string | null>(null);
const [busySub, setBusySub] = React.useState<string | null>(null);

const load = React.useCallback(async ()=>{
try {
const rows = await listSessions(clubId) as SessionItem[];
setItems(rows);

  // 讀取使用者是否已報名
  try {
    const { data: me } = await supa.auth.getUser();
    const uid = me?.user?.id;
    if (!uid || rows.length === 0) { setMySignups({}); setMySubs({}); return; }

    // 報名狀態
    const ids = rows.map((r: SessionItem) => r.id);
    const { data } = await supa
      .from('sessions_signups')
      .select('session_id')
      .eq('user_id', uid)
      .in('session_id', ids as any);
    const sMap: Record<string, boolean> = {};
    (data || []).forEach((r: any) => { sMap[String(r.session_id)] = true; });
    setMySignups(sMap);

    // 通知追蹤狀態
    try {
      const subsMap = await listSessionSubscriptions(ids);
      setMySubs(subsMap);
    } catch { setMySubs({}); }
  } catch {
    setMySignups({});
    setMySubs({});
  }
} catch(e:any){ Alert.alert('載入失敗', String(e?.message||e)); }
}, [clubId]);

React.useEffect(()=>{ load(); }, [load]);

const add = async ()=>{
try {
await createSession({
clubId,
date: date.trim(),
courts: Math.max(1, Number(courts)||1),
roundMinutes: Math.max(5, Number(roundMin)||15),
});
setDate('2025-01-01'); setCourts('3'); setRoundMin('15'); load();
} catch(e:any){ Alert.alert('新增失敗', String(e?.message||e)); }
};

const doSignup = async (sessionId:string) => {
setBusy(sessionId);
try {
await signupSession(sessionId);
setMySignups(prev => ({ ...prev, [sessionId]: true }));
Alert.alert('成功','已送出報名');
} catch (e:any) {
Alert.alert('報名失敗', String(e?.message || e));
} finally { setBusy(null); }
};

const doCancel = async (sessionId:string) => {
setBusy(sessionId);
try {
await cancelSignup(sessionId);
setMySignups(prev => {
const copy = { ...prev }; delete copy[sessionId]; return copy;
});
Alert.alert('成功','已取消報名');
} catch (e:any) {
Alert.alert('取消失敗', String(e?.message || e));
} finally { setBusy(null); }
};

const subOn = async (sessionId: string) => {
setBusySub(sessionId);
try {
await subscribeSessionNotification(sessionId);
setMySubs(prev => ({ ...prev, [sessionId]: true }));
} catch (e:any) {
Alert.alert('追蹤失敗', String(e?.message || e));
} finally { setBusySub(null); }
};

const subOff = async (sessionId: string) => {
setBusySub(sessionId);
try {
await unsubscribeSessionNotification(sessionId);
setMySubs(prev => {
const copy = { ...prev }; delete copy[sessionId]; return copy;
});
} catch (e:any) {
Alert.alert('取消追蹤失敗', String(e?.message || e));
} finally { setBusySub(null); }
};

const renderItem = ({ item }: { item: SessionItem }) => {
const signed = !!mySignups[item.id];
const subbed = !!mySubs[item.id];

return (
  <View style={{ padding:10, borderWidth:1, borderColor:C.border, backgroundColor:C.card, borderRadius:10, marginBottom:10 }}>
    <Text style={{ color:C.text, fontWeight:'600' }}>{item.date}　{item.courts} 場 / 每輪 {item.round_minutes} 分鐘</Text>
    <View style={{ flexDirection:'row', marginTop:8, flexWrap:'wrap' }}>
      <Pressable
        onPress={()=>nav.navigate('SessionCheckIn', { sessionId: item.id, clubId })}
        style={{ backgroundColor:C.btn, paddingVertical:8, paddingHorizontal:12, borderRadius:8, marginRight:8, marginBottom:8 }}
      >
        <Text style={{ color:'#fff' }}>報到名單</Text>
      </Pressable>

      <Pressable
        onPress={()=>nav.navigate('ClubPairing', { sessionId: item.id })}
        style={{ backgroundColor:'#00695c', paddingVertical:8, paddingHorizontal:12, borderRadius:8, marginRight:8, marginBottom:8 }}
      >
        <Text style={{ color:'#fff' }}>排點（進階）</Text>
      </Pressable>

      <Pressable
        onPress={()=>nav.navigate('ClubBoard', { sessionId: item.id })}
        style={{ backgroundColor:'#5d4037', paddingVertical:8, paddingHorizontal:12, borderRadius:8, marginRight:8, marginBottom:8 }}
      >
        <Text style={{ color:'#fff' }}>看板</Text>
      </Pressable>

      <Pressable
        onPress={()=>nav.navigate('ClubBoardAudience', { sessionId: item.id })}
        style={{ backgroundColor:'#455a64', paddingVertical:8, paddingHorizontal:12, borderRadius:8, marginRight:8, marginBottom:8 }}
      >
        <Text style={{ color:'#fff' }}>看板（唯讀）</Text>
      </Pressable>

      <Pressable
        onPress={()=>nav.navigate('SessionSignups', { sessionId: item.id, clubId })}
        style={{ backgroundColor:'#7b1fa2', paddingVertical:8, paddingHorizontal:12, borderRadius:8, marginRight:8, marginBottom:8 }}
      >
        <Text style={{ color:'#fff' }}>報名/候補</Text>
      </Pressable>

      {/* 使用者側：報名 / 取消報名 */}
      {!signed ? (
        <Pressable
          onPress={()=>doSignup(item.id)}
          disabled={busy===item.id}
          style={{ backgroundColor: busy===item.id ? '#555' : '#1976d2', paddingVertical:8, paddingHorizontal:12, borderRadius:8, marginRight:8, marginBottom:8 }}
        >
          <Text style={{ color:'#fff' }}>{busy===item.id?'處理中…':'我要報名'}</Text>
        </Pressable>
      ) : (
        <Pressable
          onPress={()=>doCancel(item.id)}
          disabled={busy===item.id}
          style={{ backgroundColor: busy===item.id ? '#555' : '#9e9e9e', paddingVertical:8, paddingHorizontal:12, borderRadius:8, marginRight:8, marginBottom:8 }}
        >
          <Text style={{ color:'#fff' }}>{busy===item.id?'處理中…':'取消報名'}</Text>
        </Pressable>
      )}

      {/* 追蹤通知 / 取消追蹤 */}
      {!subbed ? (
        <Pressable
          onPress={()=>subOn(item.id)}
          disabled={busySub===item.id}
          style={{ backgroundColor: busySub===item.id ? '#555' : '#0288d1', paddingVertical:8, paddingHorizontal:12, borderRadius:8, marginRight:8, marginBottom:8 }}
        >
          <Text style={{ color:'#fff' }}>{busySub===item.id?'處理中…':'追蹤通知'}</Text>
        </Pressable>
      ) : (
        <Pressable
          onPress={()=>subOff(item.id)}
          disabled={busySub===item.id}
          style={{ backgroundColor: busySub===item.id ? '#555' : '#78909c', paddingVertical:8, paddingHorizontal:12, borderRadius:8, marginRight:8, marginBottom:8 }}
        >
          <Text style={{ color:'#fff' }}>{busySub===item.id?'處理中…':'取消追蹤'}</Text>
        </Pressable>
      )}
    </View>
  </View>
);
};

return (
<View style={{ flex:1, backgroundColor:C.bg, padding:12 }}>
<Text style={{ color:C.text, fontSize:16, fontWeight:'700', marginBottom:8 }}>場次</Text>
<FlatList
data={items}
keyExtractor={(i)=>i.id}
renderItem={renderItem}
ListHeaderComponent={(
<View style={{ borderWidth:1, borderColor:C.border, borderRadius:10, padding:10, marginBottom:10 }}>
<Text style={{ color:C.text, fontWeight:'600', marginBottom:6 }}>新增場次</Text>
<TextInput value={date} onChangeText={setDate} placeholder="日期（YYYY-MM-DD）" placeholderTextColor="#888"
style={{ borderWidth:1, borderColor:'#444', borderRadius:8, paddingHorizontal:10, paddingVertical:8, color:C.text, marginBottom:8 }} />
<View style={{ flexDirection:'row' }}>
<TextInput value={courts} onChangeText={setCourts} placeholder="球場數" placeholderTextColor="#888" keyboardType="number-pad"
style={{ borderWidth:1, borderColor:'#444', borderRadius:8, paddingHorizontal:10, paddingVertical:8, color:C.text, marginBottom:8, marginRight:8, width:120 }} />
<TextInput value={roundMin} onChangeText={setRoundMin} placeholder="每輪分鐘數" placeholderTextColor="#888" keyboardType="number-pad"
style={{ borderWidth:1, borderColor:'#444', borderRadius:8, paddingHorizontal:10, paddingVertical:8, color:C.text, marginBottom:8, width:140 }} />
</View>
<Pressable onPress={add} style={{ backgroundColor:C.primary, borderRadius:8, paddingVertical:10, alignItems:'center' }}>
<Text style={{ color:'#fff' }}>建立</Text>
</Pressable>
</View>
)}
/>
</View>
);
}ezbmt-tracked/src/screens/QuickScoreboardScreen.tsx
 
import React from 'react';
import {
View,
Text,
ScrollView,
Pressable,
TextInput,
Alert,
ActivityIndicator,
Modal,
FlatList,
TextInput as RNTextInput,
KeyboardAvoidingView,
Platform,
} from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useWindowDimensions } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import {
createMatch,
nextRally,
getUiSnapshot,
serialize,
deserialize,
type MatchState,
} from '../logic/serve';
import { listClubs, getMyClubRoles, listBuddies } from '../db';

const STORE_KEY = 'quick-scoreboard:prefs:v3';

const C = {
bg: '#111',
card: '#1e1e1e',
text: '#fff',
sub: '#bbb',
border: '#333',
red: '#c62828',
teal: '#00838f',
chip: '#90caf9',
btn: '#1976d2',
gray: '#616161',
};

type PlayerForm = { name: string };
type Rules = { bestOf: 1 | 3; pointsToWin: 11 | 15 | 21 | 25 | 31; deuce: boolean };
type Config = {
singles: boolean;
home: [PlayerForm, PlayerForm];
away: [PlayerForm, PlayerForm];
homeRight: 0 | 1;
awayRight: 0 | 1;
startingTeam: 0 | 1;
startingIndex: 0 | 1;
rules: Rules;
};

const DEFAULT_CFG: Config = {
singles: false,
home: [{ name: '' }, { name: '' }],
away: [{ name: '' }, { name: '' }],
homeRight: 0,
awayRight: 0,
startingTeam: 0,
startingIndex: 0,
rules: { bestOf: 1, pointsToWin: 25, deuce: true },
};

export default function QuickScoreboardScreen() {
// hooks
const { width, height } = useWindowDimensions();
const isPortrait = height >= width;
const insets = useSafeAreaInsets();

const [mode, setMode] = React.useState<'setup' | 'board'>('setup');
const [cfg, setCfg] = React.useState<Config>(DEFAULT_CFG);
const [loading, setLoading] = React.useState(true);

// 球友名單（彙整我為 owner 的社團）
const [buddies, setBuddies] = React.useState<Array<{ id: string; name: string }>>([]);
const [picker, setPicker] = React.useState<{
open: boolean;
target?: 'home0' | 'home1' | 'away0' | 'away1';
q: string;
}>({ open: false, q: '' });

// 計分狀態
const [state, setState] = React.useState<MatchState | null>(null);
const [snap, setSnap] = React.useState<any>(null);

// 撤銷歷史（序列化後的狀態堆疊）
const historyRef = React.useRef<string[]>([]);

React.useEffect(() => {
(async () => {
try {
const s = await AsyncStorage.getItem(STORE_KEY);
if (s) {
try {
setCfg({ ...DEFAULT_CFG, ...(JSON.parse(s) as any) });
} catch {}
}
await loadMyBuddies();
} finally {
setLoading(false);
}
})();
}, []);

async function loadMyBuddies() {
try {
const clubs = (await listClubs()) as Array<{ id: string }>;
const out: Array<{ id: string; name: string }> = [];

  for (const c of clubs) {
    try {
      const roles = await getMyClubRoles([c.id]);
      const myRole = roles[c.id] || '';
      if (myRole === 'owner') {
        const rows = (await listBuddies(c.id)) as Array<{ id: string; name?: string | null }>;
        rows.forEach((b: { id: string; name?: string | null }) => {
          out.push({ id: b.id, name: (b.name ?? '') });
        });
      }
    } catch {}
  }

  // 以名字去重
  const map = new Map<string, string>();
  out.forEach((b: { id: string; name: string }) => {
    if (b.name) map.set(b.name, b.id);
  });
  setBuddies(Array.from(map.entries()).map(([name, id]) => ({ id, name })));
} catch {}
}

function setPlayer(team: 'home' | 'away', idx: 0 | 1, name: string) {
setCfg(prev => {
const next = { ...prev, [team]: [...(prev as any)[team]] } as Config;
(next as any)[team][idx] = { name };
return next;
});
}
function openPick(team: 'home' | 'away', idx: 0 | 1) {
setPicker({ open: true, target: `${team}${idx}` as any, q: '' });
}
function applyPick(name: string) {
if (!picker.target) {
setPicker({ open: false, q: '' });
return;
}
const t = picker.target as 'home0' | 'home1' | 'away0' | 'away1';
const team = t.startsWith('home') ? 'home' : 'away';
const idx = (t.endsWith('0') ? 0 : 1) as 0 | 1;
setPlayer(team as any, idx, name);
setPicker({ open: false, q: '' });
}

function startBoard() {
try {
const homePlayers: [any, any] = [
{ id: 'A0', name: cfg.home[0].name || '主#1' },
{ id: 'A1', name: cfg.singles ? '' : (cfg.home[1].name || '主#2') },
];
const awayPlayers: [any, any] = [
{ id: 'B0', name: cfg.away[0].name || '客#1' },
{ id: 'B1', name: cfg.singles ? '' : (cfg.away[1].name || '客#2') },
];
const rules = {
bestOf: cfg.rules.bestOf,
pointsToWin: cfg.rules.pointsToWin,
winBy: cfg.rules.deuce ? 2 : 1,
cap: cfg.rules.pointsToWin === 21 ? 30 : null,
technicalTimeoutAt: null,
changeEndsInDeciderAt: null,
} as any;

  const s = createMatch({
    teams: [
      { players: homePlayers, startRightIndex: cfg.homeRight },
      { players: awayPlayers, startRightIndex: cfg.awayRight },
    ],
    rules,
    startingServerTeam: cfg.startingTeam,
    startingServerPlayerIndex: cfg.startingIndex,
    metadata: { category: cfg.singles ? 'MD' : 'MD' },
  });
  setState(s);
  setSnap(getUiSnapshot(s));
  setMode('board');
  // 清空歷史，開始新堆疊
  historyRef.current = [];
  AsyncStorage.setItem(STORE_KEY, JSON.stringify(cfg)).catch(() => {});
} catch (e: any) {
  Alert.alert('開始失敗', String(e?.message || e));
}
}

function score(team: 0 | 1) {
if (!state) return;
// 入堆疊（序列化）
try {
historyRef.current.push(serialize(state));
if (historyRef.current.length > 500) historyRef.current.shift();
} catch {}
const next = nextRally({ ...state }, team);
setState(next);
setSnap(getUiSnapshot(next));
}

function undoScore() {
if (!historyRef.current.length) return;
const last = historyRef.current.pop()!;
try {
const prev = deserialize(last);
setState(prev);
setSnap(getUiSnapshot(prev));
} catch {
// 若反序列化失敗則忽略
}
}

// 字級：依最短邊自動縮放；分數儘量大
const shortSide = Math.min(width, height);
const bigFont = Math.max(52, Math.floor(shortSide * 0.50)); // 放大到 50%
const nameFont = Math.max(16, Math.floor(shortSide * 0.06));

// 顯示名字
const homeNames = [cfg.home[0].name || '主#1', cfg.singles ? '' : (cfg.home[1].name || '主#2')];
const awayNames = [cfg.away[0].name || '客#1', cfg.singles ? '' : (cfg.away[1].name || '客#2')];

// 站位/發接球
const posA = snap?.positions?.teamA || { right: 0, left: 1 };
const posB = snap?.positions?.teamB || { right: 0, left: 1 };
const nameHomeR = homeNames[posA.right] || '';
const nameHomeL = cfg.singles ? '' : (homeNames[posA.left] || '');
const nameAwayR = awayNames[posB.right] || '';
const nameAwayL = cfg.singles ? '' : (awayNames[posB.left] || '');

const srvTeam = snap?.server?.team as 0 | 1 | undefined;
const srvIdx = snap?.server?.index as 0 | 1 | undefined;
const srvCourt = snap?.server?.court as 'R' | 'L' | undefined;
const rcvTeam = snap?.receiver?.team as 0 | 1 | undefined;
const rcvIdx = snap?.receiver?.index as 0 | 1 | undefined;
const rcvCourt = snap?.receiver?.court as 'R' | 'L' | undefined;

const isSrv = (t: 0 | 1, idx: 0 | 1) => srvTeam === t && srvIdx === idx;
const isRcv = (t: 0 | 1, idx: 0 | 1) => rcvTeam === t && rcvIdx === idx;

// ================== 板面（不改手機方向；直式時把容器旋轉 90°） ==================
if (mode === 'board') {
const scoreA = snap?.scoreA ?? 0;
const scoreB = snap?.scoreB ?? 0;

const rotateStyle = isPortrait
  ? { width: height, height: width, transform: [{ rotate: '90deg' }] }
  : { width, height, transform: [{ rotate: '0deg' }] };

return (
  <View style={{ flex: 1, backgroundColor: C.bg, alignItems: 'center', justifyContent: 'center' }}>
    <View style={[{ backgroundColor: C.bg }, rotateStyle]}>
      {/* 上方列：規則 + 發/接訊息 */}
      <View style={{ paddingHorizontal: 8, paddingTop: 8, paddingBottom: 6 }}>
        <Text style={{ color: C.sub }}>
          {`規則：${cfg.rules.bestOf} 局 · 到 ${cfg.rules.pointsToWin} 分 · ${cfg.rules.deuce ? 'Deuce開' : 'Deuce關'}  ｜  `}
          {`發：${
            srvTeam === 0
              ? homeNames[srvIdx ?? 0]
              : srvTeam === 1
              ? awayNames[srvIdx ?? 0]
              : '-'
          }（${srvCourt || '-'}）  `}
          {`接：${
            rcvTeam === 0
              ? homeNames[rcvIdx ?? 0]
              : rcvTeam === 1
              ? awayNames[rcvIdx ?? 0]
              : '-'
          }（${rcvCourt || '-'}）`}
        </Text>
      </View>

      <View style={{ flex: 1, flexDirection: 'row' }}>
        {/* 左：主隊（點擊加分） */}
        <Pressable
          style={{ flex: 1, backgroundColor: C.red, alignItems: 'center', justifyContent: 'center' }}
          onPress={() => score(0)}
        >
          <Text style={{ color: '#fff', fontSize: bigFont, fontWeight: '900' }}>
            {String(scoreA).padStart(2, '0')}
          </Text>

          {/* 主隊站位（右/左） */}
          <View
            style={{
              position: 'absolute',
              bottom: 12,
              left: 0,
              right: 0,
              alignItems: 'center',
            }}
          >
            <View
              style={{
                width: '88%',
                flexDirection: 'row',
                justifyContent: 'space-between',
                alignItems: 'center',
              }}
            >
              <Seat
                label="右"
                name={nameHomeR}
                highlightSrv={isSrv(0, posA.right)}
                highlightRcv={isRcv(0, posA.right)}
                style={{ flexBasis: '48%', maxWidth: '48%' }}
              />
              {!cfg.singles && (
                <Seat
                  label="左"
                  name={nameHomeL}
                  highlightSrv={isSrv(0, posA.left)}
                  highlightRcv={isRcv(0, posA.left)}
                  style={{ flexBasis: '48%', maxWidth: '48%' }}
                />
              )}
            </View>
          </View>
        </Pressable>

        {/* 右：客隊（點擊加分） */}
        <Pressable
          style={{ flex: 1, backgroundColor: C.teal, alignItems: 'center', justifyContent: 'center' }}
          onPress={() => score(1)}
        >
          <Text style={{ color: '#fff', fontSize: bigFont, fontWeight: '900' }}>
            {String(scoreB).padStart(2, '0')}
          </Text>

          {/* 客隊站位（右/左） */}
          <View
            style={{
              position: 'absolute',
              bottom: 12,
              left: 0,
              right: 0,
              alignItems: 'center',
            }}
          >
            <View
              style={{
                width: '88%',
                flexDirection: 'row',
                justifyContent: 'space-between',
                alignItems: 'center',
              }}
            >
              <Seat
                label="右"
                name={nameAwayR}
                highlightSrv={isSrv(1, posB.right)}
                highlightRcv={isRcv(1, posB.right)}
                style={{ flexBasis: '48%', maxWidth: '48%' }}
              />
              {!cfg.singles && (
                <Seat
                  label="左"
                  name={nameAwayL}
                  highlightSrv={isSrv(1, posB.left)}
                  highlightRcv={isRcv(1, posB.left)}
                  style={{ flexBasis: '48%', maxWidth: '48%' }}
                />
              )}
            </View>
          </View>
        </Pressable>
      </View>

      {/* 右上角：設定 + 撤銷 */}
      <View style={{ position: 'absolute', right: 90, top: 5, flexDirection: 'row' }}>
        <Pressable
          onPress={undoScore}
          style={{
            paddingVertical: 6,
            paddingHorizontal: 10,
            borderRadius: 8,
            borderWidth: 1,
            borderColor: '#eee',
            backgroundColor: 'rgba(0,0,0,0.25)',
            marginRight: 8,
          }}
        >
          <Text style={{ color: '#fff' }}>撤銷</Text>
        </Pressable>

        <Pressable
          onPress={() => setMode('setup')}
          style={{
            paddingVertical: 6,
            paddingHorizontal: 10,
            borderRadius: 8,
            borderWidth: 1,
            borderColor: '#eee',
            backgroundColor: 'rgba(0,0,0,0.25)',
          }}
        >
          <Text style={{ color: '#fff' }}>設定</Text>
        </Pressable>
      </View>
    </View>
  </View>
);
}

// ================== 設定模式（加 KeyboardAvoidingView，避免被鍵盤遮住） ==================
if (loading) {
return (
<View style={{ flex: 1, backgroundColor: C.bg, alignItems: 'center', justifyContent: 'center' }}>
<ActivityIndicator color="#90caf9" />
</View>
);
}

return (
<KeyboardAvoidingView
style={{ flex: 1, backgroundColor: C.bg }}
behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
keyboardVerticalOffset={Platform.OS === 'ios' ? Math.max(0, insets.top) : 0}
>
<ScrollView
style={{ flex: 1, backgroundColor: C.bg }}
contentContainerStyle={{ padding: 12, paddingBottom: (insets.bottom || 0) + 24 }}
keyboardShouldPersistTaps="handled"
>
<Text style={{ color: C.text, fontSize: 18, fontWeight: '800', marginBottom: 8 }}>
快速計分板（本機）
</Text>

    <Card title="規則">
      <Row label="局數">
        <Chip text="1 局" active={cfg.rules.bestOf === 1} onPress={() => setCfg(p => ({ ...p, rules: { ...p.rules, bestOf: 1 } }))} />
        <Chip text="3 局" active={cfg.rules.bestOf === 3} onPress={() => setCfg(p => ({ ...p, rules: { ...p.rules, bestOf: 3 } }))} />
      </Row>
      <Row label="分數">
        {[11, 15, 21, 25, 31].map(p => (
          <Chip
            key={p}
            text={`${p}`}
            active={cfg.rules.pointsToWin === p}
            onPress={() => setCfg(s => ({ ...s, rules: { ...s.rules, pointsToWin: p as any } }))}
          />
        ))}
      </Row>
      <Row label="Deuce">
        <Chip
          text={cfg.rules.deuce ? '開' : '關'}
          active={cfg.rules.deuce}
          onPress={() => setCfg(s => ({ ...s, rules: { ...s.rules, deuce: !s.rules.deuce } }))}
        />
      </Row>
    </Card>

    <Card title="模式與起始">
      <Row label="模式">
        <Chip text="雙打" active={!cfg.singles} onPress={() => setCfg(p => ({ ...p, singles: false }))} />
        <Chip text="單打" active={cfg.singles} onPress={() => setCfg(p => ({ ...p, singles: true }))} />
      </Row>
      <Row label="主隊偶數右">
        <Chip text="#1 在右" active={cfg.homeRight === 0} onPress={() => setCfg(p => ({ ...p, homeRight: 0 }))} />
        <Chip text="#2 在右" active={cfg.homeRight === 1} onPress={() => setCfg(p => ({ ...p, homeRight: 1 }))} />
      </Row>
      <Row label="客隊偶數右">
        <Chip text="#1 在右" active={cfg.awayRight === 0} onPress={() => setCfg(p => ({ ...p, awayRight: 0 }))} />
        <Chip text="#2 在右" active={cfg.awayRight === 1} onPress={() => setCfg(p => ({ ...p, awayRight: 1 }))} />
      </Row>
      <Row label="開局發球">
        <Chip text="主隊" active={cfg.startingTeam === 0} onPress={() => setCfg(p => ({ ...p, startingTeam: 0 }))} />
        <Chip text="客隊" active={cfg.startingTeam === 1} onPress={() => setCfg(p => ({ ...p, startingTeam: 1 }))} />
      </Row>
      {!cfg.singles && (
        <Row label="發球人">
          <Chip text="#1" active={cfg.startingIndex === 0} onPress={() => setCfg(p => ({ ...p, startingIndex: 0 }))} />
          <Chip text="#2" active={cfg.startingIndex === 1} onPress={() => setCfg(p => ({ ...p, startingIndex: 1 }))} />
        </Row>
      )}
    </Card>

    <Card title="球員（可從球友帶入）">
      <Text style={{ color: '#90caf9', marginBottom: 4 }}>主隊</Text>
      <PlayerInput label="#1" value={cfg.home[0].name} onChange={(v: string) => setPlayer('home', 0, v)} onPick={() => openPick('home', 0)} />
      {!cfg.singles && (
        <PlayerInput label="#2" value={cfg.home[1].name} onChange={(v: string) => setPlayer('home', 1, v)} onPick={() => openPick('home', 1)} />
      )}

      <Text style={{ color: '#ef9a9a', marginTop: 12, marginBottom: 4 }}>客隊</Text>
      <PlayerInput label="#1" value={cfg.away[0].name} onChange={(v: string) => setPlayer('away', 0, v)} onPick={() => openPick('away', 0)} />
      {!cfg.singles && (
        <PlayerInput label="#2" value={cfg.away[1].name} onChange={(v: string) => setPlayer('away', 1, v)} onPick={() => openPick('away', 1)} />
      )}
    </Card>

    <View style={{ flexDirection: 'row', marginTop: 12 }}>
      <Pressable
        onPress={startBoard}
        style={{ flex: 1, backgroundColor: '#2e7d32', paddingVertical: 12, borderRadius: 10, alignItems: 'center', marginRight: 8 }}
      >
        <Text style={{ color: '#fff', fontWeight: '800' }}>開始</Text>
      </Pressable>
      <Pressable
        onPress={() => {
          setCfg(DEFAULT_CFG);
          AsyncStorage.removeItem(STORE_KEY).catch(() => {});
        }}
        style={{ width: 120, backgroundColor: C.gray, paddingVertical: 12, borderRadius: 10, alignItems: 'center' }}
      >
        <Text style={{ color: '#fff' }}>重置</Text>
      </Pressable>
    </View>

    {/* 球友挑選 */}
    <Modal visible={picker.open} transparent animationType="slide" onRequestClose={() => setPicker({ open: false, q: '' })}>
      <View style={{ flex: 1, backgroundColor: 'rgba(0,0,0,0.45)', justifyContent: 'flex-end' }}>
        <View style={{ backgroundColor: '#1e1e1e', borderTopLeftRadius: 16, borderTopRightRadius: 16, padding: 12, maxHeight: '70%' }}>
          <Text style={{ color: '#fff', fontWeight: '700', marginBottom: 8 }}>從球友帶入</Text>
          <RNTextInput
            value={picker.q}
            onChangeText={(t: string) => setPicker(p => ({ ...p, q: t }))}
            placeholder="搜尋球友"
            placeholderTextColor="#888"
            style={{
              borderWidth: 1,
              borderColor: '#444',
              borderRadius: 8,
              paddingHorizontal: 10,
              paddingVertical: 8,
              color: '#fff',
              backgroundColor: '#111',
              marginBottom: 8,
            }}
          />
          <FlatList
            data={buddies.filter(b => (picker.q ? b.name.toLowerCase().includes(picker.q.toLowerCase()) : true))}
            keyExtractor={(i: { id: string }) => i.id}
            renderItem={({ item }: { item: { id: string; name: string } }) => (
              <Pressable onPress={() => applyPick(item.name)} style={{ paddingVertical: 10, borderBottomWidth: 1, borderColor: '#333' }}>
                <Text style={{ color: '#fff' }}>{item.name}</Text>
              </Pressable>
            )}
            ListEmptyComponent={
              <Text style={{ color: '#888', paddingVertical: 8 }}>
                尚未找到球友（需在某社團為 owner 並在該社團建立球友名單）
              </Text>
            }
            style={{ maxHeight: '70%' }}
          />
          <Pressable onPress={() => setPicker({ open: false, q: '' })} style={{ alignSelf: 'flex-end', paddingVertical: 8, paddingHorizontal: 12 }}>
            <Text style={{ color: '#90caf9' }}>關閉</Text>
          </Pressable>
        </View>
      </View>
    </Modal>
  </ScrollView>
</KeyboardAvoidingView>
);
}

// -------------------- 小組件 --------------------
function Card({ title, children }: { title: string; children: any }) {
return (
<View style={{ padding: 10, backgroundColor: C.card, borderRadius: 12, borderWidth: 1, borderColor: C.border, marginBottom: 10 }}>
<Text style={{ color: C.text, fontWeight: '700', marginBottom: 6 }}>{title}</Text>
{children}
</View>
);
}
function Row({ label, children }: { label: string; children: any }) {
return (
<View style={{ marginBottom: 8 }}>
<Text style={{ color: '#bbb', marginBottom: 6 }}>{label}</Text>
<View style={{ flexDirection: 'row', flexWrap: 'wrap' }}>{children}</View>
</View>
);
}
function Chip({ text, active, onPress }: { text: string; active?: boolean; onPress: () => void }) {
return (
<Pressable
onPress={onPress}
style={{
paddingVertical: 6,
paddingHorizontal: 10,
borderRadius: 14,
borderWidth: 1,
borderColor: active ? C.chip : '#555',
backgroundColor: active ? 'rgba(144,202,249,0.15)' : C.card,
marginRight: 8,
marginBottom: 8,
}}
>
<Text style={{ color: '#fff' }}>{text}</Text>
</Pressable>
);
}
function PlayerInput({ label, value, onChange, onPick }: { label: string; value: string; onChange: (s: string) => void; onPick: () => void }) {
return (
<View style={{ marginBottom: 6, flexDirection: 'row', alignItems: 'center' }}>
<Text style={{ color: '#bbb', width: 28 }}>{label}</Text>
<TextInput
value={value}
onChangeText={onChange}
placeholder="球員名字"
placeholderTextColor="#888"
style={{ flex: 1, borderWidth: 1, borderColor: '#444', borderRadius: 8, paddingHorizontal: 10, paddingVertical: 8, color: '#fff', backgroundColor: '#111' }}
returnKeyType="done"
/>
<Pressable onPress={onPick} style={{ marginLeft: 8, paddingVertical: 8, paddingHorizontal: 10, borderRadius: 8, borderWidth: 1, borderColor: '#555' }}>
<Text style={{ color: '#90caf9' }}>帶入</Text>
</Pressable>
</View>
);
}
function Seat({
label,
name,
highlightSrv,
highlightRcv,
style,
}: {
label: '右' | '左';
name: string;
highlightSrv?: boolean;
highlightRcv?: boolean;
style?: any;
}) {
const ring = highlightSrv ? '#ffd54f' : highlightRcv ? '#80deea' : '#ddd';
return (
<View
style={[
{
minWidth: 120,
paddingVertical: 6,
paddingHorizontal: 10,
borderRadius: 8,
borderWidth: 1,
borderColor: ring,
backgroundColor: 'rgba(0,0,0,0.25)',
alignItems: 'center',
justifyContent: 'center',
minHeight: 44,
overflow: 'hidden',
},
style,
]}
>
<Text
style={{ color: '#fff', fontWeight: '700', textAlign: 'center' }}
numberOfLines={1}
ellipsizeMode="clip"
>
{`${label}：${name || '-'}`}
</Text>
<Text
style={{ color: ring, marginTop: 2, fontSize: 12, textAlign: 'center' }}
numberOfLines={1}
ellipsizeMode="clip"
>
{highlightSrv ? '發球位' : highlightRcv ? '接球位' : ' '}
</Text>
</View>
);
}ezbmt-tracked/src/screens/HomeScreen.tsx
 
import React from 'react';
import { View, Text, Pressable, ScrollView, Image, Platform } from 'react-native';
import { useFocusEffect, useNavigation } from '@react-navigation/native';
import { supa } from '../lib/supabase';

const ACTION_IMG = require('../images/action.png');

const C = {
bg: '#111',
card: '#1e1e1e',
border: '#333',
text: '#fff',
sub: '#bbb',
primary: '#1976d2',
accent: '#009688',
warn: '#d32f2f',
gray: '#616161',
dark: '#000000',
Setting: '#455a64',
};

export default function HomeScreen() {
const navigation = useNavigation<any>();
const [isAdmin, setIsAdmin] = React.useState<boolean>(false);

useFocusEffect(
React.useCallback(() => {
let active = true;
(async () => {
try {
const { data } = await supa.auth.getUser();
if (active && !data?.user) {
navigation.replace('Auth');
return;
}
} catch {
if (active) {
navigation.replace('Auth');
return;
}
}
try {
const { data, error } = await supa.rpc('is_app_admin');
if (active) setIsAdmin(!error && !!data);
} catch {
if (active) setIsAdmin(false);
}
})();
return () => { active = false; };
}, [navigation])
);

const Button = ({ title, color, onPress }: { title: string; color: string; onPress: () => void }) => (
<Pressable
onPress={onPress}
style={{
backgroundColor: color,
borderRadius: 14,
paddingVertical: 16,
paddingHorizontal: 20,
marginBottom: 14,
alignItems: 'center',
}}
>
<Text style={{ color: '#fff', fontSize: 16, fontWeight: '700', letterSpacing: 0.5 }}>{title}</Text>
</Pressable>
);

return (
<View style={{ flex: 1, backgroundColor: C.bg }}>
<ScrollView contentContainerStyle={{ flexGrow: 1, padding: 16, justifyContent: 'center' }}>
{/* 標題 */}
<View style={{ alignItems: 'center', marginBottom: 16 }}>
<Text style={{ color: C.text, fontSize: 20, fontWeight: '800', textAlign: 'center', marginBottom: 12 }}>
LBF能力有限羽球分析平台ezbmt
</Text>
{/* 新增：插入 action.png */}
<Image
source={ACTION_IMG}
resizeMode="contain"
style={{ width: '86%', height: 90 }}
/>
</View>

    <View style={{ maxWidth: 480, alignSelf: 'center', width: '100%' }}>
      <Button title="賽事管理" color={C.primary} onPress={() => navigation.navigate('Events')} />
      <Button title="社團管理" color={C.accent} onPress={() => navigation.navigate('Clubs')} />
      <Button title="個人設定" color={C.gray} onPress={() => navigation.navigate('Profile')} />
      <Button title="快速計分板" color="#6a1b9a" onPress={() => navigation.navigate('QuickScoreboard')} />

      {/* 僅最大管理者顯示管理項目 */}
{isAdmin && (
<>
<Button title="社群管理" color="#c2185b" onPress={() => navigation.navigate('AdminModeration')} />
<Button title="TEST" color="#0288d1" onPress={() => navigation.navigate('WebCam')} />
<Button title="測速" color={C.dark} onPress={() => navigation.navigate('SpeedCam')} />
<Button title="基本設定" color={C.Setting} onPress={() => navigation.navigate('Settings')} />
</>
)}

      <Button
        title="登出"
        color={C.warn}
        onPress={async () => {
          try { await supa.auth.signOut(); } catch {}
          navigation.replace('Auth');
        }}
      />
    </View>
  </ScrollView>
</View>
);
}ezbmt-tracked/src/screens/ClubStatsScreen.tsx
 
import React from 'react';
import { View, Text, ScrollView, TextInput, Pressable, ActivityIndicator, Alert } from 'react-native';
import { useRoute } from '@react-navigation/native';
import { listSessionsOfMe, listSessionAttendees, listRounds } from '../db';
import type { SessionRow, Attendee } from '../db/supa_club';
import SimpleBarChart, { BarRow } from '../components/SimpleBarChart';

const C = { bg:'#111', card:'#1e1e1e', border:'#333', text:'#fff', sub:'#bbb', good:'#90caf9', bad:'#ef9a9a' };

type RoundLite = { index_no: number; matches: Array<{ team_a:any; team_b:any }> };

export default function ClubStatsScreen() {
const route = useRoute<any>();
// 可選: clubId (目前 RLS 以 created_by 為主，此參數先保留不使用)
const clubId: string | undefined = route.params?.clubId;

const [loading, setLoading] = React.useState(true);

const [fromDate, setFromDate] = React.useState<string>(dateNdaysAgo(30)); // YYYY-MM-DD
const [toDate, setToDate] = React.useState<string>(dateNdaysAgo(0));

// 聚合結果
const [sessionsCount, setSessionsCount] = React.useState(0);
const [attendeesTotal, setAttendeesTotal] = React.useState(0);
const [utilizationPct, setUtilizationPct] = React.useState<number>(0);
const [commonPairs, setCommonPairs] = React.useState<BarRow[]>([]);
const [commonOpponents, setCommonOpponents] = React.useState<BarRow[]>([]);
const [levelDist, setLevelDist] = React.useState<BarRow[]>([]);

const [busy, setBusy] = React.useState(false);

React.useEffect(() => { run(); }, []);

async function run() {
setLoading(true);
try {
await computeStats(fromDate, toDate);
} catch (e:any) {
Alert.alert('載入失敗', String(e?.message || e));
} finally {
setLoading(false);
}
}

async function computeStats(from: string, to: string) {
setBusy(true);
try {
const sessions = await listSessionsOfMe(); // 先拿最多 200 筆
// 範圍過濾（以 session.date）
const ss = sessions.filter(s => inRange(s.date, from, to));

  setSessionsCount(ss.length);

  const attendeesBySession: Map<string, Attendee[]> = new Map();
  const roundsBySession: Map<string, RoundLite[]> = new Map();

  for (const s of ss) {
    try {
      const [atts, rs] = await Promise.all([
        listSessionAttendees(s.id),
        listRounds(s.id),
      ]);
      attendeesBySession.set(s.id, atts || []);
      roundsBySession.set(
        s.id,
        (rs || []).map((r: any) => ({ index_no: Number(r.index_no || 0), matches: (r.matches || []) as any[] }))
      );
    } catch {
      attendeesBySession.set(s.id, []);
      roundsBySession.set(s.id, []);
    }
  }

  // 出席總人次（總報到數）
  const totalAtt = Array.from(attendeesBySession.values()).reduce((a, arr) => a + arr.length, 0);
  setAttendeesTotal(totalAtt);

  // 利用率估算
  let usedCourtSlots = 0;
  let totalCourtSlots = 0;
  for (const s of ss) {
    const rrs = roundsBySession.get(s.id) || [];
    const roundsCount = rrs.length;
    if (roundsCount > 0) {
      const used = rrs.reduce((acc, r) => acc + ((r.matches || []).length), 0);
      usedCourtSlots += used;
      totalCourtSlots += roundsCount * Math.max(1, Number(s.courts || 1));
    }
  }
  const util = totalCourtSlots > 0 ? Math.round((usedCourtSlots / totalCourtSlots) * 1000) / 10 : 0;
  setUtilizationPct(util);

  // 常見搭檔
  const pairCount = new Map<string, number>(); // "idA|idB"
  const nameMap = new Map<string, string>();
  for (const rounds of roundsBySession.values()) {
    for (const r of rounds) {
      for (const m of r.matches || []) {
        const A = (m.team_a?.players || []) as Array<{id:string; name:string;}>;
        const B = (m.team_b?.players || []) as Array<{id:string; name:string;}>;
        A.forEach(p => nameMap.set(p.id, p.name));
        B.forEach(p => nameMap.set(p.id, p.name));
        for (let i=0;i<A.length;i++) for (let j=i+1;j<A.length;j++) inc(pairCount, key2(A[i].id, A[j].id));
        for (let i=0;i<B.length;i++) for (let j=i+1;j<B.length;j++) inc(pairCount, key2(B[i].id, B[j].id));
      }
    }
  }
  const pairsBar = topNMap(pairCount, 12).map(([k, c]: [string, number]) => {
    const [a, b] = k.split('|');
    const label = `${nameMap.get(a) || a} + ${nameMap.get(b) || b}`;
    return { label, win: c, loss: 0 } as BarRow;
  });
  setCommonPairs(pairsBar);

  // 常見對手
  const oppCount = new Map<string, number>(); // "pairKeyA|pairKeyB"
  for (const rounds of roundsBySession.values()) {
    for (const r of rounds) {
      for (const m of r.matches || []) {
        const A = (m.team_a?.players || []) as Array<{id:string; name:string;}>;
        const B = (m.team_b?.players || []) as Array<{id:string; name:string;}>;
        const pkA = pairKey(A.map(p => p.id));
        const pkB = pairKey(B.map(p => p.id));
        if (pkA && pkB) inc(oppCount, duoKey(pkA, pkB));
      }
    }
  }
  const oppBar = topNMap(oppCount, 12).map(([k, c]: [string, number]) => {
    const [x, y] = k.split('|');
    const aIds = x.split('&');
    const bIds = y.split('&');
    const aLabel = aIds.map((id: string) => nameMap.get(id) || id).join(' + ');
    const bLabel = bIds.map((id: string) => nameMap.get(id) || id).join(' + ');
    return { label: `${aLabel}  vs  ${bLabel}`, win: c, loss: 0 } as BarRow;
  });
  setCommonOpponents(oppBar);

  // 等級分布
  const levelMap = new Map<number, number>();
  for (const arr of attendeesBySession.values()) {
    for (const a of arr) {
      const lv = Number(a.level || 0);
      if (!Number.isFinite(lv) || lv <= 0) continue;
      levelMap.set(lv, (levelMap.get(lv) || 0) + 1);
    }
  }
  const lvRows: BarRow[] = Array.from(levelMap.entries())
    .sort((a, b) => a[0] - b[0])
    .map(([lv, cnt]) => ({ label: `L${lv}`, win: cnt, loss: 0 }));
  setLevelDist(lvRows);
} finally {
  setBusy(false);
}
}

const onQuickRange = async (days: number) => {
const f = dateNdaysAgo(days);
const t = dateNdaysAgo(0);
setFromDate(f); setToDate(t);
await computeStats(f, t);
};

return (
<ScrollView style={{ flex:1, backgroundColor: C.bg }} contentContainerStyle={{ padding: 12 }}>
<Text style={{ color:C.text, fontSize:16, fontWeight:'800', marginBottom: 10 }}>社團統計</Text>

  {/* 篩選區：日期篩選 */}
  <View style={{ backgroundColor:C.card, borderWidth:1, borderColor:C.border, borderRadius:10, padding:10, marginBottom:12 }}>
    <Text style={{ color:C.text, fontWeight:'700', marginBottom:6 }}>篩選</Text>
    <View style={{ flexDirection:'row', alignItems:'center', marginBottom:8 }}>
      <Field label="從" value={fromDate} onChange={setFromDate} />
      <View style={{ width: 8 }} />
      <Field label="到" value={toDate} onChange={setToDate} />
      <View style={{ width: 8 }} />
      <Pressable onPress={()=>computeStats(fromDate, toDate)} disabled={busy}
        style={{ paddingVertical:8, paddingHorizontal:12, backgroundColor:busy?'#555':'#1976d2', borderRadius:8 }}>
        <Text style={{ color:'#fff', fontWeight:'700' }}>{busy?'計算中…':'套用'}</Text>
      </Pressable>
    </View>
    <View style={{ flexDirection:'row' }}>
      <Chip text="最近 7 天" onPress={()=>onQuickRange(7)} />
      <Chip text="最近 30 天" onPress={()=>onQuickRange(30)} />
      <Chip text="最近 90 天" onPress={()=>onQuickRange(90)} />
    </View>
  </View>

  {/* 概況 */}
  <View style={{ flexDirection:'row', flexWrap:'wrap', justifyContent:'space-between' }}>
    <StatCard title="場次數" value={String(sessionsCount)} />
    <StatCard title="總出席人次" value={String(attendeesTotal)} />
    <StatCard title="場地利用率(%)" value={String(utilizationPct)} />
  </View>

  {/* 常見搭檔 */}
  <Section title="常見搭檔（Top 12）">
    {commonPairs.length ? <SimpleBarChart data={commonPairs} maxItems={12} /> : <EmptyTip />}
  </Section>

  {/* 常見對手 */}
  <Section title="常見對手（Top 12）">
    {commonOpponents.length ? <SimpleBarChart data={commonOpponents} maxItems={12} /> : <EmptyTip />}
  </Section>

  {/* 等級分布 */}
  <Section title="等級分布">
    {levelDist.length ? <SimpleBarChart data={levelDist} maxItems={50} /> : <EmptyTip />}
  </Section>

  {loading && (
    <View style={{ padding: 20, alignItems:'center' }}>
      <ActivityIndicator color="#90caf9" />
    </View>
  )}
</ScrollView>
);
}

function Field({ label, value, onChange }: { label:string; value:string; onChange:(v:string)=>void }) {
return (
<View>
<Text style={{ color:'#bbb', marginBottom:4 }}>{label}</Text>
<TextInput
value={value}
onChangeText={onChange}
placeholder="YYYY-MM-DD"
placeholderTextColor="#888"
style={{ width: 130, height: 36, borderWidth:1, borderColor:'#444', color:'#fff', backgroundColor:'#111', borderRadius:8, paddingHorizontal:8 }}
/>
</View>
);
}
function StatCard({ title, value }: { title:string; value:string }) {
return (
<View style={{ width:'32%', minWidth: 200, padding:12, backgroundColor:C.card, borderWidth:1, borderColor:C.border, borderRadius:10, marginBottom:10 }}>
<Text style={{ color:'#bbb', marginBottom:6 }}>{title}</Text>
<Text style={{ color:'#fff', fontSize:24, fontWeight:'800' }}>{value}</Text>
</View>
);
}
function Section({ title, children }: any) {
return (
<View style={{ marginTop: 12, backgroundColor:C.card, borderWidth:1, borderColor:C.border, borderRadius:10, padding:10 }}>
<Text style={{ color:'#fff', fontWeight:'700', marginBottom:8 }}>{title}</Text>
{children}
</View>
);
}
function Chip({ text, onPress }: { text:string; onPress:()=>void }) {
return (
<Pressable onPress={onPress} style={{ paddingVertical:6, paddingHorizontal:10, borderRadius:14, borderWidth:1, borderColor:'#444', backgroundColor:'#222', marginRight:8 }}>
<Text style={{ color:'#ccc' }}>{text}</Text>
</Pressable>
);
}
function EmptyTip() {
return <Text style={{ color:'#888' }}>尚無資料</Text>;
}

/* 小工具 */
function dateNdaysAgo(n: number) {
const d = new Date();
d.setDate(d.getDate() - n);
return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
}
function pad(n: number) { return n<10 ? `0${n}` : String(n); }
function inRange(dateStr: string, from: string, to: string) {
return dateStr >= from && dateStr <= to;
}
function inc(map: Map<string, number>, k: string) {
map.set(k, (map.get(k)||0) + 1);
}
function key2(a: string, b: string) {
return a < b ? `${a}|${b}` : `${b}|${a}`;
}
function pairKey(ids: string[]) {
const sorted = [...ids].sort();
return sorted.join('&');
}
function duoKey(a: string, b: string) {
return a < b ? `${a}|${b}` : `${b}|${a}`;
}
function topNMap<K>(m: Map<K, number>, n: number): Array<[K, number]> {
const arr: Array<[K, number]> = Array.from(m.entries());
arr.sort((a, b) => b[1] - a[1]); // 由大到小
return arr.slice(0, Math.max(0, n | 0));
}ezbmt-tracked/src/screens/ClubScoreboardScreen.tsx
 
import React from 'react';
import { View, Text, Pressable, Alert } from 'react-native';
import { useRoute } from '@react-navigation/native';
import { getRoundCourtTeams, getRoundResultState, getMyClubRole, upsertRoundResultOutcome } from '../db';
import { createMatch, getUiSnapshot, nextRally, serialize, deserialize, MatchState, isMatchOver } from '../logic/serve';
import { supa } from '../lib/supabase';

const C = { bg:'#111', card:'#1e1e1e', text:'#fff', btnA:'#1976d2', btnB:'#d32f2f', border:'#333', sub:'#bbb', gray:'#616161' };

export default function ClubScoreboardScreen() {
  const route = useRoute<any>();
  const roundId = route.params?.roundId as string;
  const courtNo = route.params?.courtNo as number;
  const courtsTotal = Number(route.params?.courts || 0) || 0;

  const [teams, setTeams] = React.useState<{ A: [string, string], B: [string, string] }>({ A: ['A0','A1'], B: ['B0','B1'] });
  const [state, setState] = React.useState<MatchState | null>(null);
  const [snap, setSnap] = React.useState<any>(null);

  const [pointsToWin, setPointsToWin] = React.useState<number>(21);
  const [bestOf, setBestOf] = React.useState<number>(1);
  const [deuce, setDeuce] = React.useState<boolean>(true);

  const [myRole, setMyRole] = React.useState<string | null>(null);
  const canScore = ['owner','admin','scorer'].includes(String(myRole || ''));

  // 追加：保留 sessionId 用於通知
  const [sessionIdOfRound, setSessionIdOfRound] = React.useState<string | null>(null);

  React.useEffect(() => {
    (async () => {
      try {
        const t = await getRoundCourtTeams({ roundId, courtNo });
        setTeams(t);

        // 角色：round -> session -> club -> role
        try {
          const { data: rr } = await supa.from('session_rounds').select('session_id').eq('id', roundId).maybeSingle();
          const sid = rr?.session_id;
          if (sid) {
            setSessionIdOfRound(String(sid));
            const { data: ss } = await supa.from('sessions').select('club_id').eq('id', sid).maybeSingle();
            const clubId = ss?.club_id;
            if (clubId) setMyRole(await getMyClubRole(String(clubId)) as any);
          }
        } catch { setMyRole(null); }

        const saved = await getRoundResultState({ roundId, courtNo });
        let s: MatchState | null = null;
        if (saved?.state_json) {
          try { s = deserialize(saved.state_json); } catch { s = null; }
        }
        if (!s) {
          s = createMatch({
            teams: [
              { players: [{ id:'A0', name: t.A[0] }, { id:'A1', name: t.A[1] }], startRightIndex: 0 },
              { players: [{ id:'B0', name: t.B[0] }, { id:'B1', name: t.B[1] }], startRightIndex: 0 },
            ],
            rules: { bestOf: 1, pointsToWin: 21, winBy: 2, cap: 30 },
            startingServerTeam: 0,
            startingServerPlayerIndex: 0,
            metadata: { category:'MD' },
          });
        }

        const r = s.rules || { bestOf: 1, pointsToWin: 21, winBy: 2 };
        setPointsToWin(Number(r.pointsToWin || 21));
        setBestOf(Number(r.bestOf || 1));
        setDeuce((r.winBy ?? 2) > 1);

        setState(s);
        setSnap(getUiSnapshot(s));
      } catch (e:any) {
        Alert.alert('載入失敗', String(e?.message||e));
      }
    })();
  }, [roundId, courtNo]);

  const saveState = React.useCallback(async (s: MatchState) => {
    setState(s);
    const ui = getUiSnapshot(s);
    setSnap(ui);
    // 持續回寫 serve_state_json（勝負在 finish 時再寫）
    await upsertRoundResultOutcome({
      roundId, courtNo,
      serveStateJson: serialize(s),
    });
  }, [roundId, courtNo]);

  const score = async (winner: 0|1) => {
    if (!canScore) { Alert.alert('沒有權限','僅 owner/admin/scorer 可記分'); return; }
    try {
      if (!state) return;
      const next = nextRally({ ...state }, winner);
      await saveState(next);
    } catch (e:any) {
      Alert.alert('記分失敗', String(e?.message||e));
    }
  };

  const applyRules = async (patch: Partial<MatchState['rules']>) => {
    if (!canScore) { Alert.alert('沒有權限','僅 owner/admin/scorer 可調整規則'); return; }
    try {
      if (!state) return;
      const r = { ...state.rules, ...patch };
      if (patch.pointsToWin != null) setPointsToWin(Number(patch.pointsToWin));
      if (patch.bestOf != null) setBestOf(Number(patch.bestOf));
      if (patch.winBy != null) setDeuce(Number(patch.winBy) > 1);
      await saveState({ ...state, rules: r });
    } catch (e:any) {
      Alert.alert('套用失敗', String(e?.message||e));
    }
  };

  const finishMatch = async () => {
    if (!canScore) { Alert.alert('沒有權限','僅 owner/admin/scorer 可結束比賽'); return; }
    try {
      if (!state) { Alert.alert('提示','尚未載入比賽'); return; }

      // 最終比分與勝方
      const ui = getUiSnapshot(state);
      const scoreHome = Number(ui?.scoreA || 0);
      const scoreAway = Number(ui?.scoreB || 0);

      // 一般情況以 games 贏局數決定；若未滿足 bestOf 就以現在比分較高者
      const wonA = (state.games||[]).filter(g=>g?.winner===0).length;
      const wonB = (state.games||[]).filter(g=>g?.winner===1).length;
      const need = Math.floor((state.rules?.bestOf||1)/2)+1;
      const winnerTeam = (wonA>=need || wonB>=need) ? (wonA>wonB ? 0 : 1) : (scoreHome===scoreAway ? null : (scoreHome>scoreAway ? 0 : 1));

      // upsert 結果（包含 serve_state_json）
      await upsertRoundResultOutcome({
        roundId, courtNo,
        serveStateJson: serialize(state),
        scoreHome, scoreAway,
        winnerTeam,
        finishedAt: new Date().toISOString(),
      });

      // 試著把此輪設為 finished：優先看 finished_at，其次 serve_state_json
      if (courtsTotal > 0) {
        try {
          const { count: c1 } = await supa
            .from('round_results')
            .select('court_no', { count: 'exact', head: true })
            .eq('round_id', roundId)
            .not('finished_at', 'is', null);
          let done = Number(c1 || 0);
          if (done < courtsTotal) {
            const { count: c2 } = await supa
              .from('round_results')
              .select('court_no', { count: 'exact', head: true })
              .eq('round_id', roundId)
              .not('serve_state_json', 'is', null);
            done = Math.max(done, Number(c2 || 0));
          }
          if (done >= courtsTotal) {
            await supa.from('session_rounds').update({ status: 'finished' }).eq('id', roundId);
          }
        } catch {}
      }

      // 新增：通知（追蹤該 session 的使用者）
      try {
        if (sessionIdOfRound) {
          await supa.functions.invoke('send_notify', {
            body: {
              kind: 'event',
              targetId: sessionIdOfRound,
              title: `場地 ${courtNo} 已結束`,
              body: `比分 ${scoreHome}:${scoreAway}（${winnerTeam===0 ? '主勝' : winnerTeam===1 ? '客勝' : '未定'}）`,
              data: { sessionId: sessionIdOfRound, roundId, courtNo: String(courtNo) },
            },
          });
        }
      } catch {}

      Alert.alert('已結束', '本場比賽結果已記錄');
    } catch (e:any) {
      Alert.alert('結束失敗', String(e?.message || e));
    }
  };

  if (!state || !snap) {
    return (
      <View style={{ flex:1, backgroundColor:C.bg, alignItems:'center', justifyContent:'center' }}>
        <Text style={{ color:C.sub }}>載入中…</Text>
      </View>
    );
  }

  const scoreA = snap?.scoreA ?? 0;
  const scoreB = snap?.scoreB ?? 0;

  return (
    <View style={{ flex:1, backgroundColor:C.bg, padding:12 }}>
      <Text style={{ color:C.text, fontSize:16, fontWeight:'700', marginBottom:8 }}>{`第 ${courtNo} 場地 計分板`}</Text>

      <View style={{ padding:10, borderWidth:1, borderColor:C.border, backgroundColor:C.card, borderRadius:12, marginBottom:10, opacity: canScore?1:0.8 }}>
        <Text style={{ color:C.sub, marginBottom:6 }}>{`規則（目前：到 ${pointsToWin} 分 · ${bestOf}局制 · ${deuce ? 'Deuce開' : 'Deuce關'}）`}</Text>
        <View style={{ flexDirection:'row', flexWrap:'wrap', marginBottom:6 }}>
          <Chip text="P11" active={pointsToWin===11} onPress={() => applyRules({ pointsToWin: 11 })} />
          <Chip text="P15" active={pointsToWin===15} onPress={() => applyRules({ pointsToWin: 15 })} />
          <Chip text="P21" active={pointsToWin===21} onPress={() => applyRules({ pointsToWin: 21 })} />
          <Chip text="P25" active={pointsToWin===25} onPress={() => applyRules({ pointsToWin: 25 })} />
          <Chip text="P31" active={pointsToWin===31} onPress={() => applyRules({ pointsToWin: 31 })} />
        </View>
        <View style={{ flexDirection:'row', flexWrap:'wrap', marginBottom:6 }}>
          <Chip text="BO1" active={bestOf===1} onPress={() => applyRules({ bestOf: 1 })} />
          <Chip text="BO3" active={bestOf===3} onPress={() => applyRules({ bestOf: 3 })} />
        </View>
        <View style={{ flexDirection:'row', flexWrap:'wrap' }}>
          <Chip text={deuce ? 'Deuce 開' : 'Deuce 關'} active={deuce} onPress={() => applyRules({ winBy: deuce ? 1 : 2 })} />
        </View>
      </View>

      <View style={{ padding:12, borderWidth:1, borderColor:C.border, backgroundColor:C.card, borderRadius:12 }}>
        <View style={{ flexDirection:'row', justifyContent:'space-between', alignItems:'center' }}>
          <View style={{ flex:1, alignItems:'center' }}>
            <Text style={{ color:'#90caf9', fontSize:18, fontWeight:'700' }}>{`${teams.A[0]} / ${teams.A[1]}`}</Text>
          </View>
          <View style={{ width: 100, alignItems:'center' }}>
            <Text style={{ color:'#fff', fontSize:28, fontWeight:'800' }}>{scoreA}</Text>
            <Text style={{ color:C.sub }}>VS</Text>
            <Text style={{ color:'#fff', fontSize:28, fontWeight:'800' }}>{scoreB}</Text>
          </View>
          <View style={{ flex:1, alignItems:'center' }}>
            <Text style={{ color:'#ef9a9a', fontSize:18, fontWeight:'700' }}>{`${teams.B[0]} / ${teams.B[1]}`}</Text>
          </View>
        </View>

        <View style={{ flexDirection:'row', marginTop:16 }}>
          <Pressable onPress={()=>score(0)} disabled={!canScore} style={{ flex:1, backgroundColor:canScore?C.btnA:'#555', paddingVertical:12, borderRadius:10, marginRight:8, alignItems:'center' }}>
            <Text style={{ color:'#fff', fontSize:16, fontWeight:'700' }}>主隊得分</Text>
          </Pressable>
          <Pressable onPress={()=>score(1)} disabled={!canScore} style={{ flex:1, backgroundColor:canScore?C.btnB:'#555', paddingVertical:12, borderRadius:10, marginLeft:8, alignItems:'center' }}>
            <Text style={{ color:'#fff', fontSize:16, fontWeight:'700' }}>客隊得分</Text>
          </Pressable>
        </View>

        <View style={{ flexDirection:'row', marginTop:12, justifyContent:'flex-end' }}>
          <Pressable onPress={finishMatch} disabled={!canScore} style={{ paddingVertical:8, paddingHorizontal:12, backgroundColor:canScore?'#5d4037':'#555', borderRadius:10 }}>
            <Text style={{ color:'#fff', fontWeight:'700' }}>結束比賽</Text>
          </Pressable>
        </View>

        <Text style={{ color:C.sub, marginTop:10 }}>
          {`發球方：${(snap?.servingTeam ?? 0) === 0 ? '主隊' : '客隊'}`}
          {isMatchOver(state) ? '（比賽已可結束）' : ''}
        </Text>
      </View>
    </View>
  );
}

function Chip({ text, active, onPress }: { text:string; active?:boolean; onPress:()=>void }) {
  return (
    <Pressable
      onPress={onPress}
      style={{
        paddingVertical:6, paddingHorizontal:10, borderRadius:14,
        borderWidth:1, borderColor: active ? '#90caf9' : '#555',
        backgroundColor: active ? 'rgba(144,202,249,0.15)' : '#1f1f1f',
        marginRight:8, marginBottom:8
      }}
    >
      <Text style={{ color:'#fff' }}>{text}</Text>
    </Pressable>
  );
}ezbmt-tracked/src/screens/MatchMembersScreen.tsx
 
import React from 'react';
import { View, Text, FlatList, Pressable, Alert, ScrollView } from 'react-native';
import { useRoute, useNavigation } from '@react-navigation/native';
import {
listMatchMembers,
upsertMatchMember,
deleteMatchMember,
listEventMembersBasic,
getMatch,
getMyEventRole,
importEventMembersToMatch,
} from '../db';

type MemberRole = 'owner'|'coach'|'recorder'|'player'|'viewer';

const ROLES: Array<{ key: MemberRole; label: string }> = [
{ key: 'coach',    label: '教練' },
{ key: 'recorder', label: '記錄' },
{ key: 'player',   label: '選手' },
{ key: 'viewer',   label: '觀看' },
];

const C = {
bg: '#111',
card: '#222',
border: '#333',
text: '#fff',
sub: '#bbb',
chipOn: '#90caf9',
chipOff: '#555',
};

export default function MatchMembersScreen() {
const route = useRoute<any>();
const navigation = useNavigation<any>();

// 允許 undefined，避免把 "undefined" 傳入 RPC/SQL
const matchId: string | undefined = route.params?.matchId;

const [eventId, setEventId] = React.useState<string>('');
const [mine, setMine] = React.useState<MemberRole|null>(null);
const [members, setMembers] = React.useState<Array<{ id:string; user_id:string; role:MemberRole; name:string }>>([]);
const [candidates, setCandidates] = React.useState<Array<{ user_id:string; name:string }>>([]);
const [eventMemberCount, setEventMemberCount] = React.useState<number>(0);

const canManage = mine === 'owner' || mine === 'coach' || mine === 'recorder';

// 若缺少 matchId，顯示安全畫面並禁止任何 RPC
if (!matchId) {
return (
<View style={{ flex:1, backgroundColor: C.bg, alignItems:'center', justifyContent:'center', padding:16 }}>
<Text style={{ color:'#fff', fontSize:16, marginBottom:8 }}>未提供場次 ID，無法載入成員</Text>
<Pressable onPress={() => navigation.goBack()} style={{ paddingVertical:8, paddingHorizontal:12, backgroundColor:'#455a64', borderRadius:8 }}>
<Text style={{ color:'#fff' }}>返回</Text>
</Pressable>
</View>
);
}

const load = React.useCallback(async () => {
try {
// 必須有 matchId 才能查
const m = await getMatch(matchId);
const eid = m?.event_id as string;
setEventId(eid);

  const [myRole, mm, evMembers] = await Promise.all([
    getMyEventRole(eid),
    listMatchMembers(matchId),
    listEventMembersBasic(eid),
  ]);
  setMine(myRole);

  setMembers(mm);
  setEventMemberCount((evMembers || []).length);

  const existing = new Set(mm.map((x: { user_id: string }) => x.user_id));
  setCandidates(evMembers.filter((x: { user_id: string }) => !existing.has(x.user_id)));
} catch (e:any) {
  Alert.alert('載入失敗', String(e?.message || e));
}
}, [matchId]);

React.useEffect(() => { load(); }, [load]);

// 自動提示：事件成員數 > 場次成員數，且有權限，給匯入提示（需 matchId 才觸發）
React.useEffect(() => {
if (!matchId) return;
if (!canManage) return;
if (!eventMemberCount) return;
if (members.length < eventMemberCount) {
setTimeout(() => {
Alert.alert(
'帶入事件成員',
`此場次目前成員 ${members.length} 位，賽事成員共 ${eventMemberCount} 位，是否帶入？（已存在者會覆寫其角色）`,
[
{ text: '取消', style: 'cancel' },
{ text: '帶入', style: 'default', onPress: async () => {
try {
const count = await importEventMembersToMatch(matchId);
Alert.alert('完成', `已帶入事件成員（共 ${count} 筆）。`);
await load();
} catch (e:any) {
Alert.alert('帶入失敗', String(e?.message || e));
}
} },
]
);
}, 100);
}
}, [matchId, canManage, eventMemberCount, members.length, load]);

async function changeRole(memberId: string, userId: string, newRole: MemberRole) {
try {
if (!canManage) return;
await upsertMatchMember({ matchId, userId, role: newRole });
load();
} catch (e:any) {
Alert.alert('變更失敗', String(e?.message || e));
}
}

async function removeMember(memberId: string) {
try {
if (!canManage) return;
await deleteMatchMember(memberId);
load();
} catch (e:any) {
Alert.alert('移除失敗', String(e?.message || e));
}
}

async function addToMatch(userId: string, role: MemberRole) {
try {
if (!canManage) return;
await upsertMatchMember({ matchId, userId, role });
load();
} catch (e:any) {
Alert.alert('新增失敗', String(e?.message || e));
}
}

async function importAllFromEvent() {
try {
if (!canManage) {
Alert.alert('無權限', '僅 owner/coach/recorder 可匯入事件成員');
return;
}
if (!matchId) {
Alert.alert('錯誤', '缺少場次 ID');
return;
}
const count = await importEventMembersToMatch(matchId);
Alert.alert('完成', `已帶入事件成員（共 ${count} 筆，含覆寫已存在者角色）。`);
await load();
} catch (e:any) {
Alert.alert('帶入失敗', String(e?.message || e));
}
}

const HeaderActions = () => (
<View style={{ marginBottom: 10 }}>
<View style={{ flexDirection:'row', alignItems:'center', justifyContent:'space-between' }}>
<Text style={{ fontSize: 16, fontWeight: '600', color: C.text }}>場次成員</Text>
{canManage && (
<Pressable
onPress={importAllFromEvent}
style={{ paddingVertical:8, paddingHorizontal:12, backgroundColor:'#1976d2', borderRadius:8 }}
>
<Text style={{ color:'#fff' }}>帶入事件成員</Text>
</Pressable>
)}
</View>
{!!eventId && (
<Text style={{ color: C.sub, marginTop: 6 }}>
所屬賽事：{eventId.slice(0,8)}…　目前場次成員：{members.length} 位
</Text>
)}
</View>
);

const renderRow = ({ item }: { item: { id:string; user_id:string; role:MemberRole; name:string } }) => (
<View style={{ padding:10, borderWidth:1, borderColor:C.border, backgroundColor:C.card, borderRadius:8, marginBottom:8 }}>
<Text style={{ fontWeight:'600', marginBottom:6, color: C.text }}>{item.name}</Text>
<View style={{ flexDirection:'row', flexWrap:'wrap', alignItems:'center' }}>
{ROLES.map(r => {
const selected = item.role === r.key;
return (
<Pressable
key={r.key}
onPress={() => canManage && changeRole(item.id, item.user_id, r.key)}
style={{
paddingVertical:6, paddingHorizontal:10, borderRadius:14,
borderWidth:1, borderColor: selected ? C.chipOn : C.chipOff,
backgroundColor: selected ? 'rgba(144,202,249,0.15)' : C.card,
marginRight:8, marginBottom:8, opacity: canManage ? 1 : 0.5
}}
>
<Text style={{ color: C.text }}>{r.label}</Text>
</Pressable>
);
})}
{canManage && (
<Pressable
onPress={() => removeMember(item.id)}
style={{ paddingVertical:6, paddingHorizontal:10, backgroundColor:'#d32f2f', borderRadius:8, marginLeft:8 }}
>
<Text style={{ color:'#fff' }}>移除</Text>
</Pressable>
)}
</View>
</View>
);

return (
<View style={{ flex:1, backgroundColor: C.bg }}>
<ScrollView
style={{ flex:1, backgroundColor: C.bg }}
contentContainerStyle={{ padding:12, flexGrow: 1, paddingBottom: 16 }}
>
<HeaderActions />

    <FlatList
      data={members}
      keyExtractor={(i)=>i.id}
      renderItem={renderRow}
      scrollEnabled={false}
    />

    {canManage && (
      <View style={{ marginTop:12 }}>
        <Text style={{ fontWeight:'600', marginBottom:8, color: C.text }}>從事件成員加入</Text>
        {candidates.map(c => (
          <View key={c.user_id} style={{ padding:10, borderWidth:1, borderColor:C.border, backgroundColor:C.card, borderRadius:8, marginBottom:8 }}>
            <Text style={{ marginBottom:6, color: C.text }}>{c.name}</Text>
            <View style={{ flexDirection:'row', flexWrap:'wrap' }}>
              {ROLES.map(r => (
                <Pressable
                  key={r.key}
                  onPress={() => addToMatch(c.user_id, r.key)}
                  style={{ paddingVertical:6, paddingHorizontal:10, borderRadius:14, borderWidth:1, borderColor:C.chipOff, backgroundColor:C.card, marginRight:8, marginBottom:8 }}
                >
                  <Text style={{ color: C.text }}>{r.label}</Text>
                </Pressable>
              ))}
            </View>
          </View>
        ))}
        {!candidates.length && <Text style={{ color: C.sub }}>事件所有成員都已在本場次中</Text>}
      </View>
    )}
  </ScrollView>
</View>
);
}
ezbmt-tracked/src/screens/ClubHomeScreen.tsx
 
import React from 'react';
import { View, Text, Pressable } from 'react-native';
import { useNavigation } from '@react-navigation/native';

const C = {
bg: '#111',
card: '#1e1e1e',
text: '#fff',
sub: '#bbb',
btn: '#1976d2',
};

export default function ClubHomeScreen() {
const navigation = useNavigation<any>();
return (
<View style={{ flex: 1, backgroundColor: C.bg, alignItems: 'center', justifyContent: 'center', padding: 16 }}>
<Text style={{ color: C.text, fontSize: 18, fontWeight: '700', marginBottom: 8 }}>社團管理</Text>
<Text style={{ color: C.sub, marginBottom: 16 }}>（開發中，將包含計分板、社團留言板、成員管理等）</Text>
<Pressable
onPress={() => navigation.goBack()}
style={{ paddingVertical: 10, paddingHorizontal: 16, backgroundColor: C.btn, borderRadius: 10 }}
>
<Text style={{ color: '#fff' }}>返回</Text>
</Pressable>
</View>
);
}ezbmt-tracked/src/types.ts
 
export type Side = 'home' | 'away';
export type Zone = 1 | 2 | 3 | 4 | 5 | 6 | 'out';
export type Orientation = 'portrait' | 'landscape';

export type Point = { x: number; y: number };

export type TapEvent = {
  side: Side;        // portrait: 上=away，下=home；landscape：左=home，右=away（整張左轉90°）
  zone: Zone;        // 1..6 或 'out'
  point: Point;      // 以螢幕座標（px）
  norm?: {           // 以「直式雙打外框」為基準的相對座標（0..1，可超界）
    x: number;       // (px - innerX) / innerW
    y: number;       // (py - innerY) / innerH
  };
  inBounds: boolean; // 是否在場內（雙打外框且符合單/雙有效寬）
};

export type RallyEndMeta = {
  shotType?: string;
  hand?: '正手' | '反手';
  forceType?: '主動得分' | '對手失誤' | '主動失誤' | '受迫失誤';
  errorReason?: '出界' | '掛網' | '質量不好';
  lastHitter?: string;
};

export type RallyRecord = {
  id: string;
  matchId?: string;
  gameIndex: number; // 1..N（顯示用）
  rallyNo: number;
  winnerSide: Side;
  endZone: Zone;
  meta: RallyEndMeta;
  route?: { start: Point; end: Point }; // 以螢幕座標（px）
  createdAt: string;
};
ezbmt-tracked/src/components/MatchRulesSheet.tsx
 
import React from 'react';
import { View, Text, Modal, Pressable, Switch, Platform, ActionSheetIOS, Alert } from 'react-native';

type Rules = { bestOf: number; pointsToWin: number; deuce: boolean; cap?: number | null };

type Props = {
visible: boolean;
initial: Rules;
onClose: () => void;
onSave: (rules: Rules) => void;
};

// 可調整的選單
const BEST_OF_OPTIONS = [1, 3, 5] as const;
const POINTS_OPTIONS = [11, 15, 21] as const;
const CAP_OPTIONS = [null, 30] as const; // null=無封頂

export default function MatchRulesSheet({ visible, initial, onClose, onSave }: Props) {
const [bestOf, setBestOf] = React.useState<number>(initial.bestOf);
const [points, setPoints] = React.useState<number>(initial.pointsToWin);
const [deuce, setDeuce] = React.useState<boolean>(initial.deuce);
const [cap, setCap] = React.useState<number | null>(initial.cap ?? 30);

React.useEffect(() => {
if (visible) {
setBestOf(initial.bestOf);
setPoints(initial.pointsToWin);
setDeuce(initial.deuce);
setCap(initial.cap ?? 30);
}
}, [visible, initial]);

const openPicker = <T extends number | null>(
title: string,
options: readonly T[],
format: (v: T) => string,
onSelected: (v: T) => void
) => {
if (Platform.OS === 'ios') {
const labels = options.map(format);
ActionSheetIOS.showActionSheetWithOptions(
{ title, options: [...labels, '取消'], cancelButtonIndex: labels.length },
(idx) => {
if (idx != null && idx >= 0 && idx < labels.length) onSelected(options[idx]);
}
);
} else {
// Android：用 Alert 選單
Alert.alert(
title,
'',
[
...options.map((v) => ({ text: format(v), onPress: () => onSelected(v) })),
{ text: '取消', style: 'cancel' },
],
{ cancelable: true }
);
}
};

return (
<Modal visible={visible} transparent animationType="slide" onRequestClose={onClose}>
<View style={{ flex: 1, backgroundColor: 'rgba(0,0,0,0.35)', justifyContent: 'flex-end' }}>
<View style={{ backgroundColor: '#fff', borderTopLeftRadius: 16, borderTopRightRadius: 16, padding: 16 }}>
<Text style={{ fontSize: 16, fontWeight: '600', marginBottom: 12 }}>比賽規則</Text>

      <Row label="Best of (1/3/5)">
        <PickerButton
          text={String(bestOf)}
          onPress={() =>
            openPicker('Best of', BEST_OF_OPTIONS, (v) => String(v), (v) => setBestOf(v))
          }
        />
      </Row>

      <Row label="每局目標分 (11/15/21)">
        <PickerButton
          text={String(points)}
          onPress={() =>
            openPicker('每局目標分', POINTS_OPTIONS, (v) => String(v), (v) => setPoints(v))
          }
        />
      </Row>

      <Row label="Deuce（需領先2分）">
        <Switch value={deuce} onValueChange={setDeuce} />
      </Row>

      <Row label="封頂分（cap；30=29平搶1；空白=無封頂）">
        <PickerButton
          text={cap == null ? '無封頂' : String(cap)}
          onPress={() =>
            openPicker('封頂分', CAP_OPTIONS, (v) => (v == null ? '無封頂' : String(v)), (v) => setCap(v))
          }
        />
      </Row>

      <View style={{ flexDirection: 'row', justifyContent: 'flex-end', marginTop: 14 }}>
        <Pressable onPress={onClose} style={{ padding: 12, marginRight: 8 }}>
          <Text>取消</Text>
        </Pressable>
        <Pressable
          onPress={() => onSave({ bestOf, pointsToWin: points, deuce, cap })}
          style={{ padding: 12, backgroundColor: '#1976d2', borderRadius: 8 }}
        >
          <Text style={{ color: '#fff' }}>儲存</Text>
        </Pressable>
      </View>
    </View>
  </View>
</Modal>
);
}

function Row({ label, children }: any) {
return (
<View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 10 }}>
<Text style={{ width: 180 }}>{label}</Text>
{children}
</View>
);
}

function PickerButton({ text, onPress }: { text: string; onPress: () => void }) {
return (
<Pressable
onPress={onPress}
style={{
minWidth: 100,
paddingVertical: 8,
paddingHorizontal: 12,
borderWidth: 1,
borderColor: '#ccc',
borderRadius: 8,
backgroundColor: '#fff',
}}
>
<Text>{text}</Text>
</Pressable>
);
}ezbmt-tracked/src/components/Court.tsx
 

import React, { useMemo, useState, useCallback } from 'react';
import { View, LayoutChangeEvent } from 'react-native';
import Svg, { Rect, Line, Text as SvgText, G, Circle, Path } from 'react-native-svg';
import type { Orientation, Side, Zone, TapEvent, Point } from '../types';

type Marker = {
  id: string;
  rx: number;
  ry: number;
  kind: 'win' | 'loss';
};

type OverlayPositions = {
  A: { right: 0 | 1; left: 0 | 1 };
  B: { right: 0 | 1; left: 0 | 1 };
};

type SavedRoute = {
  id: string;
  sx: number; // normalized (0..1)
  sy: number;
  ex: number;
  ey: number;
  color: string; // 起點主=藍、起點客=紅（半透明）
  gi?: number;  // game index
  shotType?: string; // 曲率參考
};

type Props = {
  orientation: Orientation;
  singles: boolean;
  mode: 'tap' | 'route';
  routeStart: Point | null;
  routeHover: Point | null;
  onTap: (e: TapEvent) => void;
  onHover?: (p: Point | null) => void;
  markers?: Marker[];
  onPressMarker?: (id: string) => void;

  overlay?: {
    homeRight?: string;
    homeLeft?: string;
    awayRight?: string;
    awayLeft?: string;
    server?: { team: 0 | 1; index: 0 | 1 };
    receiver?: { team: 0 | 1; index: 0 | 1 };
    positions?: OverlayPositions;
    opacity?: number;
  };

  savedRoutes?: SavedRoute[];
  routePreviewColor?: string; // 預覽色（依起點隊）
  focusPoint?: { x: number; y: number } | null;
};

/* 球場比例與尺寸常數 */
const FULL_LEN = 13.4;
const FULL_WID = 6.1;
const PORTRAIT_RATIO = FULL_WID / FULL_LEN;
const LANDSCAPE_RATIO = FULL_LEN / FULL_WID;
const SHORT_LINE_DIST = 1.98;
const DBL_LONG_BACK = 0.76;
const SNG_WID = 5.18;
const SIDE_GAP = (FULL_WID - SNG_WID) / 2;

export default function Court({
  orientation, singles, mode, routeStart, routeHover, onTap, onHover, markers = [], onPressMarker, overlay, focusPoint, savedRoutes = [], routePreviewColor,
}: Props) {
  const [box, setBox] = useState({ w: 0, h: 0 });
  const onLayout = useCallback((e: LayoutChangeEvent) => {
    const { width, height } = e.nativeEvent.layout;
    setBox({ w: width, h: height });
  }, []);

  const draw = useMemo(() => {
    const { w: Wv, h: Hv } = box;
    if (Wv <= 0 || Hv <= 0) return { CW: 0, CH: 0, W: 0, H: 0, padX: 0, padY: 0, x: 0, y: 0 };
    const ratio = orientation === 'portrait' ? PORTRAIT_RATIO : LANDSCAPE_RATIO;
    let H = Hv * 0.9;
    let W = H * ratio;
    if (W > Wv * 0.96) {
      W = Wv * 0.96;
      H = W / ratio;
    }
    const padX = Math.round(W * 0.1);
    const padY = Math.round(H * 0.06);
    const CW = W + padX * 2;
    const CH = H + padY * 2;
    return { CW, CH, W, H, padX, padY, x: (Wv - CW) / 2, y: (Hv - CH) / 2 };
  }, [box, orientation]);

  return (
    <View style={{ flex: 1 }} onLayout={onLayout}>
      {draw.CW > 0 && (
        <CourtSurface
          containerW={draw.CW}
          containerH={draw.CH}
          width={draw.W}
          height={draw.H}
          padX={draw.padX}
          padY={draw.padY}
          offsetX={draw.x}
          offsetY={draw.y}
          orientation={orientation}
          singles={singles}
          mode={mode}
          routeStart={routeStart}
          routeHover={routeHover}
          onTap={onTap}
          onHover={onHover}
          markers={markers}
          onPressMarker={onPressMarker}
          overlay={overlay}
          focusPoint={focusPoint}
          savedRoutes={savedRoutes}
          routePreviewColor={routePreviewColor}
        />
      )}
    </View>
  );
}

function CourtSurface({
  containerW, containerH, width, height, padX, padY, offsetX, offsetY,
  orientation, singles, mode, routeStart, routeHover, onTap, onHover, markers, onPressMarker, overlay, focusPoint, savedRoutes = [], routePreviewColor,
}: {
  containerW: number; containerH: number; width: number; height: number; padX: number; padY: number; offsetX: number; offsetY: number;
} & Props) {
  const border = Math.max(2, Math.round(Math.min(width, height) * 0.02));
  const innerX = padX + border;
  const innerY = padY + border;
  const innerW = width - border * 2;
  const innerH = height - border * 2;

  const sx = innerW / FULL_WID;
  const sy = innerH / FULL_LEN;

  const midY = innerY + innerH / 2;
  const midX = innerX + innerW / 2;
  const topBack = innerY;
  const bottomBack = innerY + innerH;
  const topShort = midY - SHORT_LINE_DIST * sy;
  const bottomShort = midY + SHORT_LINE_DIST * sy;
  const topDblLong = topBack + DBL_LONG_BACK * sy;
  const bottomDblLong = bottomBack - DBL_LONG_BACK * sy;
  const singleLeft = innerX + SIDE_GAP * sx;
  const singleRight = innerX + innerW - SIDE_GAP * sx;

  const halfH = innerH / 2;
  const frontH = SHORT_LINE_DIST * sy;
  const midH = (halfH - frontH) / 2;
  const backH = (halfH - frontH) / 2;

  const effX = singles ? singleLeft : innerX;
  const effW = singles ? (singleRight - singleLeft) : innerW;

  function zoneNumber(rowType: 0 | 1 | 2, isRightFromPlayer: boolean): Zone {
    const base = rowType === 0 ? 1 : (rowType === 1 ? 5 : 3);
    return (base + (isRightFromPlayer ? 0 : 1)) as Zone;
  }

  function RealCourt() {
    const frame = '#151515';
    const line = '#f0e6da';
    const grass = '#2e7d32';
    const lineW = Math.max(3, Math.round(Math.min(innerW, innerH) * 0.012));
    return (
      <>
        <Rect x={innerX} y={innerY} width={innerW} height={innerH} fill={grass} />
        <Rect x={innerX} y={innerY} width={innerW} height={innerH} fill="none" stroke={frame} strokeWidth={lineW} />
        <Line x1={singleLeft} y1={innerY} x2={singleLeft} y2={innerY + innerH} stroke={line} strokeWidth={lineW} />
        <Line x1={singleRight} y1={innerY} x2={singleRight} y2={innerY + innerH} stroke={line} strokeWidth={lineW} />
        <Line x1={innerX} y1={midY} x2={innerX + innerW} y2={midY} stroke={line} strokeWidth={lineW} />
        <Line x1={innerX} y1={topShort} x2={innerX + innerW} y2={topShort} stroke={line} strokeWidth={lineW} />
        <Line x1={innerX} y1={bottomShort} x2={innerX + innerW} y2={bottomShort} stroke={line} strokeWidth={lineW} />
        <Line x1={midX} y1={topShort} x2={midX} y2={topBack} stroke={line} strokeWidth={lineW} />
        <Line x1={midX} y1={bottomShort} x2={midX} y2={bottomBack} stroke={line} strokeWidth={lineW} />
        <Line x1={innerX} y1={topDblLong} x2={innerX + innerW} y2={topDblLong} stroke={line} strokeWidth={lineW} />
        <Line x1={innerX} y1={bottomDblLong} x2={innerX + innerW} y2={bottomDblLong} stroke={line} strokeWidth={lineW} />
      </>
    );
  }

  function unrotateForLandscape(x: number, y: number) {
    const cx = containerW / 2, cy = containerH / 2;
    const dx = x - cx, dy = y - cy;
    return { x: cx - dy, y: cy + dx };
  }

  function classifyTapPortrait(px: number, py: number): TapEvent {
    const inOuter = px >= innerX && px <= innerX + innerW && py >= innerY && py <= innerY + innerH;
    const side: Side = py < midY ? 'away' : 'home';

    const inSinglesX = px >= effX && px <= effX + effW;
    const inBounds = inOuter && inSinglesX;

    const relFromNet = side === 'home' ? (py - midY) : (midY - py);
    let rowType: 0 | 1 | 2;
    if (relFromNet < frontH) rowType = 0;
    else if (relFromNet < frontH + midH) rowType = 1;
    else rowType = 2;

    const cellW = (effW / 2);
    const col = Math.max(0, Math.min(1, Math.floor((px - effX) / cellW))) as 0 | 1;
    const isRightFromPlayer = side === 'home' ? (col === 1) : (col === 0);
    const zone = zoneNumber(rowType, isRightFromPlayer);

    const rx = (px - innerX) / innerW;
    const ry = (py - innerY) / innerH;

    return { side, zone, point: { x: px, y: py }, norm: { x: rx, y: ry }, inBounds };
  }

  function classifyTap(x: number, y: number): TapEvent {
    if (orientation === 'portrait') {
      return classifyTapPortrait(x, y);
    } else {
      const r = unrotateForLandscape(x, y);
      return classifyTapPortrait(r.x, r.y);
    }
  }

  const onResponderMove = (evt: any) => {
    if (!routeStart || mode !== 'route') return;
    const { locationX, locationY } = evt?.nativeEvent || {};
    if (typeof locationX !== 'number' || typeof locationY !== 'number') return;
    onHover?.({ x: locationX, y: locationY });
  };

  const onResponderRelease = (evt: any) => {
    const { locationX, locationY } = evt?.nativeEvent || {};
    if (typeof locationX !== 'number' || typeof locationY !== 'number') return;

    const portraitPt = orientation === 'portrait'
      ? { x: locationX, y: locationY }
      : unrotateForLandscape(locationX, locationY);

    if (onPressMarker && markers && markers.length) {
      const near = markers.find(m => {
        const mx = innerX + m.rx * innerW;
        const my = innerY + m.ry * innerH;
        const dx = portraitPt.x - mx;
        const dy = portraitPt.y - my;
        return (dx*dx + dy*dy) <= (16*16);
      });
      if (near) { onPressMarker(near.id); return; }
    }

    onTap(classifyTap(locationX, locationY));
    onHover?.(null);
  };

  function renderZonesPortrait(side: Side) {
    const isAway = side === 'away';
    const rowsH = isAway ? [backH, midH, frontH] : [frontH, midH, backH];
    const startY = isAway ? innerY : midY;
    const cellW = (effW / 2);
    let y = startY;
    const nodes: any[] = [];
    for (let i = 0; i < 3; i++) {
      const rowH = rowsH[i];
      const xLeft = effX, xRight = effX + cellW;

      const rowType: 0 | 1 | 2 = isAway ? ((i === 0 ? 2 : i === 1 ? 1 : 0) as 0 | 1 | 2) : (i as 0 | 1 | 2);
      const rightLabel = zoneNumber(rowType, true);
      const leftLabel = zoneNumber(rowType, false);
      const leftZone = isAway ? rightLabel : leftLabel;
      const rightZone = isAway ? leftLabel : rightLabel;

      nodes.push(
        <G key={side + '-row' + i + '-L'}>
          <Rect x={xLeft} y={y} width={cellW} height={rowH} fill={side === 'home' ? 'rgba(76,175,80,0.12)' : 'rgba(244,67,54,0.12)'} />
          <SvgText x={xLeft + cellW / 2} y={y + rowH / 2} fontSize={Math.min(cellW, rowH) * 0.35} fill="#222" textAnchor="middle" alignmentBaseline="middle">
            {String(leftZone)}
          </SvgText>
        </G>
      );
      nodes.push(
        <G key={side + '-row' + i + '-R'}>
          <Rect x={xRight} y={y} width={cellW} height={rowH} fill={side === 'home' ? 'rgba(76,175,80,0.12)' : 'rgba(244,67,54,0.12)'} />
          <SvgText x={xRight + cellW / 2} y={y + rowH / 2} fontSize={Math.min(cellW, rowH) * 0.35} fill="#222" textAnchor="middle" alignmentBaseline="middle">
            {String(rightZone)}
          </SvgText>
        </G>
      );

      y += rowH;
    }
    return nodes;
  }

  function renderMarkers() {
    if (!markers || markers.length === 0) return null;
    const R = Math.max(6, Math.round(Math.min(innerW, innerH) * 0.015));
    return markers.map((m) => {
      const px = innerX + m.rx * innerW;
      const py = innerY + m.ry * innerH;
      const fill = m.kind === 'win' ? 'rgba(33,150,243,0.5)' : 'rgba(244,67,54,0.5)';
      const stroke = m.kind === 'win' ? 'rgba(33,150,243,0.9)' : 'rgba(244,67,54,0.9)';
      return <Circle key={m.id} cx={px} cy={py} r={R} fill={fill} stroke={stroke} strokeWidth={2} />;
    });
  }

  // 已保存路線（近似羽球飛行）
  function renderSavedRoutes() {
    if (!savedRoutes || savedRoutes.length === 0) return null;

    return savedRoutes.map(r => {
      const sxPx = innerX + r.sx * innerW;
      const syPx = innerY + r.sy * innerH;
      const exPx = innerX + r.ex * innerW;
      const eyPx = innerY + r.ey * innerH;

      const dx = exPx - sxPx;
      const dy = eyPx - syPx;
      const len = Math.max(1, Math.hypot(dx, dy));

      // 單位法向（朝上側），控制點落在 60~70% 處，弧度依球種
      const nx = -dy / len;
      const ny = dx / len;

      const shot = (r.shotType || '').trim();
      let k = 0.12 * len; // 中等弧度
      let t = 0.6;
      if (shot.includes('殺')) { k = 0.05 * len; t = 0.55; }
      else if (shot.includes('高遠')) { k = 0.24 * len; t = 0.7; }

      const cx = sxPx + dx * t + nx * k;
      const cy = syPx + dy * t + ny * k;

      const d = `M ${sxPx} ${syPx} Q ${cx} ${cy} ${exPx} ${eyPx}`;
      return <Path key={r.id} d={d} stroke={r.color} strokeWidth={Math.max(3, Math.round(Math.min(innerW, innerH) * 0.008))} fill="none" opacity={0.65} />;
    });
  }

  const previewColor = routePreviewColor || '#1976d2';

  return (
    <View style={{ width: containerW, height: containerH, marginLeft: offsetX, marginTop: offsetY }}>
      <Svg width={containerW} height={containerH} viewBox={'0 0 ' + containerW + ' ' + containerH}>
        <G transform={orientation === 'landscape' ? `rotate(-90 ${containerW / 2} ${containerH / 2})` : undefined}>
          {RealCourt()}
          {renderZonesPortrait('away')}
          {renderZonesPortrait('home')}

          {/* 路線（已保存） */}
          {renderSavedRoutes()}

          {/* 落點 */}
          {renderMarkers()}

          {/* 路線預覽（依起點隊伍顏色） */}
          {routeStart && (
            <>
              <Circle cx={routeStart.x} cy={routeStart.y} r={12} fill={previewColor} />
              {routeHover && (
                <>
                  <Line x1={routeStart.x} y1={routeStart.y} x2={routeHover.x} y2={routeHover.y} stroke={previewColor} strokeWidth={6} strokeDasharray="12,8" opacity={0.85} />
                  <Circle cx={routeHover.x} cy={routeHover.y} r={10} fill={previewColor} opacity={0.9} />
                </>
              )}
            </>
          )}

          {/* 疊加名牌 */}
          {(() => {
            if (!overlay) return null;
            const fs = Math.max(12, Math.round(Math.min(innerW, innerH) * 0.04));
            const cellW = (singles ? (singleRight - singleLeft) : innerW) / 2;
            const ex = singles ? singleLeft : innerX;
            const xLeft = ex + cellW / 2;
            const xRight = ex + cellW * 1.5;
            const yAway = innerY + innerH * 0.25;
            const yHome = innerY + innerH * 0.75;

            const pos = overlay.positions;
            const srv = overlay.server;
            const rcv = overlay.receiver;
            const markOf = (team: 0 | 1, side: 'R' | 'L'): 'S' | 'R' | undefined => {
              const map = team === 0 ? pos?.A : pos?.B;
              const at = side === 'R' ? map?.right : map?.left;
              if (srv && srv.team === team && srv.index === at) return 'S';
              if (rcv && rcv.team === team && rcv.index === at) return 'R';
              return undefined;
            };

            return (
              <>
                {!!overlay.awayRight && <NameBadge x={xLeft}  y={yAway} label={overlay.awayRight} fs={fs} mark={markOf(1,'R')} />}
                {!!overlay.awayLeft  && <NameBadge x={xRight} y={yAway} label={overlay.awayLeft } fs={fs} mark={markOf(1,'L')} />}
                {!!overlay.homeLeft  && <NameBadge x={xLeft}  y={yHome} label={overlay.homeLeft } fs={fs} mark={markOf(0,'L')} />}
                {!!overlay.homeRight && <NameBadge x={xRight} y={yHome} label={overlay.homeRight} fs={fs} mark={markOf(0,'R')} />}
              </>
            );
          })()}

          {/* 受控黑點 */}
          {focusPoint ? <Circle cx={focusPoint.x} cy={focusPoint.y} r={10} fill="rgba(0,0,0,0.85)" /> : null}
        </G>
      </Svg>

      <View
        style={{ position: 'absolute', left: 0, top: 0, right: 0, bottom: 0 }}
        pointerEvents="box-only"
        onStartShouldSetResponder={() => true}
        onResponderMove={onResponderMove}
        onResponderRelease={onResponderRelease}
      />
    </View>
  );
}

function NameBadge({ x, y, label, fs, mark }: { x: number; y: number; label: string; fs: number; mark?: 'S' | 'R' }) {
  const padX = 10, padY = 6;
  const w = Math.max(24, Math.round((label || '').length * fs * 0.58)) + padX * 2;
  const h = fs + padY * 2;
  const rx = 10;
  const bg = 'rgba(0,0,0,0.35)';
  return (
    <G>
      <Rect x={x - w / 2} y={y - h / 2} width={w} height={h} rx={rx} ry={rx} fill={bg} />
      <SvgText x={x} y={y} fontSize={fs} fill="#fff" textAnchor="middle" alignmentBaseline="middle">
        {label || ''}
      </SvgText>
      {mark ? (
        <G>
          <Circle cx={x + w / 2 - 12} cy={y - h / 2 + 12} r={10} fill={mark === 'S' ? '#1976d2' : '#d32f2f'} />
          <SvgText x={x + w / 2 - 12} y={y - h / 2 + 12} fontSize={10} fill="#fff" textAnchor="middle" alignmentBaseline="middle">
            {mark}
          </SvgText>
        </G>
      ) : null}
    </G>
  );
}ezbmt-tracked/src/components/GlobalBackground.tsx
 
import React from 'react';
import { Image, View, StyleSheet } from 'react-native';
import { useBgStore } from '../store/bg';

// 有上傳用使用者圖片，沒上傳用預設圖
const DEFAULT_BG = require('../images/bg_default.jpg');

export default function GlobalBackground() {
const uri = useBgStore(s => s.uri);
const opacity = useBgStore(s => s.opacity);
const source = uri ? { uri } : DEFAULT_BG;

return (
<View pointerEvents="none" style={StyleSheet.absoluteFillObject}>
<Image
source={source}
style={[StyleSheet.absoluteFillObject, { opacity }]}
resizeMode="cover"  // 中心裁切
/>
</View>
);
}ezbmt-tracked/src/components/RoutePlayer.tsx
 
import React, {
useEffect,
useImperativeHandle,
useMemo,
useRef,
useState,
forwardRef,
} from 'react';
import { View, Text, Pressable } from 'react-native';
import Svg, { Rect, Line, Circle } from 'react-native-svg';

export type RouteItem = {
sx: number; sy: number;     // normalized start (可為 <0 或 >1：出界)
ex: number; ey: number;     // normalized end   (可為 <0 或 >1：出界)
kind: 'win' | 'loss';
color?: string;             // 可由外部指定線色（主=藍、客=紅）
meta?: { shotType?: string; forceType?: string; errorReason?: string };
};

export type RoutePlayerHandle = {
play: () => void;
pause: () => void;
toggle: () => void;
prev: () => void;
next: () => void;
replay: () => void;
restartAll: () => void;           // 全部重播（從第一球）
setSpeed: (s: 0.5 | 1 | 2) => void;
};

type Props = {
width: number;
height: number;
routes: RouteItem[];
autoPlay?: boolean;
initialSpeed?: 0.5 | 1 | 2;
filter?: 'all' | 'win' | 'loss' | 'random';
onIndexChange?: (index: number) => void;
onPlayingChange?: (playing: boolean) => void;
controls?: 'full' | 'none';       // 預設 'none'：不畫內建控制列
showFilterChips?: boolean;        // controls='full' 時才有意義
};

// 球場實際規格（直式）
const FULL_LEN = 13.4;
const FULL_WID = 6.1;
const SHORT_LINE_DIST = 1.98;
const DBL_LONG_BACK = 0.76;

// 為「界外」預留的可視邊界（比例以整張畫布計算）
// 例如 0.15 代表左右/上下各留 15% 空間，用來容納 rx/ry < 0 或 > 1 的落點
const OUT_PAD_X = 0.1;
const OUT_PAD_Y = 0.02;

const RoutePlayer = forwardRef<RoutePlayerHandle, Props>(function RoutePlayer(
{
width,
height,
routes,
autoPlay = true,
initialSpeed = 1,
filter = 'all',
onIndexChange,
onPlayingChange,
controls = 'none',
showFilterChips = false,
},
ref
) {
const [index, setIndex] = useState(0);
const [t, setT] = useState(0);
const [playing, setPlaying] = useState(autoPlay);
const [speed, setSpeed] = useState<0.5 | 1 | 2>(initialSpeed);

const rafRef = useRef<number | null>(null);
const lastTsRef = useRef<number | null>(null);

// 預先計算「球場本體」繪製區（inner）與映射函式（mapX/mapY）
const padX = Math.round(width * OUT_PAD_X);
const padY = Math.round(height * OUT_PAD_Y);
const innerW = Math.max(1, width - padX * 2);
const innerH = Math.max(1, height - padY * 2);

const mapX = (rx: number) => padX + rx * innerW;
const mapY = (ry: number) => padY + ry * innerH;

const filtered = useMemo(() => {
if (filter === 'all') return routes;
if (filter === 'win') return routes.filter(r => r.kind === 'win');
if (filter === 'loss') return routes.filter(r => r.kind === 'loss');
if (filter === 'random') {
const arr = routes.slice();
for (let i = arr.length - 1; i > 0; i--) {
const j = Math.floor(Math.random() * (i + 1));
[arr[i], arr[j]] = [arr[j], arr[i]];
}
return arr;
}
return routes;
}, [routes, filter]);

useEffect(() => { setIndex(0); setT(0); setPlaying(autoPlay); }, [filter, routes, autoPlay]);
useEffect(() => { onIndexChange?.(index); }, [index, onIndexChange]);
useEffect(() => { onPlayingChange?.(playing); }, [playing, onPlayingChange]);

useEffect(() => {
if (!playing || !filtered.length) return;
const step = (ts: number) => {
const last = lastTsRef.current;
lastTsRef.current = ts;
const dt = last ? (ts - last) : 16;
const dur = 1500 / speed;
setT(prev => {
const nt = prev + dt / dur;
if (nt >= 1) { next(); return 0; }
return nt;
});
rafRef.current = requestAnimationFrame(step);
};
rafRef.current = requestAnimationFrame(step);
return () => {
if (rafRef.current) cancelAnimationFrame(rafRef.current);
rafRef.current = null;
lastTsRef.current = null;
};
}, [playing, index, speed, filtered.length]);

const total = filtered.length;
const idx = Math.max(0, Math.min(index, Math.max(0, total - 1)));
const cur = total ? filtered[idx] : null;

function play() { if (total) setPlaying(true); }
function pause() { setPlaying(false); }
function toggle() { setPlaying(p => !p); }
function prev() {
if (!total) return;
if (idx > 0) { setIndex(i => i - 1); setT(0); setPlaying(true); }
else { setT(0); setPlaying(false); }
}
function next() {
if (!total) return;
if (idx < total - 1) { setIndex(i => i + 1); setT(0); setPlaying(true); }
else { setPlaying(false); setT(1); }
}
function replay() { setT(0); if (total) setPlaying(true); }
function restartAll() { setIndex(0); setT(0); setPlaying(true); }

useImperativeHandle(
ref,
() => ({ play, pause, toggle, prev, next, replay, restartAll, setSpeed }),
[total]
);

// 點大小與線寬依 inner 區域尺度計算（避免含 padding 時視覺過小）
const sizeBase = Math.min(innerW, innerH);
const dotR = Math.max(4, Math.round(sizeBase * 0.01));
const trackW = Math.max(3, Math.round(sizeBase * 0.008));

// 位置映射（把 normalized *inner + padding）
const sx = cur ? mapX(cur.sx) : 0;
const sy = cur ? mapY(cur.sy) : 0;
const ex = cur ? mapX(cur.ex) : 0;
const ey = cur ? mapY(cur.ey) : 0;
const cx = sx + (ex - sx) * t;
const cy = sy + (ey - sy) * t;

// 路徑顏色（優先用外部 color；否則依得/失）
const color = cur?.color || (cur?.kind === 'win' ? '#1976d2' : '#d32f2f');

// 以 inner 繪製球場（綠底與線）
function CourtLines() {
const midY = padY + innerH / 2;
const midX = padX + innerW / 2;
const syScale = innerH / FULL_LEN;
const sxScale = innerW / FULL_WID;
const topShort = midY - SHORT_LINE_DIST * syScale;
const bottomShort = midY + SHORT_LINE_DIST * syScale;
const topDblLong = padY + 0 + DBL_LONG_BACK * syScale;
const bottomDblLong = padY + innerH - DBL_LONG_BACK * syScale;
const singleInnerW = 5.18 * sxScale;
const singleLeft = padX + (innerW - singleInnerW) / 2;
const singleRight = padX + innerW - (innerW - singleInnerW) / 2;
const line = '#f0e6da';
const lineW = Math.max(2, Math.round(Math.min(innerW, innerH) * 0.012));

return (
  <>
    {/* 背景透明層 */}
    <Rect x={0} y={0} width={width} height={height} fill="transparent" />
    {/* 球場本體（綠底） */}
    <Rect x={padX} y={padY} width={innerW} height={innerH} fill="#2e7d32" />
    {/* 外框 */}
    <Line x1={padX} y1={padY} x2={padX + innerW} y2={padY} stroke={line} strokeWidth={lineW} />
    <Line x1={padX} y1={padY + innerH} x2={padX + innerW} y2={padY + innerH} stroke={line} strokeWidth={lineW} />
    <Line x1={padX} y1={padY} x2={padX} y2={padY + innerH} stroke={line} strokeWidth={lineW} />
    <Line x1={padX + innerW} y1={padY} x2={padX + innerW} y2={padY + innerH} stroke={line} strokeWidth={lineW} />
    {/* 單打邊線 */}
    <Line x1={singleLeft} y1={padY} x2={singleLeft} y2={padY + innerH} stroke={line} strokeWidth={lineW} />
    <Line x1={singleRight} y1={padY} x2={singleRight} y2={padY + innerH} stroke={line} strokeWidth={lineW} />
    {/* 網 */}
    <Line x1={padX} y1={midY} x2={padX + innerW} y2={midY} stroke={line} strokeWidth={lineW} />
    {/* 短發球線 */}
    <Line x1={padX} y1={topShort} x2={padX + innerW} y2={topShort} stroke={line} strokeWidth={lineW} />
    <Line x1={padX} y1={bottomShort} x2={padX + innerW} y2={bottomShort} stroke={line} strokeWidth={lineW} />
    {/* 中央分界線 */}
    <Line x1={midX} y1={topShort} x2={midX} y2={padY} stroke={line} strokeWidth={lineW} />
    <Line x1={midX} y1={bottomShort} x2={midX} y2={padY + innerH} stroke={line} strokeWidth={lineW} />
    {/* 雙打長發球線 */}
    <Line x1={padX} y1={topDblLong} x2={padX + innerW} y2={topDblLong} stroke={line} strokeWidth={lineW} />
    <Line x1={padX} y1={bottomDblLong} x2={padX + innerW} y2={bottomDblLong} stroke={line} strokeWidth={lineW} />
  </>
);
}

return (
<View style={{ width, height }}>
<Svg width={width} height={height}>
<CourtLines />
{cur && (
<>
<Line x1={sx} y1={sy} x2={ex} y2={ey} stroke={color} strokeWidth={trackW} strokeDasharray="12,8" opacity={0.5} />
<Circle cx={sx} cy={sy} r={dotR} fill={color} opacity={0.85} />
<Circle cx={ex} cy={ey} r={dotR} fill={color} opacity={0.85} />
<Circle cx={cx} cy={cy} r={dotR + 2} fill={color} />
</>
)}
</Svg>

  {/* 內建控制列關閉，外層自繪（controls='none'） */}
  {controls === 'full' && (
    <View style={{ position: 'absolute', left: 10, right: 10, bottom: 10, backgroundColor: 'rgba(0,0,0,0.5)', borderRadius: 10, padding: 8 }}>
      <View style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between' }}>
        <Text style={{ color: '#fff' }}>{total ? `第 ${idx + 1}/${total} 球` : '無可播放路徑'}</Text>
        <View style={{ flexDirection: 'row', alignItems: 'center' }}>
          <Pressable onPress={prev} style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#424242', borderRadius: 6, marginRight: 6 }}>
            <Text style={{ color: '#fff' }}>上球</Text>
          </Pressable>
          <Pressable onPress={toggle} style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#1976d2', borderRadius: 6, marginRight: 6 }}>
            <Text style={{ color: '#fff' }}>{playing ? '暫停' : '播放'}</Text>
          </Pressable>
          <Pressable onPress={replay} style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#455a64', borderRadius: 6, marginRight: 6 }}>
            <Text style={{ color: '#fff' }}>重播</Text>
          </Pressable>
          <Pressable onPress={next} style={{ paddingVertical: 6, paddingHorizontal: 10, backgroundColor: '#424242', borderRadius: 6 }}>
            <Text style={{ color: '#fff' }}>下球</Text>
          </Pressable>
        </View>
      </View>

      {showFilterChips && (
        <View style={{ flexDirection: 'row', marginTop: 8 }}>
          {/* 如需在內建控制列顯示篩選 chips，可在此補上。 */}
        </View>
      )}
    </View>
  )}
</View>
);
});

export default RoutePlayer;ezbmt-tracked/src/components/MarkerSheet.tsx
 
import React from 'react';
import { View, Text, Modal, Pressable, ScrollView } from 'react-native';

type Props = {
  visible: boolean;
  data: { id: string; kind: 'win' | 'loss'; meta: any } | null;
  onClose: () => void;
  onDelete: (id: string) => void;
};

export default function MarkerSheet({ visible, data, onClose, onDelete }: Props) {
  if (!data) return null;
  const { id, kind, meta } = data;
  return (
    <Modal visible={visible} transparent animationType="slide" onRequestClose={onClose}>
      <View style={{ flex:1, backgroundColor:'rgba(0,0,0,0.35)', justifyContent:'flex-end' }}>
        <View style={{ backgroundColor:'#fff', borderTopLeftRadius:16, borderTopRightRadius:16, padding:16, maxHeight:'70%' }}>
          <Text style={{ fontSize:16, fontWeight:'600', marginBottom:8 }}>落點詳情</Text>
          <Text style={{ marginBottom:8 }}>結果：{kind === 'win' ? '得分' : '失分'}</Text>
          <ScrollView style={{ maxHeight:300 }}>
            <Text selectable style={{ color:'#444' }}>{JSON.stringify(meta || {}, null, 2)}</Text>
          </ScrollView>
          <View style={{ flexDirection:'row', justifyContent:'space-between', marginTop:12 }}>
            <Pressable onPress={() => onDelete(id)} style={{ padding:12, backgroundColor:'#d32f2f', borderRadius:8 }}>
              <Text style={{ color:'#fff' }}>刪除此筆</Text>
            </Pressable>
            <Pressable onPress={onClose} style={{ padding:12 }}>
              <Text>關閉</Text>
            </Pressable>
          </View>
        </View>
      </View>
    </Modal>
  );
}
ezbmt-tracked/src/components/HeatGrid.tsx
 
import React, { useMemo } from 'react';
import { View } from 'react-native';
import Svg, { Rect } from 'react-native-svg';

type Pt = { rx: number; ry: number; kind: 'win' | 'loss' };
type Props = {
width: number;
height: number;
points: Pt[]; // portrait 相對座標
grid: number; // 每格邊長（px）
mode?: 'all' | 'win' | 'loss';
};

export default function HeatGrid({ width, height, points, grid, mode = 'all' }: Props) {
const { cols, rows, cells, maxWin, maxLoss } = useMemo(() => {
const cols = Math.max(1, Math.floor(width / grid));
const rows = Math.max(1, Math.floor(height / grid));
const cells: Array<Array<{ win: number; loss: number }>> = Array.from({ length: rows }, () =>
Array.from({ length: cols }, () => ({ win: 0, loss: 0 }))
);
let maxWin = 0, maxLoss = 0;

for (let i = 0; i < points.length; i++) {
  const p = points[i];
  if (p.rx < 0 || p.rx > 1 || p.ry < 0 || p.ry > 1) continue;
  const cx = Math.min(cols - 1, Math.max(0, Math.floor(p.rx * cols)));
  const cy = Math.min(rows - 1, Math.max(0, Math.floor(p.ry * rows)));
  if (p.kind === 'win') cells[cy][cx].win += 1; else cells[cy][cx].loss += 1;
  if (cells[cy][cx].win > maxWin) maxWin = cells[cy][cx].win;
  if (cells[cy][cx].loss > maxLoss) maxLoss = cells[cy][cx].loss;
}
return { cols, rows, cells, maxWin, maxLoss };
}, [width, height, points, grid]);

const cellW = width / cols;
const cellH = height / rows;

return (
<View style={{ width, height }}>
<Svg width={width} height={height}>
{cells.map((row, y) =>
row.map((c, x) => {
if (c.win === 0 && c.loss === 0) return null;
let fill = 'transparent';
let alpha = 0;

        if (mode === 'win') {
          alpha = maxWin ? c.win / maxWin : 0;
          fill = `rgba(33,150,243,${0.15 + 0.55 * alpha})`;
        } else if (mode === 'loss') {
          alpha = maxLoss ? c.loss / maxLoss : 0;
          fill = `rgba(244,67,54,${0.15 + 0.55 * alpha})`;
        } else {
          const aWin = maxWin ? c.win / maxWin : 0;
          const aLoss = maxLoss ? c.loss / maxLoss : 0;
          if (aWin >= aLoss) {
            fill = `rgba(33,150,243,${0.15 + 0.55 * aWin})`;
          } else {
            fill = `rgba(244,67,54,${0.15 + 0.55 * aLoss})`;
          }
        }

        return (
          <Rect
            key={`${x}-${y}`}
            x={x * cellW}
            y={y * cellH}
            width={cellW}
            height={cellH}
            fill={fill}
          />
        );
      })
    )}
  </Svg>
</View>
);
}ezbmt-tracked/src/components/IntroShuttle.tsx
 
import React from 'react';
import { View, useWindowDimensions } from 'react-native';
import Svg, { Path, Circle, Line } from 'react-native-svg';
import Animated, {
useSharedValue,
useAnimatedStyle,
withRepeat,
withTiming,
Easing,
} from 'react-native-reanimated';

export default function IntroShuttle({ once = false }: { once?: boolean }) {
const { width } = useWindowDimensions();
const W = Math.min(width - 32, 560);
const H = 120;

const t = useSharedValue(0);

React.useEffect(() => {
const duration = 1600;
if (once) {
t.value = withTiming(1, { duration, easing: Easing.inOut(Easing.ease) });
} else {
t.value = withRepeat(
withTiming(1, { duration, easing: Easing.inOut(Easing.ease) }),
-1,
true
);
}
}, [once, t]);

// 動畫中的羽球位置與旋轉
const shuttleStyle = useAnimatedStyle(() => {
const x = 16 + (W - 32) * t.value;
const y = H * 0.65 - Math.sin(Math.PI * t.value) * (H * 0.42);
const dy =
(-Math.cos(Math.PI * t.value) * (H * 0.42) * Math.PI) / (W - 32);
const angle = Math.atan2(dy, 1); // 弧度

return {
  transform: [
    { translateX: x },
    { translateY: y },
    { rotate: angle + 'rad' },
    { translateX: -12 },
    { translateY: -12 },
  ],
};
});

// 幫助產生 Path d（不用模板字串，避免貼上時出錯）
const line = (x1: number, y1: number, x2: number, y2: number) =>
'M' + x1 + ' ' + y1 + ' L ' + x2 + ' ' + y2;
const quad = (x1: number, y1: number, cx: number, cy: number, x2: number, y2: number) =>
'M' + x1 + ' ' + y1 + ' Q ' + cx + ' ' + cy + ' ' + x2 + ' ' + y2;

return (
<View style={{ width: W, height: H, alignSelf: 'center' }}>
<Svg width={W} height={H}>
{/* 背景淡線 */}
<Path
d={line(0, H * 0.7, W, H * 0.7)}
stroke="#f0e6da"
strokeWidth={2}
opacity={0.4}
/>
<Path
d={line(0, H * 0.9, W, H * 0.9)}
stroke="#f0e6da"
strokeWidth={2}
opacity={0.2}
/>

    {/* 參考拋物線（淡藍） */}
    <Path
      d={quad(16, H * 0.65, W / 2, H * 0.1, W - 16, H * 0.65)}
      stroke="#1976d2"
      strokeWidth={2}
      fill="none"
      opacity={0.25}
    />
  </Svg>

  <Animated.View
    style={[{ position: 'absolute', left: 0, top: 0 }, shuttleStyle]}
  >
    {/* 迷你羽球圖形 */}
    <Svg width={24} height={24} viewBox="0 0 48 48">
      <Circle cx="18" cy="18" r="9" fill="#fff" />
      <Line
        x1="18"
        y1="22"
        x2="6"
        y2="34"
        stroke="#fff"
        strokeWidth={3}
        strokeLinecap="round"
      />
      <Line
        x1="22"
        y1="21"
        x2="11"
        y2="37"
        stroke="#fff"
        strokeWidth={3}
        strokeLinecap="round"
      />
      <Line
        x1="26"
        y1="19"
        x2="17"
        y2="38"
        stroke="#fff"
        strokeWidth={3}
        strokeLinecap="round"
      />
      <Circle
        cx="18"
        cy="18"
        r="11"
        stroke="#1976d2"
        strokeWidth={1.5}
        fill="none"
        opacity={0.4}
      />
    </Svg>
  </Animated.View>
</View>
);
}ezbmt-tracked/src/components/PS.tsx
 
import React from 'react';
import { View, Text, TextInput, Pressable, Alert, Image } from 'react-native';
import { supa, getCurrentUser } from '../lib/supabase';
import { useBgStore } from '../store/bg';
import { launchImageLibrary, type ImageLibraryOptions } from 'react-native-image-picker';

export default function ProfileScreen({ navigation }: any) {
const [name, setName] = React.useState('');
const [busy, setBusy] = React.useState(false);

const bgUri = useBgStore(s => s.uri);
const opacity = useBgStore(s => s.opacity);
const setOpacity = useBgStore(s => s.setOpacity);
const setFromBase64 = useBgStore(s => s.setFromBase64);
const clearBg = useBgStore(s => s.clear);

React.useEffect(() => {
(async () => {
const u = await getCurrentUser();
if (!u) return;
const { data } = await supa.from('profiles').select('name').eq('id', u.id).single();
if (data?.name) setName(String(data.name));
})();
}, []);

const save = async () => {
setBusy(true);
try {
const u = await getCurrentUser();
if (!u) throw new Error('未登入');
await supa.from('profiles').upsert({ id: u.id, name });
Alert.alert('成功', '已更新個人資料');
} catch (e: any) {
Alert.alert('失敗', String(e?.message || e));
} finally { setBusy(false); }
};

async function handleSignOut() {
try {
await supa.auth.signOut();   // 改用 supa.auth.signOut()
navigation.replace('Auth');
} catch (e:any) {
Alert.alert('登出失敗', String(e?.message || e));
}
}

async function pickBackground() {
try {
const opts: ImageLibraryOptions = {
mediaType: 'photo',
quality: 0.9,           // 修正：PhotoQuality（0~1），用 0.9
includeBase64: true,
selectionLimit: 1,
};
const res = await launchImageLibrary(opts);
if (res.didCancel) return;
const a = res.assets && res.assets[0];
if (!a?.base64) { Alert.alert('失敗', '此圖片無法取得內容，請再試一次'); return; }
const ext = (a.fileName?.split('.').pop() || (a.type?.split('/')?.pop() || 'jpg')).toLowerCase();
await setFromBase64(a.base64, ext);
Alert.alert('成功', '已設定背景圖');
} catch (e: any) {
Alert.alert('失敗', String(e?.message || e));
}
}

return (
<View style={{ flex:1, padding:16 }}>
<Text style={{ fontSize:16, fontWeight:'600', marginBottom:8 }}>個人資料</Text>
<TextInput
value={name}
onChangeText={setName}
placeholder="暱稱"
style={{ borderWidth:1, borderColor:'#ccc', borderRadius:8, paddingHorizontal:10, paddingVertical:8, marginBottom:10 }}
/>
<Pressable onPress={save} disabled={busy} style={{ backgroundColor:'#1976d2', paddingVertical:10, borderRadius:8, alignItems:'center', marginBottom:10 }}>
<Text style={{ color:'#fff' }}>儲存</Text>
</Pressable>
<Pressable onPress={handleSignOut} style={{ backgroundColor:'#d32f2f', paddingVertical:10, borderRadius:8, alignItems:'center', marginBottom:16 }}>
<Text style={{ color:'#fff' }}>登出</Text>
</Pressable>

  {/* 背景設定 */}
  <Text style={{ fontSize:16, fontWeight:'600', marginBottom:8 }}>背景圖片（本機）</Text>
  {bgUri ? (
    <View style={{ marginBottom: 10 }}>
      <Image source={{ uri: bgUri }} resizeMode="cover" style={{ width: '100%', height: 160, borderRadius: 8, backgroundColor:'#eee' }} />
      <Text style={{ color:'#555', marginTop:6 }}>目前透明度：{Math.round(opacity*100)}%</Text>
    </View>
  ) : (
    <Text style={{ color:'#666', marginBottom: 8 }}>尚未設定背景圖</Text>
  )}

  <View style={{ flexDirection:'row', flexWrap:'wrap', marginBottom:10 }}>
    <Pressable onPress={pickBackground} style={{ paddingVertical:8, paddingHorizontal:12, backgroundColor:'#1976d2', borderRadius:8, marginRight:8, marginBottom:8 }}>
      <Text style={{ color:'#fff' }}>選擇圖片</Text>
    </Pressable>
    {!!bgUri && (
      <Pressable onPress={clearBg} style={{ paddingVertical:8, paddingHorizontal:12, backgroundColor:'#9e9e9e', borderRadius:8, marginRight:8, marginBottom:8 }}>
        <Text style={{ color:'#fff' }}>清除背景</Text>
      </Pressable>
    )}
  </View>

  {!!bgUri && (
    <>
      <Text style={{ marginBottom:6 }}>透明度</Text>
      <View style={{ flexDirection:'row', flexWrap:'wrap' }}>
        {[0.15, 0.25, 0.4].map(v => (
          <Pressable
            key={String(v)}
            onPress={() => setOpacity(v)}
            style={{
              paddingVertical:6, paddingHorizontal:10, borderRadius:14,
              borderWidth:1, borderColor: opacity===v?'#1976d2':'#ccc',
              backgroundColor: opacity===v?'rgba(25,118,210,0.1)':'#fff',
              marginRight:8, marginBottom:8
            }}
          >
            <Text>{Math.round(v*100)}%</Text>
          </Pressable>
        ))}
      </View>
    </>
  )}
</View>
);
}ezbmt-tracked/src/components/CourtBackground.tsx
 
import React from 'react';
import Svg, { Rect, Line } from 'react-native-svg';

type Props = {
width: number;
height: number;
};

const FULL_LEN = 13.4;
const FULL_WID = 6.1;
const SHORT_LINE_DIST = 1.98;
const DBL_LONG_BACK = 0.76;

export default function CourtBackground({ width, height }: Props) {
const midY = height / 2;
const midX = width / 2;
const sy = height / FULL_LEN;
const sx = width / FULL_WID;

const topShort = midY - SHORT_LINE_DIST * sy;
const bottomShort = midY + SHORT_LINE_DIST * sy;
const topDblLong = 0 + DBL_LONG_BACK * sy;
const bottomDblLong = height - DBL_LONG_BACK * sy;

const singleInnerW = 5.18 * sx;
const singleLeft = (width - singleInnerW) / 2;
const singleRight = width - singleLeft;

const line = '#f0e6da';
const lineW = Math.max(2, Math.round(Math.min(width, height) * 0.012));

return (
<Svg width={width} height={height}>
{/* 草地 */}
<Rect x={0} y={0} width={width} height={height} fill="#2e7d32" />

  {/* 外框 */}
  <Line x1={0} y1={0} x2={width} y2={0} stroke={line} strokeWidth={lineW} />
  <Line x1={0} y1={height} x2={width} y2={height} stroke={line} strokeWidth={lineW} />
  <Line x1={0} y1={0} x2={0} y2={height} stroke={line} strokeWidth={lineW} />
  <Line x1={width} y1={0} x2={width} y2={height} stroke={line} strokeWidth={lineW} />

  {/* 單打邊線 */}
  <Line x1={singleLeft} y1={0} x2={singleLeft} y2={height} stroke={line} strokeWidth={lineW} />
  <Line x1={singleRight} y1={0} x2={singleRight} y2={height} stroke={line} strokeWidth={lineW} />

  {/* 網 */}
  <Line x1={0} y1={midY} x2={width} y2={midY} stroke={line} strokeWidth={lineW} />

  {/* 短發球線 */}
  <Line x1={0} y1={topShort} x2={width} y2={topShort} stroke={line} strokeWidth={lineW} />
  <Line x1={0} y1={bottomShort} x2={width} y2={bottomShort} stroke={line} strokeWidth={lineW} />

  {/* 中央分界線（短發球線之上/之下） */}
  <Line x1={midX} y1={topShort} x2={midX} y2={0} stroke={line} strokeWidth={lineW} />
  <Line x1={midX} y1={bottomShort} x2={midX} y2={height} stroke={line} strokeWidth={lineW} />

  {/* 雙打長發球線 */}
  <Line x1={0} y1={topDblLong} x2={width} y2={topDblLong} stroke={line} strokeWidth={lineW} />
  <Line x1={0} y1={bottomDblLong} x2={width} y2={bottomDblLong} stroke={line} strokeWidth={lineW} />
</Svg>
);
}ezbmt-tracked/src/components/ZoneMatrix.tsx
 
import React from 'react';
import { View, Text } from 'react-native';

type Stat = { win: number; loss: number };
type Props = {
stats: Record<string, Stat>; // key: '1'..'6' | 'out'
showOut?: boolean;
title?: string;
};

export default function ZoneMatrix({ stats, showOut = true, title }: Props) {
// 顯示順序：1,2 | 5,6 | 3,4
const zones = ['1', '2', '5', '6', '3', '4'];
const outStat = stats['out'] || { win: 0, loss: 0 };

const totals = zones.map((z) => {
const st = stats[z] || { win: 0, loss: 0 };
return st.win + st.loss;
});
const maxTotal = Math.max(1, ...totals, showOut ? outStat.win + outStat.loss : 0);

// 量測外層容器寬度，避免百分比
const [wrapW, setWrapW] = React.useState(0);
const GAP = 8; // 兩欄之間的水平間隙（px）
const cellW = React.useMemo(() => {
if (!wrapW) return 0;
// 兩欄等寬（簡單切半，保留間隙）
return Math.floor((wrapW - GAP) / 2);
}, [wrapW]);

const renderCell = (z: string) => {
const st = stats[z] || { win: 0, loss: 0 };
const total = st.win + st.loss;
const alpha = total ? 0.15 + 0.6 * (total / maxTotal) : 0.1;
const bg = 'rgba(76,175,80,' + alpha + ')';
const winPct = total ? (st.win / total) * 100 : 0;

return (
  <View
    key={z}
    style={{
      width: cellW || undefined,
      aspectRatio: 1.2,
      marginBottom: 8,
      borderWidth: 1,
      borderColor: '#eee',
      borderRadius: 10,
      padding: 8,
      backgroundColor: bg,
    }}
  >
    <Text style={{ fontWeight: '600', marginBottom: 4 }}>區 {z}</Text>
    <Text style={{ color: '#333' }}>總數：{total}</Text>

    <Progress pct={winPct} />

    <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginTop: 4 }}>
      <Text style={{ color: '#1976d2' }}>得：{st.win}</Text>
      <Text style={{ color: '#d32f2f' }}>失：{st.loss}</Text>
    </View>
  </View>
);
};

const outTotal = outStat.win + outStat.loss;
const outWinPct = outTotal ? (outStat.win / outTotal) * 100 : 0;

return (
<View>
{title ? <Text style={{ fontSize: 16, fontWeight: '600', marginBottom: 8 }}>{title}</Text> : null}

  <View
    style={{ flexDirection: 'row', flexWrap: 'wrap', justifyContent: 'space-between' }}
    onLayout={(e) => setWrapW(Math.floor(e.nativeEvent.layout.width || 0))}
  >
    {zones.map(renderCell)}

    {showOut ? (
      <View style={{ width: wrapW || undefined, marginTop: 6 }}>
        <View
          style={{
            borderWidth: 1,
            borderColor: '#eee',
            borderRadius: 10,
            padding: 10,
            backgroundColor: '#fafafa',
          }}
        >
          <Text style={{ fontWeight: '600', marginBottom: 4 }}>界外（OUT）</Text>

          <Progress pct={outWinPct} />

          <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginTop: 4 }}>
            <Text style={{ color: '#1976d2' }}>得：{outStat.win}</Text>
            <Text style={{ color: '#d32f2f' }}>失：{outStat.loss}</Text>
          </View>
        </View>
      </View>
    ) : null}
  </View>
</View>
);
}

// 單純的進度條（不使用百分比寬度）
function Progress({ pct }: { pct: number }) {
const [trackW, setTrackW] = React.useState(0);
const innerW = Math.round(trackW * Math.max(0, Math.min(1, pct / 100)));

return (
<View
onLayout={(e) => setTrackW(Math.floor(e.nativeEvent.layout.width || 0))}
style={{
height: 10,
backgroundColor: '#eee',
borderRadius: 6,
overflow: 'hidden',
marginTop: 6,
}}
>
<View
style={{
width: innerW,
height: 10,
backgroundColor: '#2196f3',
}}
/>
</View>
);
}ezbmt-tracked/src/components/Heatmap.tsx
 
import React, { useMemo } from 'react';
import { View } from 'react-native';
import Svg, { Rect, Circle } from 'react-native-svg';

type Pt = { rx: number; ry: number; kind: 'win' | 'loss' };
type Props = {
width: number;
height: number;
points: Pt[]; // portrait 相對座標，允許 <0 或 >1（界外）
dotRadius?: number;
blur?: boolean; // 預留：漸層熱區（此版先畫散點）
};

export default function Heatmap({ width, height, points, dotRadius = 6 }: Props) {
// 有界裁切（只顯示場內點；界外點可選擇另外顯示）
const inside = useMemo(
() => points.filter(p => p.rx >= 0 && p.rx <= 1 && p.ry >= 0 && p.ry <= 1),
[points]
);

return (
<View style={{ width, height }}>
<Svg width={width} height={height}>
<Rect x={0} y={0} width={width} height={height} fill="transparent" />
{inside.map((p, idx) => {
const x = p.rx * width;
const y = p.ry * height;
const fill = p.kind === 'win' ? 'rgba(33,150,243,0.45)' : 'rgba(244,67,54,0.45)';
const stroke = p.kind === 'win' ? 'rgba(33,150,243,0.9)' : 'rgba(244,67,54,0.9)';
return <Circle key={idx} cx={x} cy={y} r={dotRadius} fill={fill} stroke={stroke} strokeWidth={2} />;
})}
</Svg>
</View>
);
}
ezbmt-tracked/src/components/SimpleBarChart.tsx
 
import React from 'react';
import { View, Text, LayoutChangeEvent } from 'react-native';

export type BarRow = { label: string; win: number; loss: number };

type Props = {
data: BarRow[];
maxItems?: number;
title?: string;
};

export default function SimpleBarChart({ data, maxItems = 8, title }: Props) {
const rows = data.slice(0, maxItems);
const maxVal = Math.max(1, ...rows.map(r => r.win + r.loss));

return (
<View>
{title ? <Text style={{ fontSize: 16, fontWeight: '600', marginBottom: 8 }}>{title}</Text> : null}

  {rows.map((r) => (
    <BarRowItem key={r.label} row={r} maxVal={maxVal} />
  ))}
</View>
);
}

function BarRowItem({ row, maxVal }: { row: BarRow; maxVal: number }) {
const total = row.win + row.loss;
const [trackW, setTrackW] = React.useState(0); // px width of whole track

const onLayout = (e: LayoutChangeEvent) => {
const w = e.nativeEvent.layout.width || 0;
if (w !== trackW) setTrackW(Math.max(0, Math.floor(w)));
};

// bar 寬度（以 px 計算，不用百分比字串）
const barW = trackW * (total / maxVal);
const winW = total ? barW * (row.win / total) : 0;

return (
<View style={{ marginBottom: 10 }}>
<View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
<Text>{row.label}</Text>
<Text style={{ color: '#555' }}>{total} 次</Text>
</View>

  <View
    onLayout={onLayout}
    style={{
      alignSelf: 'stretch',
      height: 14,
      backgroundColor: '#eee',
      borderRadius: 8,
      overflow: 'hidden',
    }}
  >
    <View
      style={{
        width: barW,
        height: 14,
        backgroundColor: '#ffcdd2',
      }}
    >
      <View
        style={{
          width: winW,
          height: 14,
          backgroundColor: '#90caf9',
        }}
      />
    </View>
  </View>

  <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginTop: 4 }}>
    <Text style={{ color: '#1976d2' }}>得：{row.win}</Text>
    <Text style={{ color: '#d32f2f' }}>失：{row.loss}</Text>
  </View>
</View>
);
}ezbmt-tracked/src/lib/push.ts
 
export async function initPushIfAvailable() {
  try {
    // 動態載入，沒裝也不會拋錯
    const messaging = require('@react-native-firebase/messaging').default;

    // 申請權限（iOS 會彈窗；Android 自動允許）
    try {
      await messaging().requestPermission();
    } catch {}

    // 取得 token 並註冊到後端
    let token: string | null = null;
    try {
      token = await messaging().getToken();
    } catch {
      token = null;
    }
    if (token) {
      try {
        const { registerDeviceToken } = require('../db');
        await registerDeviceToken(token);
      } catch {}
    }

    // token 變更時重新註冊
    try {
      messaging().onTokenRefresh(async (tok: string) => {
        try {
          const { registerDeviceToken } = require('../db');
          await registerDeviceToken(tok);
        } catch {}
      });
    } catch {}
  } catch {
    // 未安裝 @react-native-firebase/messaging 或環境不支援，略過即可
  }
}ezbmt-tracked/src/lib/exportSession.ts
 
import { supa } from './supabase';
import { Alert, Platform } from 'react-native';
import Share from 'react-native-share';
import RNFS from 'react-native-fs';
import { shareCsv } from './exportPdf';

type RoundRow = { id: string; index: number };
type TeamNames = { a: string[]; b: string[] };

type Row = {
roundIndex: number;
courtNo: number;
teamA: string[];
teamB: string[];
scoreA?: number|null;
scoreB?: number|null;
winnerTeam?: 0|1|null;
finishedAt?: string|null;
};

function getPdfConvert(): ((opts:any)=>Promise<any>) | undefined {
try {
const mod = require('react-native-html-to-pdf');
const inst = mod?.default ?? mod;
return inst?.convert;
} catch {
return undefined;
}
}

function joinNames(list: string[]) { return (list || []).filter(Boolean).join('、'); }
function safe(s: any) { return s == null ? '' : String(s); }

export async function exportSessionCsv(sessionId: string): Promise<void> {
const rows = await buildSessionRows(sessionId);
const header = ['round_index', 'court_no', 'team_a', 'team_b', 'score_a', 'score_b', 'winner', 'finished_at'];
const lines = [header.join(',')];

rows.forEach((r) => {
const winner = r.winnerTeam == null ? '' : (r.winnerTeam === 0 ? 'A' : 'B');
const line = [
r.roundIndex, r.courtNo,
"${joinNames(r.teamA)}",
"${joinNames(r.teamB)}",
(r.scoreA ?? ''), (r.scoreB ?? ''),
winner,
r.finishedAt ? new Date(r.finishedAt).toISOString() : '',
].join(',');
lines.push(line);
});

const csv = lines.join('\n');
await shareCsv(`session-${sessionId}`, csv);
}

export async function exportSessionPdf(sessionId: string): Promise<void> {
const rows = await buildSessionRows(sessionId);
const group = new Map<number, Row[]>();
rows.forEach((r) => {
if (!group.has(r.roundIndex)) group.set(r.roundIndex, []);
group.get(r.roundIndex)!.push(r);
});

const parts: string[] = [];
parts.push(`

<html><head><meta charset="utf-8"/> <style> body{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;padding:16px;} h1{font-size:20px;margin:0 0 12px 0;} h2{font-size:16px;margin:16px 0 8px 0;} table{border-collapse:collapse;width:100%;} th,td{border:1px solid #ddd;padding:6px;font-size:12px;} .muted{color:#777;} </style> </head><body> <h1>Session Summary</h1> `);
Array.from(group.keys()).sort((a,b)=>a-b).forEach((idx) => {
const arr = group.get(idx) || [];
parts.push(`<h2>第 ${idx} 輪</h2>`);
parts.push('<table><tr><th>場地</th><th>A隊</th><th>B隊</th><th>比分</th><th>勝方</th><th>結束時間</th></tr>');
arr.forEach((r) => {
const score = (r.scoreA == null || r.scoreB == null) ? '-' : `${r.scoreA}:${r.scoreB}`;
const win = r.winnerTeam == null ? '-' : (r.winnerTeam === 0 ? 'A' : 'B');
const fin = r.finishedAt ? new Date(r.finishedAt).toLocaleString() : '';
parts.push(`<tr>         <td>${r.courtNo}</td>         <td>${joinNames(r.teamA)}</td>         <td>${joinNames(r.teamB)}</td>         <td>${score}</td>         <td>${win}</td>         <td>${fin}</td>       </tr>`);
});
parts.push('</table>');
});

if (group.size === 0) {
parts.push(`<p class="muted">尚無任何輪次/對戰資料</p>`);
}

parts.push('</body></html>');
const html = parts.join('\n');

const convert = getPdfConvert();
if (typeof convert !== 'function') {
throw new Error('RNHTMLtoPDF 不可用（模組未連結或尚未重編譯）');
// 你也可以改成 Alert.alert(...)，但這裡丟錯讓呼叫端去 catch
}

const fileBase = `session-${String(sessionId).replace(/[^a-zA-Z0-9_-]/g,'-')}-${Date.now()}`;
const directory = Platform.OS === 'android' ? 'Download' : 'Documents';
const res = await convert({ html, fileName: fileBase, base64: false, directory });

const rawPath = res?.filePath;
if (!rawPath) throw new Error('PDF 產生失敗（未取得檔案路徑）');
const url = rawPath.startsWith('file://') ? rawPath : `file://${rawPath}`;

try {
await Share.open({
url,
type: 'application/pdf',
filename: `${fileBase}.pdf`,
failOnCancel: false,
showAppsToView: true,
});
} catch (e) {
const msg = String((e as any)?.message || e).toLowerCase();
if (msg.includes('cancel')) return;
throw e;
}
}

/** 聚合 session 下的所有輪與對戰結果 */
async function buildSessionRows(sessionId: string): Promise<Row[]> {
const { data: roundsData } = await supa
.from('session_rounds')
.select('id,index_no')
.eq('session_id', sessionId)
.order('index_no', { ascending: true });

const rounds: RoundRow[] = (roundsData || []).map((r: any) => ({ id: String(r.id), index: Number(r.index_no || 0) }));
if (!rounds.length) return [];
const roundIds = rounds.map(r => r.id);

const { data: rms } = await supa
.from('round_matches')
.select('round_id,court_no,team_a,team_b')
.in('round_id', roundIds as any);

const { data: rrs } = await supa
.from('round_results')
.select('round_id,court_no,score_home,score_away,winner_team,finished_at')
.in('round_id', roundIds as any);

const matchMap = new Map<string, TeamNames>();
(rms || []).forEach((m: any) => {
const key = `${m.round_id}#${Number(m.court_no)}`;
const a = ((m.team_a?.players) || []).map((p: any) => String(p?.name || ''));
const b = ((m.team_b?.players) || []).map((p: any) => String(p?.name || ''));
matchMap.set(key, { a, b });
});

const resultMap = new Map<string, { a?: number|null; b?: number|null; w?: 0|1|null; fin?: string|null }>();
(rrs || []).forEach((r: any) => {
const key = `${r.round_id}#${Number(r.court_no)}`;
resultMap.set(key, {
a: (r.score_home == null ? null : Number(r.score_home)),
b: (r.score_away == null ? null : Number(r.score_away)),
w: (r.winner_team == null ? null : Number(r.winner_team)) as 0|1|null,
fin: r.finished_at ? String(r.finished_at) : null,
});
});

const allCourtNos = new Set<number>();
(rms || []).forEach((m: any) => allCourtNos.add(Number(m.court_no)));
(rrs || []).forEach((r: any) => allCourtNos.add(Number(r.court_no)));
if (allCourtNos.size === 0) return [];

const rows: Row[] = [];
rounds.forEach((r) => {
const courtNos = Array.from(allCourtNos).sort((a,b)=>a-b);
courtNos.forEach((c) => {
const key = `${r.id}#${c}`;
const names = matchMap.get(key) || { a: [], b: [] };
const res = resultMap.get(key) || {};
rows.push({
roundIndex: r.index,
courtNo: c,
teamA: names.a,
teamB: names.b,
scoreA: res.a ?? null,
scoreB: res.b ?? null,
winnerTeam: res.w ?? null,
finishedAt: res.fin ?? null,
});
});
});

const filtered = rows.filter(r => (r.teamA.length || r.teamB.length));
filtered.sort((x,y)=> x.roundIndex===y.roundIndex ? (x.courtNo-y.courtNo) : (x.roundIndex-y.roundIndex));
return filtered;
}

ezbmt-tracked/src/lib/webrtcSignal.ts
 
import { supa } from './supabase';

export type SignalMessage =
| { kind: 'offer'; from: string; sdp: any }
| { kind: 'answer'; from: string; sdp: any }
| { kind: 'ice'; from: string; candidate: any };

export function openSignalChannel(camDeviceId: string) {
const topic = `webrtc:cam:${camDeviceId}`;
const channel = supa.channel(topic, { config: { broadcast: { ack: true } } });

let subscribed = false;

function subscribe(onMessage: (msg: SignalMessage) => void): Promise<void> {
return new Promise<void>((resolve) => {
channel.on('broadcast', { event: 'signal' }, (payload: any) => {
const msg = payload?.payload as SignalMessage;
if (msg && typeof msg === 'object' && 'kind' in msg) {
onMessage(msg);
}
});

  channel.subscribe((status: string) => {
    if (status === 'SUBSCRIBED') {
      subscribed = true;
      resolve();
    }
  });
});
}

async function ensureSubscribed() {
if (subscribed) return;
await new Promise<void>((resolve) => {
channel.subscribe((status: string) => {
if (status === 'SUBSCRIBED') {
subscribed = true;
resolve();
}
});
});
}

async function send(msg: SignalMessage): Promise<void> {
await ensureSubscribed();
try {
await channel.send({ type: 'broadcast', event: 'signal', payload: msg });
} catch {
// ignore
}
}

async function close(): Promise<void> {
try {
await channel.unsubscribe();
} catch {
// ignore
}
}

return { subscribe, send, close, channel };
}ezbmt-tracked/src/lib/syncDown.ts
 
import { supa } from './supabase';
import SQLite from 'react-native-sqlite-storage';
import { openDB } from '../db/sqlite'; // 若你的 openDB 在聚合層，改對應路徑

export async function syncDownOnce() {
const d = await openDB();

// 取 last sync
let since = '1970-01-01T00:00:00.000Z';
try {
const [res] = await d.executeSql('SELECT v FROM meta WHERE k=?', ['last_down_sync_at']);
if (res.rows.length) since = String(res.rows.item(0).v);
} catch {}

// 拉資料（RPC）
const [ev, mt, rl] = await Promise.all([
supa.rpc('pull_events_since', { p_since: since }),
supa.rpc('pull_matches_since', { p_since: since }),
supa.rpc('pull_rallies_since', { p_since: since }),
]);
if (ev.error) throw ev.error;
if (mt.error) throw mt.error;
if (rl.error) throw rl.error;

// 本地 upsert
const now = new Date().toISOString();

await d.executeSql('BEGIN');

for (const e of ev.data || []) {
await d.executeSql(
'REPLACE INTO events (id,name,level,venue,start_at,end_at) VALUES (?,?,?,?,?,?)',
[e.id, e.name, e.level || null, e.venue || null, e.start_at || null, e.end_at || null]
);
}

for (const m of mt.data || []) {
await d.executeSql(
'REPLACE INTO matches (id,event_id,type,court_no,rules_json,created_at) VALUES (?,?,?,?,?,?)',
[m.id, m.event_id, m.type, m.court_no || null, JSON.stringify(m.rules_json || null), m.created_at]
);
}

for (const r of rl.data || []) {
await d.executeSql(
'REPLACE INTO rallies (id,match_id,game_index,rally_no,winner_side,end_zone,meta_json,route_start_x,route_start_y,route_end_x,route_end_y,created_at) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)',
[
r.id, r.match_id, r.game_index, r.rally_no, r.winner_side, r.end_zone,
JSON.stringify(r.meta_json || null),
r.route_start_x ?? null, r.route_start_y ?? null, r.route_end_x ?? null, r.route_end_y ?? null,
r.created_at
]
);
}

await d.executeSql('REPLACE INTO meta(k,v) VALUES(?,?)', ['last_down_sync_at', now]);
await d.executeSql('COMMIT');
}

export function startSyncDownLoop() {
// 前景每 60 秒跑一次
syncDownOnce().catch(()=>{});
return setInterval(()=>syncDownOnce().catch(()=>{}), 60_000);
}
ezbmt-tracked/src/lib/storage.ts
 
import { supa, SUPABASE_URL } from './supabase'

// base64 -> Uint8Array（純 JS，不依賴外部套件）
function base64ToUint8Array(base64: string): Uint8Array {
const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
let str = base64.replace(/[^A-Za-z0-9+/=]/g, '');
const len = str.length;
let bufferLength = str.length * 0.75;
if (str[str.length - 1] === '=') bufferLength--;
if (str[str.length - 2] === '=') bufferLength--;
const bytes = new Uint8Array(bufferLength);
let p = 0;
for (let i = 0; i < len; i += 4) {
const c1 = chars.indexOf(str[i]);
const c2 = chars.indexOf(str[i + 1]);
const c3 = chars.indexOf(str[i + 2]);
const c4 = chars.indexOf(str[i + 3]);
const n = (c1 << 18) | (c2 << 12) | ((c3 & 63) << 6) | (c4 & 63);
bytes[p++] = (n >> 16) & 255;
if (str[i + 2] !== '=') bytes[p++] = (n >> 8) & 255;
if (str[i + 3] !== '=') bytes[p++] = n & 255;
}
return bytes;
}

function ensureClient() {
if (!supa) {
throw new Error('Supabase client 未初始化。請檢查 src/lib/supabase.ts 是否已 createClient。');
}
if (!(supa as any).storage) {
throw new Error('supa.storage 不可用，請確認 @supabase/supabase-js 已安裝與 polyfill 已加入。');
}
}

// 主要：從 URI 讀檔並上傳（先嘗試 fetch arrayBuffer，失敗時用 RNFS 讀 file://）
export async function uploadImageFromUri(uri: string, path: string, contentType = 'image/jpeg'): Promise<string> {
ensureClient();

let ab: ArrayBuffer | null = null;

// 1) 優先用 fetch 取得 arrayBuffer（RN 0.71+ 支援）
try {
const res = await fetch(uri);
if (res && typeof (res as any).arrayBuffer === 'function') {
ab = await (res as any).arrayBuffer();
} else if (res && typeof (res as any).blob === 'function') {
const blob = await (res as any).blob();
if (blob && typeof (blob as any).arrayBuffer === 'function') {
ab = await (blob as any).arrayBuffer();
}
}
} catch {
// 忽略，改走 RNFS
}

// 2) 若還是空，且是 file://，改用 RNFS 讀 base64 再轉 ArrayBuffer
if ((!ab || ab.byteLength === 0) && uri.startsWith('file://')) {
try {
const RNFS = require('react-native-fs');
const base64 = await RNFS.readFile(uri.replace('file://', ''), 'base64');
const u8 = base64ToUint8Array(base64);
ab = u8.buffer;
} catch (_e) {
// 留待最後檢查
}
}

if (!ab || ab.byteLength === 0) {
throw new Error('讀取圖片內容失敗（arrayBuffer 為空）。請改用 includeBase64 或確認 uri 可讀。');
}

const { data, error } = await supa.storage.from('media').upload(path, ab, { contentType, upsert: false });
if (error) throw error;
return data?.path || path;
}

// 若 image-picker 有回傳 base64，可用這個直接上傳
export async function uploadImageBase64(base64: string, path: string, contentType = 'image/jpeg'): Promise<string> {
ensureClient();
const u8 = base64ToUint8Array(base64);
const ab = u8.buffer;
const { data, error } = await supa.storage.from('media').upload(path, ab, { contentType, upsert: false });
if (error) throw error;
return data?.path || path;
}

export function getPublicUrl(path: string): string {
ensureClient();
const { data } = supa.storage.from('media').getPublicUrl(path);
return data.publicUrl;
}

export async function removeFile(path: string): Promise<void> {
ensureClient();
const { error } = await supa.storage.from('media').remove([path]);
if (error) throw error;
}

export function publicUrlToPath(url: string): string | null {
try {
const marker = '/storage/v1/object/public/media/';
const idx = url.indexOf(marker);
if (idx < 0) return null;
return url.slice(idx + marker.length);
} catch {
return null;
}
}

export async function getSignedUploadUrl(matchId: string, ext: string, contentType: string) {
const { data, error } = await supa.functions.invoke('sign-upload', {
body: { matchId, contentType, ext },
});
if (error) throw error;
return data as { path: string; signedUrl: string };
}

export async function uploadToSignedUrl(signedUrl: string, data: ArrayBuffer, contentType: string) {
const res = await fetch(signedUrl, {
method: 'PUT',
headers: { 'content-type': contentType },
body: data,
});
//if (!res.ok) throw new Error(upload failed: ${res.status});
}
ezbmt-tracked/src/lib/pairingPrefs.ts
 
import AsyncStorage from '@react-native-async-storage/async-storage';

export type PairingPrefs = {
courts: string;
teamSize: '1' | '2';
roundMinutes: string;
partnerCooldown: string;
opponentWindow: string;
maxLevelDiffPerPair: string;
preferMixed: boolean;
restCooldown: string;  // 新增
};

const keyOf = (sessionId: string) => `pairing:prefs:${sessionId}`;

export async function getPrefs(sessionId: string): Promise<Partial<PairingPrefs> | null> {
try {
const s = await AsyncStorage.getItem(keyOf(sessionId));
if (!s) return null;
const obj = JSON.parse(s || '{}');
return obj || null;
} catch {
return null;
}
}

export async function savePrefs(sessionId: string, prefs: PairingPrefs): Promise<void> {
try {
await AsyncStorage.setItem(keyOf(sessionId), JSON.stringify(prefs));
} catch {}
}

export async function clearPrefs(sessionId: string): Promise<void> {
try { await AsyncStorage.removeItem(keyOf(sessionId)); } catch {}
}

ezbmt-tracked/src/lib/deviceId.ts
 
import AsyncStorage from '@react-native-async-storage/async-storage';
import { v4 as uuidv4 } from 'uuid';
import { Platform } from 'react-native';

const KEY = 'device:id:v1';

export async function getDeviceId(): Promise<string> {
try {
const s = await AsyncStorage.getItem(KEY);
if (s && s.length > 0) return s;
} catch {}
const id = uuidv4();
try { await AsyncStorage.setItem(KEY, id); } catch {}
return id;
}

export function getPlatformTag(): string {
return Platform.OS === 'ios' ? 'iOS' : Platform.OS === 'android' ? 'Android' : Platform.OS;
}

ezbmt-tracked/src/lib/presence.ts
 
import { supa } from './supabase';

export function startPresenceHeartbeat(intervalMs = 30000) {
let timer: any = null;
let stopped = false;

const loop = async () => {
try {
const { data } = await supa.auth.getUser();
const uid = data?.user?.id;
if (!uid) return;

  // 不強依賴定位；就算沒權限也要 upsert last_seen_at
  await supa.from('user_presence').upsert({
    user_id: uid,
    last_seen_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
  });
} catch {}
};

loop().catch(()=>{});
timer = setInterval(() => loop().catch(()=>{}), intervalMs);

return () => {
if (stopped) return;
stopped = true;
if (timer) clearInterval(timer);
};
}ezbmt-tracked/src/lib/export.ts
 
import { Platform } from 'react-native';
import Share from 'react-native-share';
import RNFS from 'react-native-fs';

// 動態載入（default 優先）；沒有就回傳 undefined
function getPdfConvert(): ((opts:any)=>Promise<any>) | undefined {
try {
const mod = require('react-native-html-to-pdf');
const inst = mod?.default ?? mod;
return inst?.convert;
} catch {
return undefined;
}
}

function esc(s: any) {
return String(s == null ? '' : s)
.replace(/&/g,'&')
.replace(/</g,'<')
.replace(/>/g,'>');
}

function courtSvg(w:number,h:number, routes: Array<{ rx:number; ry:number; kind:'win'|'loss' }>): string {
const lines: string[] = [];
const line = '#f0e6da';
const lw = Math.max(2, Math.round(Math.min(w, h) * 0.012));
const midY = h/2, midX = w/2;
const sy = h / 13.4, sx = w / 6.1;
const tS = midY - 1.98 * sy, bS = midY + 1.98 * sy;
const tL = 0 + 0.76 * sy, bL = h - 0.76 * sy;
const singleLeft = (w - (5.18 * sx)) / 2, singleRight = w - singleLeft;

function L(x1:number,y1:number,x2:number,y2:number) {
lines.push(`<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${line}" stroke-width="${lw}" />`);
}

const court = [
`<rect x="0" y="0" width="${w}" height="${h}" fill="#2e7d32" />`,
`<rect x="0" y="0" width="${w}" height="${h}" fill="none" stroke="${line}" stroke-width="${lw}" />`,
`<line x1="${singleLeft}" y1="0" x2="${singleLeft}" y2="${h}" stroke="${line}" stroke-width="${lw}" />`,
`<line x1="${singleRight}" y1="0" x2="${singleRight}" y2="${h}" stroke="${line}" stroke-width="${lw}" />`,
`<line x1="0" y1="${midY}" x2="${w}" y2="${midY}" stroke="${line}" stroke-width="${lw}" />`,
`<line x1="0" y1="${tS}" x2="${w}" y2="${tS}" stroke="${line}" stroke-width="${lw}" />`,
`<line x1="0" y1="${bS}" x2="${w}" y2="${bS}" stroke="${line}" stroke-width="${lw}" />`,
`<line x1="${midX}" y1="${tS}" x2="${midX}" y2="0" stroke="${line}" stroke-width="${lw}" />`,
`<line x1="${midX}" y1="${bS}" x2="${midX}" y2="${h}" stroke="${line}" stroke-width="${lw}" />`,
`<line x1="0" y1="${tL}" x2="${w}" y2="${tL}" stroke="${line}" stroke-width="${lw}" />`,
`<line x1="0" y1="${bL}" x2="${w}" y2="${bL}" stroke="${line}" stroke-width="${lw}" />`,
].join('\n');

const dots = routes
.filter(p => p.rx>=0 && p.rx<=1 && p.ry>=0 && p.ry<=1)
.map((p) => {
const x = Math.round(p.rx * w), y = Math.round(p.ry * h);
const fill = p.kind === 'win' ? 'rgba(33,150,243,0.55)' : 'rgba(244,67,54,0.55)';
const stroke = p.kind === 'win' ? 'rgba(33,150,243,0.95)' : 'rgba(244,67,54,0.95)';
return `<circle cx="${x}" cy="${y}" r="6" fill="${fill}" stroke="${stroke}" stroke-width="2" />`;
}).join('\n');

return `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">${court}${lines.join('')}${dots}</svg>`;
}

function shotBarHtml(rows: Array<{ label:string; win:number; loss:number }>) {
const max = Math.max(1, ...rows.map(r=>r.win+r.loss));
return rows.map(r => {
const total = r.win + r.loss;
const widthPct = Math.round(total / max * 100);
const winPct = total ? Math.round(r.win / total * 100) : 0;
return `<div style="margin-bottom:8px">       <div style="display:flex;justify-content:space-between;margin-bottom:2px">         <span>${esc(r.label)}</span><span style="color:#555">${total} 次</span>       </div>       <div style="height:12px;background:#eee;border-radius:6px;overflow:hidden">         <div style="width:${widthPct}%;height:100%;background:#ffcdd2">           <div style="width:${winPct}%;height:100%;background:#90caf9"></div>         </div>       </div>     </div>`;
}).join('\n');
}

function routeThumbs(th: Array<{ sx:number; sy:number; ex:number; ey:number; kind:'win'|'loss' }>, cols=4, size=150) {
const items = th.map((r) => {
const color = r.kind==='win'?'#1976d2':'#d32f2f';
return `<div style="width:${size}px;height:${Math.round(size*13.4/6.1)}px;border-radius:8px;overflow:hidden;background:#e8f5e9;margin:6px">       <svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${Math.round(size*13.4/6.1)}" viewBox="0 0 ${size} ${Math.round(size*13.4/6.1)}">         <line x1="${r.sx*size}" y1="${r.sy*Math.round(size*13.4/6.1)}" x2="${r.ex*size}" y2="${r.ey*Math.round(size*13.4/6.1)}" stroke="${color}" stroke-width="4" stroke-dasharray="8,6" opacity="0.7" />       </svg>     </div>`;
}).join('\n');
return `<div style="display:flex;flex-wrap:wrap">${items}</div>`;
}

export async function exportPdfReport(matchId: string, args: {
points: Array<{ rx:number; ry:number; kind:'win'|'loss' }>;
zoneStat: Record<string,{ win:number; loss:number }>;
metaStat: Array<{ shot?:string; force?:string; reason?:string; count:number }>;
shotAgg?: Array<{ label:string; win:number; loss:number }>;
routesSample?: Array<{ sx:number; sy:number; ex:number; ey:number; kind:'win'|'loss' }>;
}): Promise<{ path: string; cancelled: boolean } | void> {
try {
const svg = courtSvg(305, 670, args.points);
const zoneHtml = (() => {
const keys = Object.keys(args.zoneStat);
keys.sort();
const rows = keys.map(k => `<tr><td>${k}</td><td>${args.zoneStat[k].win}</td><td>${args.zoneStat[k].loss}</td></tr>`).join('\n');
return `<table><tr><th>區</th><th>得分</th><th>失分</th></tr>${rows}</table>`;
})();
const metaHtml = args.metaStat.map(m => `<tr><td>${esc(m.shot||'')}</td><td>${esc(m.force||'')}</td><td>${esc(m.reason||'')}</td><td>${m.count}</td></tr>`).join('\n');
const barHtml = args.shotAgg && args.shotAgg.length ? shotBarHtml(args.shotAgg) : '';
const thumbs = args.routesSample && args.routesSample.length ? routeThumbs(args.routesSample.slice(0,12), 4, 140) : '';

const html =
  `<html><head><meta charset="utf-8"/><style>
    body{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;padding:16px;}
    h1{font-size:20px;margin:0 0 8px 0;} h2{font-size:16px;margin:16px 0 8px 0;}
    table{border-collapse:collapse;width:100%;} td,th{border:1px solid #ddd;padding:6px;}
  </style></head><body>
    <h1>Badminton Report</h1>
    <div style="display:flex;gap:16px;align-items:flex-start">
      <div>${svg}</div>
      <div style="flex:1">
        <h2>區域統計</h2>${zoneHtml}
        <h2 style="margin-top:12px">球種 × 主/受迫 × 原因</h2><table>
          <tr><th>球種</th><th>主/受迫</th><th>原因</th><th>次數</th></tr>${metaHtml}
        </table>
        ${barHtml ? '<h2 style="margin-top:12px">球種分布（得/失）</h2>'+barHtml : ''}
      </div>
    </div>
    ${thumbs ? '<h2>球路縮圖（前 12 球）</h2>'+thumbs : ''}
  </body></html>`;

const convert = getPdfConvert();
if (typeof convert !== 'function') {
  throw new Error('RNHTMLtoPDF 不可用（模組未連結或尚未重編譯）');
}

const directory = Platform.OS === 'android' ? 'Download' : 'Documents';
const fileBase = `match-${String(matchId).replace(/[^a-zA-Z0-9_-]/g,'-')}-${Date.now()}`;

const res = await convert({
  html,
  fileName: fileBase,
  base64: false,
  directory,
});

const rawPath = res?.filePath;
if (!rawPath) throw new Error('PDF 產生失敗（未取得檔案路徑）');

const url = rawPath.startsWith('file://') ? rawPath : `file://${rawPath}`;
await Share.open({
  url,
  type: 'application/pdf',
  filename: `${fileBase}.pdf`,
  failOnCancel: false,
  showAppsToView: true,
});

return { path: url, cancelled: false };
} catch (err: any) {
throw new Error(err?.message || String(err));
}
}ezbmt-tracked/src/lib/exportPdf.ts
 
import { Platform } from 'react-native';
import RNFS from 'react-native-fs';
import Share, { ShareOptions } from 'react-native-share';
function getCacheDir(): string {
return RNFS.CachesDirectoryPath;
}
function buildName(matchId: string, ext: string): string {
const ts = String(Date.now());
const safeId = String(matchId).replace(/[^a-zA-Z0-9_-]/g, '-');
return 'match-' + safeId + '-' + ts + '.' + ext;
}
async function writeAndShare(path: string, mime: string, filename: string): Promise<void> {
const opts: ShareOptions = {
url: 'file://' + path,
type: mime,
filename: filename,
failOnCancel: false,
showAppsToView: true
};
try {
await Share.open(opts);
} catch (e: any) {
const msg = e && e.message ? String(e.message).toLowerCase() : String(e).toLowerCase();
if (msg.indexOf('cancel') >= 0) return;
throw e;
}
}
export async function shareCsv(matchId: string, csvText: string): Promise<void> {
const dir = getCacheDir();
const name = buildName(matchId, 'csv');
const path = dir + '/' + name;
const text = String(csvText == null ? '' : csvText);
try {
await RNFS.writeFile(path, text, 'utf8');
} catch (_e) {
const exists = await RNFS.exists(dir);
if (!exists) await RNFS.mkdir(dir);
await RNFS.writeFile(path, text, 'utf8');
}
await writeAndShare(path, 'text/csv', name);
}
export async function shareJson(matchId: string, jsonObj: any): Promise<void> {
let text = '';
try { text = JSON.stringify(jsonObj == null ? {} : jsonObj, null, 2); } catch (_e) { text = '{}'; }
const dir = getCacheDir();
const name = buildName(matchId, 'json');
const path = dir + '/' + name;
try {
await RNFS.writeFile(path, text, 'utf8');
} catch (_e) {
const exists = await RNFS.exists(dir);
if (!exists) await RNFS.mkdir(dir);
await RNFS.writeFile(path, text, 'utf8');
}
await writeAndShare(path, 'application/json', name);
}
ezbmt-tracked/src/lib/supabase.ts
 
import { createClient, type SupabaseClient } from '@supabase/supabase-js';
import AsyncStorage from '@react-native-async-storage/async-storage';
export const supa = createClient("https://uejjamgowybupzwsjctk.supabase.co", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVlamphbWdvd3lidXB6d3NqY3RrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTczOTgxMjEsImV4cCI6MjA3Mjk3NDEyMX0.MtkQ7RGDq883ZecG3OxG6-ImsnZfD4QBLZpNYW7DWy8", { auth: { persistSession: true, autoRefreshToken: true } });
/* Events */
export const SUPABASE_URL="https://uejjamgowybupzwsjctk.supabase.co";
export async function insertEvent(e: { id?: string; name: string; level?: string; venue?: string; start_at?: string; end_at?: string; }) {
const { data, error } = await supa.from('events').insert({
id: e.id, name: e.name, level: e.level ?? null, venue: e.venue ?? null,
start_at: e.start_at ?? null, end_at: e.end_at ?? null,
}).select('id').single();
if (error) throw error;
return data.id;
}
export async function listEvents(): Promise<Array<{ id: string; name: string }>> {
const { data, error } = await supa.from('events').select('id,name').order('name', { ascending: true });
if (error) throw error;
return data || [];
}

/* Matches */
export async function insertMatch(m: { id?: string; event_id: string; type: string; court_no?: string; rules_json?: string; }) {
const rules = m.rules_json ? JSON.parse(m.rules_json) : null;
const { error } = await supa.from('matches').insert({
id: m.id, event_id: m.event_id, type: m.type, court_no: m.court_no ?? null, rules_json: rules,
});
if (error) throw error;
}
export async function listMatches(eventId: string) {
const { data, error } = await supa.from('matches')
.select('id,type,court_no,rules_json,record_mode')
.eq('event_id', eventId)
.order('created_at', { ascending: false });
if (error) throw error;
return data || [];
}
export async function updateMatchRules(matchId: string, rulesJson: string) {
const { error } = await supa.from('matches').update({ rules_json: JSON.parse(rulesJson) }).eq('id', matchId);
if (error) throw error;
}
export async function setMatchRecordMode(matchId: string, mode: 'tap' | 'route') {
const { error } = await supa.from('matches').update({ record_mode: mode }).eq('id', matchId);
if (error) throw error;
}
export async function saveMatchState(matchId: string, stateJson: string) {
const { error } = await supa.from('matches').update({ state_json: JSON.parse(stateJson) }).eq('id', matchId);
if (error) throw error;
}
export async function getMatch(matchId: string) {
const { data, error } = await supa.from('matches').select('*').eq('id', matchId).single();
if (error) throw error;
return data;
}

/* Players */
export async function upsertMatchPlayers(args: {
matchId: string;
home: { idx: 0 | 1; name?: string; gender?: string; handedness?: string }[];
away: { idx: 0 | 1; name?: string; gender?: string; handedness?: string }[];
}) {
const all = [
...args.home.map(p => ({ ...p, side: 'home' })),
...args.away.map(p => ({ ...p, side: 'away' })),
];
for (const p of all) {
const { error } = await supa.from('match_players').upsert({
match_id: args.matchId, side: p.side, idx: p.idx,
name: p.name ?? null, gender: p.gender ?? null, handedness: p.handedness ?? null,
});
if (error) throw error;
}
}
export async function getMatchPlayers(matchId: string) {
const { data, error } = await supa.from('match_players')
.select('side, idx, name, gender, handedness')
.eq('match_id', matchId);
if (error) throw error;
return data || [];
}
export async function updateStartConfigs(args: {
matchId: string; startingServerTeam: 0 | 1; startingServerIndex: 0 | 1; homeRightWhenEven: 0 | 1; awayRightWhenEven: 0 | 1;
}) {
const { error } = await supa.from('matches').update({
starting_server_team: args.startingServerTeam,
starting_server_index: args.startingServerIndex,
home_right_when_even_index: args.homeRightWhenEven,
away_right_when_even_index: args.awayRightWhenEven,
}).eq('id', args.matchId);
if (error) throw error;
}

/* Rallies */
export async function insertRally(r: {
id: string; match_id: string; game_index: number; rally_no: number;
winner_side: string; end_zone: string; meta_json: string;
route_start_x?: number | null; route_start_y?: number | null;
route_end_x?: number | null; route_end_y?: number | null;
route_start_rx?: number | null; route_start_ry?: number | null;
route_end_rx?: number | null; route_end_ry?: number | null;
created_at: string;
}) {
const { error } = await supa.from('rallies').insert({
id: r.id, match_id: r.match_id, game_index: r.game_index, rally_no: r.rally_no,
winner_side: r.winner_side, end_zone: r.end_zone,
meta_json: r.meta_json ? JSON.parse(r.meta_json) : null,
route_start_x: r.route_start_x ?? null, route_start_y: r.route_start_y ?? null,
route_end_x: r.route_end_x ?? null, route_end_y: r.route_end_y ?? null,
route_start_rx: r.route_start_rx ?? null, route_start_ry: r.route_start_ry ?? null,
route_end_rx: r.route_end_rx ?? null, route_end_ry: r.route_end_ry ?? null,
created_at: r.created_at,
});
if (error) throw error;
}
export async function listRecentRallies(matchId: string, limit = 20) {
const { data, error } = await supa.from('rallies').select('*').eq('match_id', matchId).order('created_at', { ascending: false }).limit(limit);
if (error) throw error; return data || [];
}
export async function listRalliesOrdered(matchId: string) {
const { data, error } = await supa.from('rallies').select('*').eq('match_id', matchId)
.order('game_index', { ascending: true }).order('rally_no', { ascending: true });
if (error) throw error; return data || [];
}
export async function getLastRally(matchId: string) {
const { data, error } = await supa.from('rallies').select('*').eq('match_id', matchId)
.order('created_at', { ascending: false }).limit(1);
if (error) throw error;
return data && data.length ? data[0] : null;
}
export async function deleteRally(id: string) {
const { error } = await supa.from('rallies').delete().eq('id', id);
if (error) throw error;
}

/* Games summary */
export async function upsertGameSummary(args: {
matchId: string; gameIndex: number;
home: number; away: number;
winnerTeam: 0 | 1 | null;
intervalTaken: boolean; deciderSwitched: boolean;
}) {
// 以 UPSERT 模擬 SQLite 的 upsert 行為
const id = cryptoRandomId(args.matchId + '-g' + args.gameIndex);
const { error } = await supa.from('games').upsert({
id,
match_id: args.matchId,
index_no: args.gameIndex,
home_score: args.home,
away_score: args.away,
winner_team: args.winnerTeam,
interval_taken: args.intervalTaken,
decider_sides_switched: args.deciderSwitched,
}, { onConflict: 'match_id,index_no' });
if (error) throw error;
}
function cryptoRandomId(seed: string) {
// 產生穩定 id（非必要，亦可直接讓 DB 自動生成）
return seed;
}

/* Chat */
export async function insertChatMessage(args: { matchId: string; user?: string; text: string; createdAt?: string }) {
const { error } = await supa.from('chat_messages').insert({
match_id: args.matchId,
user_name: args.user ?? null,
text: args.text,
created_at: args.createdAt ?? new Date().toISOString(),
});
if (error) throw error;
}
export async function listChatMessages(matchId: string, limit = 200) {
const { data, error } = await supa.from('chat_messages').select('*').eq('match_id', matchId).order('created_at', { ascending: false }).limit(limit);
if (error) throw error; return data || [];
}

/* Media */
export async function insertMedia(m: { id?: string; owner_type: 'event'|'match'; owner_id: string; kind: 'youtube'|'photo'; url: string; description?: string }) {
const { error } = await supa.from('media').insert({
id: m.id, owner_type: m.owner_type, owner_id: m.owner_id, kind: m.kind,
url: m.url, description: m.description ?? null,
});
if (error) throw error;
}
export async function listMedia(owner_type: 'event'|'match', owner_id: string) {
const { data, error } = await supa.from('media').select('*').eq('owner_type', owner_type).eq('owner_id', owner_id).order('created_at', { ascending: false });
if (error) throw error; return data || [];
}
export async function deleteMedia(id: string) {
const { error } = await supa.from('media').delete().eq('id', id);
if (error) throw error;
}

/* Dictionaries */
export async function listDictionary(kind: 'shot_type'|'error_reason') {
const { data, error } = await supa.from('dictionaries')
.select('id,label,value,order_no').eq('kind', kind)
.order('order_no', { ascending: true }).order('label', { ascending: true });
if (error) throw error; return data || [];
}
export async function upsertDictionary(item: { id?: string; kind:'shot_type'|'error_reason'; label:string; value?:string; order_no?:number }) {
const { error } = await supa.from('dictionaries').upsert({
id: item.id, kind: item.kind, label: item.label, value: item.value ?? item.label, order_no: item.order_no ?? 0,
});
if (error) throw error;
}
export async function deleteDictionary(id: string) {
const { error } = await supa.from('dictionaries').delete().eq('id', id);
if (error) throw error;
}

/* Live/Replay 補充 */
export async function getRalliesByIds(ids: string[]): Promise<any[]> {
if (!ids || !ids.length) return [];
const { data, error } = await supa.from('rallies').select('*').in('id', ids);
if (error) throw error;
const out = data || [];
out.sort((a: any, b: any) => (a.game_index === b.game_index ? (a.rally_no - b.rally_no) : (a.game_index - b.game_index)));
return out;
}

export async function getCurrentUser() {
const { data, error } = await supa.auth.getUser();
if (error) return null;
return data.user || null;
}

ezbmt-tracked/src/lib/backend.ts
 
export type Backend = 'sqlite' | 'supabase';
export const BACKEND: Backend = 'supabase'; // 調整這行即可切換
ezbmt-tracked/src/lib/supabase_bak.ts
 
export type LiveSnapshot = {
scoreA: number; scoreB: number;
servingTeam: 0|1;
server?: { team:0|1; index:0|1; court:'R'|'L' };
receiver?: { team:0|1; index:0|1; court:'R'|'L' };
players?: Array<{ name?: string }>;
};

export const supa = null;

export async function publishLiveState(_matchId: string, _snap: LiveSnapshot) {
// no-op
}
export function subscribeLive(_matchId: string, _onState: (s: LiveSnapshot) => void) {
return { unsubscribe(){} };
}

export async function publishChat(_matchId: string, _msg: { user?: string; text: string }) {
// no-op
}
export function subscribeChat(_matchId: string, _onMsg: (m: { user?: string; text: string; created_at: string }) => void) {
return { unsubscribe(){} };
}
ezbmt-tracked/src/lib/sync.ts
 
import { listSyncQueue, removeSyncItem, bumpSyncRetry } from '../db';
import { insertRally, insertChatMessage, insertMedia } from '../db'; // supabase 版
import { supa } from './supabase';
import { getSignedUploadUrl, uploadToSignedUrl, getPublicUrl } from './storage';

let timer: any = null;

export function startSyncLoop() {
if (timer) return;
timer = setInterval(runOnce, 10_000); // 每 10 秒
runOnce().catch(()=>{});
}
export function stopSyncLoop() { if (timer) { clearInterval(timer); timer = null; } }

async function runOnce() {
const { data } = await supa.auth.getUser();
if (!data?.user) return; // 未登入不送
const batch = await listSyncQueue(30);
for (const item of batch) {
try {
const payload = JSON.parse(item.payload_json || '{}');
await pushOne(item.kind, payload);
await removeSyncItem(item.id);
} catch (_e) {
await bumpSyncRetry(item.id);
// 可選: 若 retries 超過某值則丟棄或上報
}
}
}

async function pushOne(kind: string, payload: any) {
if (kind === 'rally') {
await insertRally(payload); // payload 需符合 supa.insertRally 的欄位
} else if (kind === 'chat') {
await insertChatMessage(payload);
} else if (kind === 'media') {
// payload: { matchId, local: { base64?:string, arrayBuffer?:ArrayBuffer }, mime, ext, description? }
const { matchId, base64, mime, ext, description } = payload;
const { path, signedUrl } = await getSignedUploadUrl(matchId, ext, mime);
const buf = base64ToArrayBuffer(base64 || '');
await uploadToSignedUrl(signedUrl, buf, mime);
const publicUrl = getPublicUrl(path);
await insertMedia({ owner_type:'match', owner_id:matchId, kind:'photo', url: publicUrl, description });
}
}

function base64ToArrayBuffer(b64: string): ArrayBuffer {
const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
let str = b64.replace(/[^A-Za-z0-9+/=]/g, '');
let i = 0; let len = str.length; let bufferLength = len * 0.75;
if (str[str.length-1] === '=') bufferLength--;
if (str[str.length-2] === '=') bufferLength--;
const bytes = new Uint8Array(bufferLength);
while (i < len) {
const enc1 = chars.indexOf(str[i++]); const enc2 = chars.indexOf(str[i++]);
const enc3 = chars.indexOf(str[i++]); const enc4 = chars.indexOf(str[i++]);
const n = (enc1 << 18) | (enc2 << 12) | ((enc3 & 63) << 6) | (enc4 & 63);
bytes[(i/43)-3] = (n >> 16) & 255; if (enc3 !== 64) bytes[(i/43)-2] = (n >> 8) & 255; if (enc4 !== 64) bytes[(i/4*3)-1] = n & 255;
}
return bytes.buffer;
}

ezbmt-tracked/src/db/sqlite.ts
 
import SQLite, { SQLiteDatabase } from 'react-native-sqlite-storage';

SQLite.enablePromise(true);

let db: SQLiteDatabase | null = null;

export async function openDB() {
if (db) return db;
db = await SQLite.openDatabase({ name: 'badminton.db', location: 'default' });
await migrate(db);
return db;
}

async function migrate(d: SQLiteDatabase) {
await d.executeSql('CREATE TABLE IF NOT EXISTS meta (k TEXT PRIMARY KEY, v INTEGER)');
const [res] = await d.executeSql('SELECT v FROM meta WHERE k="schema_version"');
const cur = res.rows.length ? (res.rows.item(0).v as number) : 0;

if (cur < 1) {
const sqlEvents = [
'CREATE TABLE IF NOT EXISTS events (',
'  id TEXT PRIMARY KEY,',
'  name TEXT NOT NULL,',
'  level TEXT,',
'  venue TEXT,',
'  start_at TEXT,',
'  end_at TEXT',
')',
].join('\n');

const sqlMatches = [
  'CREATE TABLE IF NOT EXISTS matches (',
  '  id TEXT PRIMARY KEY,',
  '  event_id TEXT NOT NULL,',
  '  type TEXT NOT NULL,',
  '  court_no TEXT,',
  '  rules_json TEXT,',
  '  created_at TEXT',
  ')',
].join('\n');

const sqlRallies = [
  'CREATE TABLE IF NOT EXISTS rallies (',
  '  id TEXT PRIMARY KEY,',
  '  match_id TEXT NOT NULL,',
  '  game_index INTEGER,',
  '  rally_no INTEGER,',
  '  winner_side TEXT,',
  '  end_zone TEXT,',
  '  meta_json TEXT,',
  '  route_start_x REAL, route_start_y REAL,',
  '  route_end_x REAL,   route_end_y REAL,',
  '  created_at TEXT',
  ')',
].join('\n');

await d.executeSql(sqlEvents);
await d.executeSql(sqlMatches);
await d.executeSql(sqlRallies);
await d.executeSql('REPLACE INTO meta(k,v) VALUES("schema_version",1)');
}

if (cur < 2) {
const sqlGames = [
'CREATE TABLE IF NOT EXISTS games (',
'  id TEXT PRIMARY KEY,',
'  match_id TEXT NOT NULL,',
'  index_no INTEGER NOT NULL,',
'  home_score INTEGER NOT NULL,',
'  away_score INTEGER NOT NULL,',
'  winner_team INTEGER,',
'  interval_taken INTEGER DEFAULT 0,',
'  decider_sides_switched INTEGER DEFAULT 0,',
'  created_at TEXT,',
'  updated_at TEXT,',
'  UNIQUE (match_id, index_no)',
')',
].join('\n');
await d.executeSql(sqlGames);
try { await d.executeSql('ALTER TABLE matches ADD COLUMN state_json TEXT'); } catch (_) {}
await d.executeSql('REPLACE INTO meta(k,v) VALUES("schema_version",2)');
}

if (cur < 3) {
const sqlMatchPlayers = [
'CREATE TABLE IF NOT EXISTS match_players (',
'  match_id TEXT NOT NULL,',
'  side TEXT NOT NULL,',
'  idx INTEGER NOT NULL,',
'  name TEXT, gender TEXT, handedness TEXT,',
'  PRIMARY KEY (match_id, side, idx),',
'  FOREIGN KEY (match_id) REFERENCES matches(id)',
')',
].join('\n');

await d.executeSql(sqlMatchPlayers);
try { await d.executeSql('ALTER TABLE matches ADD COLUMN starting_server_team INTEGER'); } catch (_) {}
try { await d.executeSql('ALTER TABLE matches ADD COLUMN starting_server_index INTEGER'); } catch (_) {}
try { await d.executeSql('ALTER TABLE matches ADD COLUMN home_right_when_even_index INTEGER'); } catch (_) {}
try { await d.executeSql('ALTER TABLE matches ADD COLUMN away_right_when_even_index INTEGER'); } catch (_) {}

await d.executeSql('REPLACE INTO meta(k,v) VALUES("schema_version",3)');
}

    if (cur < 4) {
    try { await d.executeSql('ALTER TABLE matches ADD COLUMN record_mode TEXT DEFAULT "tap"'); } catch (_e) {}
    try { await d.executeSql('ALTER TABLE rallies ADD COLUMN route_start_rx REAL'); } catch (_e) {}
    try { await d.executeSql('ALTER TABLE rallies ADD COLUMN route_start_ry REAL'); } catch (_e) {}
    try { await d.executeSql('ALTER TABLE rallies ADD COLUMN route_end_rx REAL'); } catch (_e) {}
    try { await d.executeSql('ALTER TABLE rallies ADD COLUMN route_end_ry REAL'); } catch (_e) {}
    await d.executeSql('REPLACE INTO meta(k,v) VALUES("schema_version",4)');
    }

if (cur < 5) {
await d.executeSql([
'CREATE TABLE IF NOT EXISTS chat_messages (',
'  id TEXT PRIMARY KEY,',
'  match_id TEXT NOT NULL,',
'  user TEXT,',
'  text TEXT,',
'  created_at TEXT',
')'
].join('\n'));

await d.executeSql([
  'CREATE TABLE IF NOT EXISTS media (',
  '  id TEXT PRIMARY KEY,',
  '  owner_type TEXT NOT NULL,',
  '  owner_id TEXT NOT NULL,',
  '  kind TEXT NOT NULL,',
  '  url TEXT NOT NULL,',
  '  description TEXT,',
  '  created_at TEXT',
  ')'
].join('\n'));
    await d.executeSql('REPLACE INTO meta(k,v) VALUES("schema_version",5)');
    }
    
    if (cur < 6) {
    await d.executeSql([
    'CREATE TABLE IF NOT EXISTS dictionaries (',
    '  id TEXT PRIMARY KEY,',
    '  kind TEXT NOT NULL,',      // 'shot_type' | 'error_reason'
    '  label TEXT NOT NULL,',     // 顯示文字
    '  value TEXT,',              // 可選（等同 label）
    '  order_no INTEGER DEFAULT 0,',
    '  created_at TEXT',
    ')'
    ].join('\n'));

    // 預設種子資料（若需要）
    const now = new Date().toISOString();
    const seed = (id: string, kind: string, label: string, order: number) =>
    d.executeSql('INSERT OR IGNORE INTO dictionaries (id,kind,label,value,order_no,created_at) VALUES (?,?,?,?,?,?)',
    [id, kind, label, label, order, now]);

    // shot_type
    await seed('st-1','shot_type','切球',1);
    await seed('st-2','shot_type','網前',2);
    await seed('st-3','shot_type','封網',3);
    await seed('st-4','shot_type','殺球',4);
    await seed('st-5','shot_type','高遠球',5);
    await seed('st-6','shot_type','挑球及推後場',6);
    await seed('st-7','shot_type','過渡',7);
    await seed('st-8','shot_type','平抽',8);
    await seed('st-9','shot_type','發球',9);

    // error_reason
    await seed('er-1','error_reason','出界',1);
    await seed('er-2','error_reason','掛網',2);
    await seed('er-3','error_reason','質量不好',3);
    await seed('er-4','error_reason','發球失誤',4);

    await d.executeSql('REPLACE INTO meta(k,v) VALUES("schema_version",6)');
    }

    if (cur < 7) {
    // rallies 索引
    try { await d.executeSql('CREATE INDEX IF NOT EXISTS idx_rallies_match ON rallies(match_id)'); } catch (_e) {}
    try { await d.executeSql('CREATE INDEX IF NOT EXISTS idx_rallies_match_game ON rallies(match_id, game_index)'); } catch (_e) {}
    try { await d.executeSql('CREATE INDEX IF NOT EXISTS idx_rallies_match_created ON rallies(match_id, datetime(created_at))'); } catch (_e) {}

    // chat 索引
    try { await d.executeSql('CREATE INDEX IF NOT EXISTS idx_chat_match_created ON chat_messages(match_id, datetime(created_at))'); } catch (_e) {}

    await d.executeSql('REPLACE INTO meta(k,v) VALUES("schema_version",7)');
    }
    
    if (cur < 8) {
    await d.executeSql([
    'CREATE TABLE IF NOT EXISTS sync_queue (',
    '  id TEXT PRIMARY KEY,',
    '  kind TEXT NOT NULL,',        // rally | chat | media
    '  payload_json TEXT NOT NULL,',// 要推送的 JSON 字串
    '  created_at TEXT,',
    '  retries INTEGER DEFAULT 0',
    ')'
    ].join('\n'));
    await d.executeSql('REPLACE INTO meta(k,v) VALUES("schema_version",8)');
    }

    if (cur < 9) {
await d.executeSql([
'CREATE TABLE IF NOT EXISTS speed_sessions (',
'  id TEXT PRIMARY KEY,',
'  note TEXT,',
'  unit TEXT DEFAULT "kmh",', // 'kmh' | 'mph'
'  created_at TEXT',
')'
].join('\n'));
await d.executeSql([
'CREATE TABLE IF NOT EXISTS speed_points (',
'  id TEXT PRIMARY KEY,',
'  session_id TEXT NOT NULL,',
'  idx INTEGER NOT NULL,',
'  rx REAL NOT NULL,',
'  ry REAL NOT NULL,',
'  ts_ms INTEGER NOT NULL,',
'  FOREIGN KEY (session_id) REFERENCES speed_sessions(id)',
')'
].join('\n'));
try { await d.executeSql('CREATE INDEX IF NOT EXISTS idx_speed_points_session ON speed_points(session_id, idx)'); } catch (_e) {}
await d.executeSql('REPLACE INTO meta(k,v) VALUES("schema_version",9)');
}

}

/* DAO 基本 */

export async function insertEvent(e: {
  id: string; name: string; level?: string; venue?: string; start_at?: string; end_at?: string;
}) {
  const d = await openDB();
  await d.executeSql(
    'INSERT INTO events (id,name,level,venue,start_at,end_at) VALUES (?,?,?,?,?,?)',
    [e.id, e.name, e.level || null, e.venue || null, e.start_at || null, e.end_at || null]
  );
}

export async function listEvents(): Promise<Array<{ id: string; name: string }>> {
  const d = await openDB();
  const [res] = await d.executeSql('SELECT id,name FROM events ORDER BY name ASC');
  const out: any[] = [];
  for (let i = 0; i < res.rows.length; i++) out.push(res.rows.item(i));
  return out;
}

export async function insertMatch(m: {
  id: string; event_id: string; type: string; court_no?: string; rules_json?: string;
}) {
  const d = await openDB();
  await d.executeSql(
    'INSERT INTO matches (id,event_id,type,court_no,rules_json,created_at) VALUES (?,?,?,?,?,?)',
    [m.id, m.event_id, m.type, m.court_no || null, m.rules_json || null, new Date().toISOString()]
  );
}

export async function listMatches(eventId: string): Promise<Array<{ id: string; type: string; court_no: string | null; rules_json: string | null; record_mode?: string | null }>> {
  const d = await openDB();
  const [res] = await d.executeSql(
    'SELECT id,type,court_no,rules_json,record_mode FROM matches WHERE event_id=? ORDER BY datetime(created_at) DESC',
    [eventId]
  );
  const out: any[] = [];
  for (let i = 0; i < res.rows.length; i++) out.push(res.rows.item(i));
  return out;
}

export async function updateMatchRules(matchId: string, rulesJson: string) {
  const d = await openDB();
  await d.executeSql('UPDATE matches SET rules_json=? WHERE id=?', [rulesJson, matchId]);
}

export async function setMatchRecordMode(matchId: string, mode: 'tap' | 'route') {
  const d = await openDB();
  await d.executeSql('UPDATE matches SET record_mode=? WHERE id=?', [mode, matchId]);
}

export async function saveMatchState(matchId: string, stateJson: string) {
  const d = await openDB();
  await d.executeSql('UPDATE matches SET state_json=? WHERE id=?', [stateJson, matchId]);
}

/* Players */

export async function upsertMatchPlayers(args: {
  matchId: string;
  home: { idx: 0 | 1; name?: string; gender?: string; handedness?: string }[];
  away: { idx: 0 | 1; name?: string; gender?: string; handedness?: string }[];
}) {
  const d = await openDB();
  const all = [
    ...args.home.map(p => ({ ...p, side: 'home' })),
    ...args.away.map(p => ({ ...p, side: 'away' })),
  ];
  for (const p of all) {
    await d.executeSql(
      'REPLACE INTO match_players (match_id,side,idx,name,gender,handedness) VALUES (?,?,?,?,?,?)',
      [args.matchId, p.side, p.idx, p.name || null, p.gender || null, p.handedness || null]
    );
  }
}

export async function getMatchPlayers(matchId: string): Promise<Array<{ side: 'home' | 'away'; idx: 0 | 1; name: string | null; gender: string | null; handedness: string | null }>> {
  const d = await openDB();
  const [res] = await d.executeSql('SELECT side, idx, name, gender, handedness FROM match_players WHERE match_id=?', [matchId]);
  const out: any[] = [];
  for (let i = 0; i < res.rows.length; i++) out.push(res.rows.item(i));
  return out as any;
}

export async function updateStartConfigs(args: {
  matchId: string;
  startingServerTeam: 0 | 1;
  startingServerIndex: 0 | 1;
  homeRightWhenEven: 0 | 1;
  awayRightWhenEven: 0 | 1;
}) {
  const d = await openDB();
  await d.executeSql(
    'UPDATE matches SET starting_server_team=?, starting_server_index=?, home_right_when_even_index=?, away_right_when_even_index=? WHERE id=?',
    [args.startingServerTeam, args.startingServerIndex, args.homeRightWhenEven, args.awayRightWhenEven, args.matchId]
  );
}

/* Rallies */

export async function insertRally(r: {
  id: string; match_id: string; game_index: number; rally_no: number;
  winner_side: string; end_zone: string; meta_json: string;
  route_start_x?: number | null; route_start_y?: number | null;
  route_end_x?: number | null; route_end_y?: number | null;
  route_start_rx?: number | null; route_start_ry?: number | null;
  route_end_rx?: number | null; route_end_ry?: number | null;
  created_at: string;
}) {
  const d = await openDB();
  await d.executeSql(
    'INSERT INTO rallies (id,match_id,game_index,rally_no,winner_side,end_zone,meta_json,route_start_x,route_start_y,route_end_x,route_end_y,route_start_rx,route_start_ry,route_end_rx,route_end_ry,created_at) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
    [
      r.id, r.match_id, r.game_index, r.rally_no, r.winner_side, r.end_zone, r.meta_json,
      r.route_start_x ?? null, r.route_start_y ?? null, r.route_end_x ?? null, r.route_end_y ?? null,
      r.route_start_rx ?? null, r.route_start_ry ?? null, r.route_end_rx ?? null, r.route_end_ry ?? null,
      r.created_at,
    ]
  );
}

export async function listRecentRallies(matchId: string, limit = 20) {
  const d = await openDB();
  const [res] = await d.executeSql(
    'SELECT * FROM rallies WHERE match_id=? ORDER BY datetime(created_at) DESC LIMIT ?',
    [matchId, limit]
  );
  const out: any[] = [];
  for (let i = 0; i < res.rows.length; i++) out.push(res.rows.item(i));
  return out;
}

export async function listRalliesOrdered(matchId: string) {
  const d = await openDB();
  const [res] = await d.executeSql(
    'SELECT * FROM rallies WHERE match_id=? ORDER BY game_index, rally_no',
    [matchId]
  );
  const out: any[] = [];
  for (let i = 0; i < res.rows.length; i++) out.push(res.rows.item(i));
  return out;
}

export async function getLastRally(matchId: string) {
  const d = await openDB();
  const [res] = await d.executeSql(
    'SELECT * FROM rallies WHERE match_id=? ORDER BY datetime(created_at) DESC LIMIT 1',
    [matchId]
  );
  return res.rows.length ? res.rows.item(0) : null;
}

export async function deleteRally(rallyId: string) {
  const d = await openDB();
  await d.executeSql('DELETE FROM rallies WHERE id=?', [rallyId]);
}

export async function getMatch(matchId: string) {
  const d = await openDB();
  const [res] = await d.executeSql('SELECT * FROM matches WHERE id=?', [matchId]);
  return res.rows.length ? res.rows.item(0) : null;
}

export async function upsertGameSummary(args: {
  matchId: string; gameIndex: number;
  home: number; away: number;
  winnerTeam: 0 | 1 | null;
  intervalTaken: boolean; deciderSwitched: boolean;
}) {
  const d = await openDB();
  const id = args.matchId + '-g' + args.gameIndex;
  const now = new Date().toISOString();
  const [res] = await d.executeSql('SELECT id FROM games WHERE id=?', [id]);
  if (res.rows.length) {
    await d.executeSql(
      'UPDATE games SET home_score=?, away_score=?, winner_team=?, interval_taken=?, decider_sides_switched=?, updated_at=? WHERE id=?',
      [args.home, args.away, args.winnerTeam, args.intervalTaken ? 1 : 0, args.deciderSwitched ? 1 : 0, now, id]
    );
  } else {
    await d.executeSql(
      'INSERT INTO games (id,match_id,index_no,home_score,away_score,winner_team,interval_taken,decider_sides_switched,created_at,updated_at) VALUES (?,?,?,?,?,?,?,?,?,?)',
      [id, args.matchId, args.gameIndex, args.home, args.away, args.winnerTeam, args.intervalTaken ? 1 : 0, args.deciderSwitched ? 1 : 0, now, now]
    );
  }
}

export async function insertChatMessage(args: { matchId: string; user?: string; text: string; createdAt?: string }) {
const d = await openDB();
const id = Math.random().toString(36).slice(2);
const ts = args.createdAt || new Date().toISOString();
await d.executeSql(
'INSERT INTO chat_messages (id,match_id,user,text,created_at) VALUES (?,?,?,?,?)',
[id, args.matchId, args.user || null, args.text, ts]
);
}
export async function listChatMessages(matchId: string, limit = 200) {
const d = await openDB();
const [res] = await d.executeSql(
'SELECT * FROM chat_messages WHERE match_id=? ORDER BY datetime(created_at) DESC LIMIT ?',
[matchId, limit]
);
const out: any[] = []; for (let i=0;i<res.rows.length;i++) out.push(res.rows.item(i)); return out;
}

export async function insertMedia(m: { id?: string; owner_type: 'event'|'match'; owner_id: string; kind: 'youtube'|'photo'; url: string; description?: string }) {
const d = await openDB();
const id = m.id || Math.random().toString(36).slice(2);
await d.executeSql(
'INSERT INTO media (id,owner_type,owner_id,kind,url,description,created_at) VALUES (?,?,?,?,?,?,?)',
[id, m.owner_type, m.owner_id, m.kind, m.url, m.description || null, new Date().toISOString()]
);
}
export async function listMedia(owner_type: 'event'|'match', owner_id: string) {
const d = await openDB();
const [res] = await d.executeSql(
'SELECT * FROM media WHERE owner_type=? AND owner_id=? ORDER BY datetime(created_at) DESC',
[owner_type, owner_id]
);
const out: any[] = []; for (let i=0;i<res.rows.length;i++) out.push(res.rows.item(i)); return out;
}
export async function deleteMedia(id: string) {
const d = await openDB();
await d.executeSql('DELETE FROM media WHERE id=?', [id]);
}

export async function listDictionary(kind: 'shot_type'|'error_reason'): Promise<Array<{ id:string; label:string; value?:string; order_no:number }>> {
const d = await openDB();
const [res] = await d.executeSql('SELECT * FROM dictionaries WHERE kind=? ORDER BY order_no ASC, label ASC', [kind]);
const out:any[] = []; for (let i=0;i<res.rows.length;i++) out.push(res.rows.item(i));
return out;
}
export async function upsertDictionary(item: { id?: string; kind:'shot_type'|'error_reason'; label:string; value?:string; order_no?:number }) {
const d = await openDB();
const id = item.id || Math.random().toString(36).slice(2);
const now = new Date().toISOString();
await d.executeSql(
'REPLACE INTO dictionaries (id,kind,label,value,order_no,created_at) VALUES (?,?,?,?,?,?)',
[id, item.kind, item.label, item.value ?? item.label, item.order_no ?? 0, now]
);
}
export async function deleteDictionary(id: string) {
const d = await openDB();
await d.executeSql('DELETE FROM dictionaries WHERE id=?', [id]);
}

export async function getRalliesByIds(ids: string[]): Promise<any[]> {
  if (!ids || !ids.length) return [];
  const d = await openDB();
  const placeholders = ids.map(() => '?').join(',');
  const [res] = await d.executeSql(`SELECT * FROM rallies WHERE id IN (${placeholders})`, ids);
  const out: any[] = []; for (let i=0;i<res.rows.length;i++) out.push(res.rows.item(i));
  out.sort((a,b)=> (a.game_index===b.game_index ? (a.rally_no-b.rally_no) : (a.game_index-b.game_index)));
  return out;
}

export async function enqueueSync(item: { kind: 'rally'|'chat'|'media'; payload: any }) {
const d = await openDB();
const id = Math.random().toString(36).slice(2);
const ts = new Date().toISOString();
await d.executeSql(
'INSERT INTO sync_queue (id,kind,payload_json,created_at,retries) VALUES (?,?,?,?,?)',
[id, item.kind, JSON.stringify(item.payload || {}), ts, 0]
);
}
export async function listSyncQueue(limit = 50) {
const d = await openDB();
const [res] = await d.executeSql('SELECT * FROM sync_queue ORDER BY datetime(created_at) ASC LIMIT ?', [limit]);
const out:any[] = []; for (let i=0;i<res.rows.length;i++) out.push(res.rows.item(i));
return out;
}
export async function removeSyncItem(id: string) {
const d = await openDB();
await d.executeSql('DELETE FROM sync_queue WHERE id=?', [id]);
}
export async function bumpSyncRetry(id: string) {
const d = await openDB();
await d.executeSql('UPDATE sync_queue SET retries = retries + 1 WHERE id=?', [id]);
}

export async function insertSpeedSession(note?: string, unit: 'kmh'|'mph' = 'kmh') {
const d = await openDB();
const id = Math.random().toString(36).slice(2);
const now = new Date().toISOString();
await d.executeSql(
'INSERT INTO speed_sessions (id,note,unit,created_at) VALUES (?,?,?,?)',
[id, note || null, unit, now]
);
return id;
}
export async function insertSpeedPoints(sessionId: string, points: Array<{ idx:number; rx:number; ry:number; ts:number }>) {
const d = await openDB();
await d.executeSql('BEGIN');
try {
for (const p of points) {
const id = Math.random().toString(36).slice(2);
await d.executeSql(
'INSERT INTO speed_points (id,session_id,idx,rx,ry,ts_ms) VALUES (?,?,?,?,?,?)',
[id, sessionId, p.idx, p.rx, p.ry, p.ts]
);
}
await d.executeSql('COMMIT');
} catch (e) {
await d.executeSql('ROLLBACK');
throw e;
}
}
export async function listSpeedSessions(): Promise<Array<{ id:string; note?:string|null; unit:'kmh'|'mph'; created_at:string }>> {
const d = await openDB();
const [res] = await d.executeSql('SELECT * FROM speed_sessions ORDER BY datetime(created_at) DESC');
const out:any[] = [];
for (let i=0;i<res.rows.length;i++) out.push(res.rows.item(i));
return out as any;
}
export async function getSpeedSessionPoints(sessionId: string): Promise<Array<{ idx:number; rx:number; ry:number; ts_ms:number }>> {
const d = await openDB();
const [res] = await d.executeSql('SELECT idx,rx,ry,ts_ms FROM speed_points WHERE session_id=? ORDER BY idx ASC', [sessionId]);
const out:any[] = [];
for (let i=0;i<res.rows.length;i++) out.push(res.rows.item(i));
return out as any;
}
export async function deleteSpeedSession(sessionId: string) {
const d = await openDB();
await d.executeSql('BEGIN');
try {
await d.executeSql('DELETE FROM speed_points WHERE session_id=?', [sessionId]);
await d.executeSql('DELETE FROM speed_sessions WHERE id=?', [sessionId]);
await d.executeSql('COMMIT');
} catch (e) {
await d.executeSql('ROLLBACK');
throw e;
}
}

export async function hasEventMatches(eventId: string): Promise<boolean> {
  const d = await openDB();
  const [res] = await d.executeSql('SELECT COUNT(1) AS c FROM matches WHERE event_id=?', [eventId]);
  const c = res.rows.length ? Number(res.rows.item(0).c) : 0;
  return c > 0;
}
export async function deleteEvent(eventId: string): Promise<void> {
  const d = await openDB();
  await d.executeSql('DELETE FROM events WHERE id=?', [eventId]);
}

export async function hasMatchRallies(matchId: string): Promise<boolean> {
  const d = await openDB();
  const [res] = await d.executeSql('SELECT COUNT(1) AS c FROM rallies WHERE match_id=?', [matchId]);
  const c = res.rows.length ? Number(res.rows.item(0).c) : 0;
  return c > 0;
}
export async function deleteMatch(matchId: string): Promise<void> {
  const d = await openDB();
  await d.executeSql('BEGIN');
  try {
    await d.executeSql('DELETE FROM rallies WHERE match_id=?', [matchId]);
    await d.executeSql('DELETE FROM games WHERE match_id=?', [matchId]);
    await d.executeSql('DELETE FROM match_players WHERE match_id=?', [matchId]);
    await d.executeSql('DELETE FROM chat_messages WHERE match_id=?', [matchId]);
    await d.executeSql('DELETE FROM media WHERE owner_type=? AND owner_id=?', ['match', matchId]);
    await d.executeSql('DELETE FROM matches WHERE id=?', [matchId]);
    await d.executeSql('COMMIT');
  } catch (e) {
    await d.executeSql('ROLLBACK');
    throw e;
  }
}

export async function listGamesByMatch(matchId: string) {
  const d = await openDB();
  const [res] = await d.executeSql(
    'SELECT index_no,home_score,away_score,winner_team FROM games WHERE match_id=? ORDER BY index_no ASC',
    [matchId]
  );
  const out: any[] = [];
  for (let i=0;i<res.rows.length;i++) out.push(res.rows.item(i));
  return out;
}
ezbmt-tracked/src/db/supa_club.ts
 
import { supa } from '../lib/supabase';

export type SessionRow = {
id: string;
club_id?: string | null;
date: string;
start_at?: string | null;
end_at?: string | null;
courts: number;
round_minutes: number;
status: 'draft'|'ongoing'|'finished';
created_by: string;
created_at: string;
};

export type Attendee = {
id: string;
session_id: string;
user_id?: string|null;
buddy_id?: string|null;
display_name: string;
level?: number|null;
gender?: 'M'|'F'|'U'|null;
handedness?: 'L'|'R'|'U'|null;
checked_in: boolean;
arrive_at?: string|null;
leave_at?: string|null;
};

export type RoundRow = {
id: string;
session_id: string;
index_no: number;
start_at?: string|null;
end_at?: string|null;
status: 'planned'|'published'|'ongoing'|'finished';
meta?: any;
created_at: string;
};

export type RoundMatch = {
id: string;
round_id: string;
court_no: number;
team_a: any; // { players: [{id,name,level}], ... }
team_b: any;
result?: any;
created_at: string;
};

export async function insertSession(args: {
club_id?: string|null;
date: string; start_at?: string|null; end_at?: string|null;
courts: number; round_minutes: number;
status?: 'draft'|'ongoing'|'finished';
}): Promise<string> {
const { data, error } = await supa
.from('sessions')
.insert({
club_id: args.club_id ?? null,
date: args.date,
start_at: args.start_at ?? null,
end_at: args.end_at ?? null,
courts: args.courts,
round_minutes: args.round_minutes,
status: args.status ?? 'draft',
})
.select('id')
.single();
if (error) throw error;
return data!.id as string;
}

export async function listSessionsOfMe(): Promise<SessionRow[]> {
const { data, error } = await supa
.from('sessions')
.select('*')
.order('date', { ascending: false })
.limit(200);
if (error) throw error;
return (data || []) as SessionRow[];
}

export async function listSessionAttendees(sessionId: string) {
// A) 先嘗試從 view 讀（若你的 view 有 checked_in 就會帶回來）
try {
const { data, error } = await supa
.from('session_attendees_view')
.select('id,session_id,buddy_id,name,level,gender,handedness,checked_in')
.eq('session_id', sessionId)
.order('id', { ascending: true });
if (!error && data) {
return (data || []).map((r: any) => ({
id: r.id as string,
session_id: r.session_id as string,
buddy_id: (r.buddy_id ?? null) as string | null,
display_name: String(r.name || ''),
level: (r.level ?? null) as number | null,
gender: (r.gender ?? null) as 'M'|'F'|'U'|null,
handedness: (r.handedness ?? null) as 'L'|'R'|'U'|null,
checked_in: !!(r.checked_in ?? true), // 若 view 沒給，一律視為 true
}));
}
} catch {}

// B) 若 view 存在但沒有 checked_in 欄位，就用精簡欄位再試
try {
const { data, error } = await supa
.from('session_attendees_view')
.select('id,session_id,buddy_id,name,level,gender,handedness')
.eq('session_id', sessionId)
.order('id', { ascending: true });
if (!error && data) {
return (data || []).map((r: any) => ({
id: r.id as string,
session_id: r.session_id as string,
buddy_id: (r.buddy_id ?? null) as string | null,
display_name: String(r.name || ''),
level: (r.level ?? null) as number | null,
gender: (r.gender ?? null) as 'M'|'F'|'U'|null,
handedness: (r.handedness ?? null) as 'L'|'R'|'U'|null,
checked_in: true, // 沒欄位就預設已報到
}));
}
} catch {}

// C) 再退回查表（表沒有 checked_in 就不要 select 它）
const { data: raw, error: e2 } = await supa
.from('session_attendees')
.select('id,session_id,buddy_id')
.eq('session_id', sessionId)
.order('id', { ascending: true });
if (e2) throw e2;

const ids = (raw || []).map((r: any) => r.buddy_id).filter(Boolean);
const meta = new Map<string, { name?: string; level?: number|null; gender?: any; handedness?: any }>();
if (ids.length) {
const { data: bs } = await supa
.from('buddies')
.select('id,name,level,gender,handedness')
.in('id', ids as any);
(bs || []).forEach((b: any) =>
meta.set(b.id, {
name: b.name || '',
level: b.level ?? null,
gender: b.gender ?? null,
handedness: b.handedness ?? null,
}),
);
}

return (raw || []).map((r: any) => {
const b = meta.get(r.buddy_id) || {};
return {
id: r.id as string,
session_id: r.session_id as string,
buddy_id: (r.buddy_id ?? null) as string | null,
display_name: String(b.name || ''),
level: (b.level ?? null) as number | null,
gender: (b.gender ?? null) as 'M'|'F'|'U'|null,
handedness: (b.handedness ?? null) as 'L'|'R'|'U'|null,
checked_in: true, // 表沒有此欄，一律視為已報到
};
});
}



export async function upsertAttendee(a: Omit<Attendee,'id'|'created_at'> & { id?: string }) {
// 僅寫入實際存在於 table 的欄位（避免 checked_in）
const payload: any = {};
if ((a as any).id) payload.id = (a as any).id;
if ((a as any).session_id) payload.session_id = (a as any).session_id;
if ((a as any).buddy_id) payload.buddy_id = (a as any).buddy_id;
if ((a as any).user_id) payload.user_id = (a as any).user_id;

if (payload.id) {
const { error } = await supa.from('session_attendees').upsert(payload, { onConflict: 'id' });
if (error) throw error;
return;
}

// 無 id → 插入一筆（避免使用不存在的 onConflict 鍵）
const { error } = await supa.from('session_attendees').insert(payload);
if (error) throw error;
}

export async function removeAttendee(id: string) {
const { error } = await supa
.from('session_attendees')
.delete()
.eq('id', id);
if (error) throw error;
}

/** 呼叫 RPC: upsert_round */
export async function upsertRound(session_id: string, payload: {
index_no: number;
start_at?: string|null;
end_at?: string|null;
status?: 'planned'|'published'|'ongoing'|'finished';
matches: Array<{ court_no: number; team_a: any; team_b: any }>;
}): Promise<string> {
const { data, error } = await supa.rpc('upsert_round', {
p_session_id: session_id,
p_round: payload as any,
});
if (error) throw error;
return data as string; // round_id
}

export async function listRounds(session_id: string): Promise<Array<RoundRow & { matches: RoundMatch[] }>> {
// 只選一定存在的欄位，避免資料庫沒有的欄位（meta/start_at/end_at/created_at）造成 5xx
const { data: rounds, error: re } = await supa
.from('session_rounds')
.select('id, session_id, index_no, status')
.eq('session_id', session_id)
.order('index_no', { ascending: true });

if (re) throw re;
// 這裡用 any 承接，以免你的 RoundRow 型別還包含可選欄位時產生型別警告
const arr = (rounds || []) as any[];

// 批次撈每輪的 matches
const ids = arr.map(r => r.id);
if (!ids.length) return arr.map(r => ({ ...r, matches: [] }));

const { data: matches, error: me } = await supa
.from('round_matches')
.select('id, round_id, court_no, team_a, team_b, result')
.in('round_id', ids as any)
.order('court_no', { ascending: true });

if (me) throw me;

const map = new Map<string, RoundMatch[]>();
(matches || []).forEach((m: any) => {
const rid = String(m.round_id);
if (!map.has(rid)) map.set(rid, []);
map.get(rid)!.push(m as RoundMatch);
});

return arr.map(r => ({ ...r, matches: map.get(r.id) || [] }));
}

/** 投影看板/倒數 */
export async function listProjection(session_id: string): Promise<{
server_time: string;
now?: { index: number; start_at?: string|null; end_at?: string|null; matches: any[] } | null;
next?: { index: number; planned_start_at?: string|null; matchesPreview: any[] } | null;
}> {
const { data, error } = await supa.rpc('list_projection', { p_session_id: session_id });
if (error) throw error;
return data as any;
}

export async function setRoundStatus(
roundId: string,
status: 'planned'|'published'|'ongoing'|'finished'
): Promise<void> {
const { error } = await supa
.from('session_rounds')
.update({ status })
.eq('id', roundId);
if (error) throw error;
}

export async function listSignups(sessionId: string): Promise<Array<{ id:string; user_id:string; name?:string|null; email?:string|null; created_at:string }>> {
// 改用安全 RPC：list_signups_with_names
const { data, error } = await supa.rpc('list_signups_with_names', { p_session_id: sessionId });
if (error) throw error;

// 保底 fallback（極端狀況仍確保不出現「未命名」）
const rows = (data || []) as Array<{ id:string; user_id:string; name?:string|null; email?:string|null; created_at:string }>;
return rows.map(r => {
const safeName =
(r.name && String(r.name).trim()) ||
(r.email ? String(r.email).split('@')[0] : (r.user_id ? r.user_id.slice(0,8)+'…' : 'Anon'));
return { ...r, name: safeName };
});
}

export async function signupSession(sessionId: string): Promise<void> {
const { data: me } = await supa.auth.getUser();
const uid = me?.user?.id;
const uEmail = me?.user?.email || null;
if (!uid) throw new Error('Not logged in');

// 嘗試補 profiles 基本資料（若沒有 name，補 email 前綴；若沒有 email，補 auth 的 email）
try {
const { data: prof } = await supa
.from('profiles')
.select('id,name,email')
.eq('id', uid)
.maybeSingle();

let newName = (prof?.name && String(prof.name).trim()) || '';
let newEmail = (prof?.email && String(prof.email).trim()) || '';

if (!newName && uEmail) newName = uEmail.split('@')[0];
if (!newEmail && uEmail) newEmail = uEmail;

if ((newName && newName !== (prof?.name || '')) || (newEmail && newEmail !== (prof?.email || ''))) {
  await supa.from('profiles').upsert({ id: uid, name: newName || null, email: newEmail || null });
}
} catch {
// 若 RLS 限制或表結構不同，略過不拋錯
}

const { error } = await supa
.from('sessions_signups')
.insert({ session_id: sessionId, user_id: uid });
if (error) throw error;
}

export async function cancelSignup(sessionId: string): Promise<void> {
const { data: me } = await supa.auth.getUser();
const uid = me?.user?.id;
if (!uid) throw new Error('Not logged in');
const { error } = await supa.from('sessions_signups').delete().eq('session_id', sessionId).eq('user_id', uid);
if (error) throw error;
}

export async function deleteSignup(signupId: string): Promise<void> {
const { error } = await supa.from('sessions_signups').delete().eq('id', signupId);
if (error) throw error;
}ezbmt-tracked/src/db/index.ts
 
import { BACKEND } from '../lib/backend';

// SQLite 版本
import * as sqliteDao from './sqlite';
// Supabase 版本
import * as supaDao from './supa';

const dao = BACKEND === 'supabase' ? supaDao : sqliteDao;
export const openDB = (sqliteDao as any).openDB ?? (async()=>null);

export const joinEventByCode = (dao as any).joinEventByCode || (async (_code: string) => {
throw new Error('joinEventByCode not implemented for current backend');
});

export { enqueueSync, listSyncQueue, removeSyncItem, bumpSyncRetry } from './sqlite';

// Events
export const insertEvent = dao.insertEvent;
export const listEvents = dao.listEvents;

export const importEventMembersToMatch = (supaDao as any).importEventMembersToMatch;
export const hasMatchRallies = (dao as any).hasMatchRallies;
export const deleteMatch = (dao as any).deleteMatch;
export const hasEventMatches = (dao as any).hasEventMatches;
export const deleteEvent = (dao as any).deleteEvent;

export const listGamesByMatch = (dao as any).listGamesByMatch;

export const insertMatch = dao.insertMatch;
export const listMatches = dao.listMatches;
export const updateMatchRules = dao.updateMatchRules;
export const setMatchRecordMode = dao.setMatchRecordMode;
export const saveMatchState = dao.saveMatchState;
export const getMatch = dao.getMatch;

export const upsertMatchPlayers = dao.upsertMatchPlayers;
export const getMatchPlayers = dao.getMatchPlayers;
export const updateStartConfigs = dao.updateStartConfigs;

export const insertRally = dao.insertRally;
export const listRecentRallies = dao.listRecentRallies;
export const listRalliesOrdered = dao.listRalliesOrdered;
export const getLastRally = dao.getLastRally;
export const deleteRally = dao.deleteRally;

export const upsertGameSummary = dao.upsertGameSummary;

export const insertChatMessage = dao.insertChatMessage;
export const listChatMessages = dao.listChatMessages;

export const insertMedia = dao.insertMedia;
export const listMedia = dao.listMedia;
export const deleteMedia = dao.deleteMedia;

export const listDictionary = dao.listDictionary;
export const upsertDictionary = dao.upsertDictionary;
export const deleteDictionary = dao.deleteDictionary;

export const getRalliesByIds = dao.getRalliesByIds;

export const listEventMembers = (dao as any).listEventMembers;
export const getMyEventRole = (dao as any).getMyEventRole;
export const upsertEventMember = (dao as any).upsertEventMember;
export const deleteEventMember = (dao as any).deleteEventMember;
export const getEventJoinCode = (dao as any).getEventJoinCode;
export const setEventJoinCode = (dao as any).setEventJoinCode;
export const listEventMembersBasic = (dao as any).listEventMembersBasic;
export const listMatchMembers = (dao as any).listMatchMembers;
export const upsertMatchMember = (dao as any).upsertMatchMember;
export const deleteMatchMember = (dao as any).deleteMatchMember;
export const inviteEventMemberByEmail = (dao as any).inviteEventMemberByEmail;
export const setEventOwnerRPC = (dao as any).setEventOwnerRPC;

// Speed (SQLite)
export const insertSpeedSession = (sqliteDao as any).insertSpeedSession;
export const insertSpeedPoints = (sqliteDao as any).insertSpeedPoints;
export const listSpeedSessions = (sqliteDao as any).listSpeedSessions;
export const getSpeedSessionPoints = (sqliteDao as any).getSpeedSessionPoints;
export const deleteSpeedSession = (sqliteDao as any).deleteSpeedSession;

// Clubs
export const listClubs = (supaDao as any).listClubs;
export const createClub = (supaDao as any).createClub;
export const getMyClubRoles = (supaDao as any).getMyClubRoles;

// Buddies
export const listBuddies = (supaDao as any).listBuddies;
export const upsertBuddy = (supaDao as any).upsertBuddy;
export const deleteBuddy = (supaDao as any).deleteBuddy;

// Sessions
export const listSessions = (supaDao as any).listSessions;
export const createSession = (supaDao as any).createSession;

// Session Attendees（修正對應）
export const listSessionAttendees = (supaDao as any).listSessionAttendees;
export const upsertSessionAttendee = (supaDao as any).upsertAttendee;
export const removeSessionAttendee = (supaDao as any).removeAttendee;

// Rounds / Courts
export const listRounds = (supaDao as any).listRounds;
export const createRound = (supaDao as any).createRound;
export const listRoundCourts = (supaDao as any).listRoundCourts;
export const upsertRoundCourts = (supaDao as any).upsertRoundCourts;
export const getRoundCourtTeams = (supaDao as any).getRoundCourtTeams;

// Scoreboard
export const getRoundResultState = (supaDao as any).getRoundResultState;
export const upsertRoundResultState = (supaDao as any).upsertRoundResultState;
export const upsertRoundResultOutcome = (supaDao as any).upsertRoundResultOutcome;  // <--- 新增

// Club roles
export const getMyClubRole = (supaDao as any).getMyClubRole;

// Club chats
export const listClubChatMessages = (supaDao as any).listClubChatMessages;
export const insertClubChatMessage = (supaDao as any).insertClubChatMessage;

// Club media
export const listClubMedia = (supaDao as any).listClubMedia;
export const insertClubMedia = (supaDao as any).insertClubMedia;

// My events (supabase or sqlite fallback)
export async function listMyEvents() {
if (BACKEND === 'supabase' && (supaDao as any).listMyEvents) {
return supaDao.listMyEvents();
}
const rows = await sqliteDao.listEvents();
return rows;
}

export async function createEventRPC(args: { name: string; level?: string; venue?: string; start_at?: string; end_at?: string; join_code?: string }) {
if (BACKEND === 'supabase' && (supaDao as any).createEventRPC) {
return supaDao.createEventRPC(args);
}
const id = Math.random().toString(36).slice(2);
await sqliteDao.insertEvent({ id, name: args.name } as any);
return id;
}

export async function createMatchRPC(args: { event_id: string; type: string; courtNo?: string | null }) {
if (BACKEND === 'supabase' && (supaDao as any).createMatchRPC) {
return supaDao.createMatchRPC(args);
}
const id = Math.random().toString(36).slice(2);
await sqliteDao.insertMatch({ id, event_id: args.event_id, type: args.type, court_no: args.courtNo ?? undefined } as any);
return id;
}

export * from './supa_club';

export const listClubMembers = (supaDao as any).listClubMembers;
export const upsertClubMember = (supaDao as any).upsertClubMember;
export const deleteClubMember = (supaDao as any).deleteClubMember;
export const inviteClubMemberByEmail = (supaDao as any).inviteClubMemberByEmail;

export const getSession = (supaDao as any).getSession;
export const listMyInviteContactsWithNames = (supaDao as any).listMyInviteContactsWithNames;

// RSVPs
//export const listSignups = (supaDao as any).listSignups;
//export const signupSession = (supaDao as any).signupSession;
//export const cancelSignup = (supaDao as any).cancelSignup;
//export const deleteSignup = (supaDao as any).deleteSignup;
export const subscribeSessionNotification = (supaDao as any).subscribeSessionNotification;
export const unsubscribeSessionNotification = (supaDao as any).unsubscribeSessionNotification;
export const listSessionSubscriptions = (supaDao as any).listSessionSubscriptions;
export const registerDeviceToken = (supaDao as any).registerDeviceToken;
ezbmt-tracked/src/db/supa.ts
 
import { supa, SUPABASE_URL } from '../lib/supabase';

type MemberRole = 'owner'|'coach'|'recorder'|'player'|'viewer';

export async function listInviteContacts(): Promise<Array<{ email:string; last_role: MemberRole; total_count:number; last_invited_at: string }>> {
// RLS 已限制只回自己的資料，不需手動帶 owner_id
const { data, error } = await supa
.from('invite_contacts')
.select('email,last_role,total_count,last_invited_at')
.order('last_invited_at', { ascending: false })
.limit(30);
if (error) throw error;
return (data || []) as any;
}

function toJsonString(v: any): string | null {
try {
if (v == null) return null;
if (typeof v === 'string') return v;
return JSON.stringify(v);
} catch {
return null;
}
}

/* Join by code */
export async function joinEventByCode(code: string): Promise<void> {
const { error } = await supa.rpc('join_event_by_code', { p_code: code });
if (error) throw error;
}

/* Events */
export async function insertEvent(e: { id?: string; name: string; level?: string; venue?: string; start_at?: string; end_at?: string; }) {
const { data, error } = await supa.from('events').insert({
id: e.id, name: e.name, level: e.level ?? null, venue: e.venue ?? null, start_at: e.start_at ?? null, end_at: e.end_at ?? null
}).select('id').single();
if (error) throw error;
return data?.id as string;
}
export async function listEvents(): Promise<Array<{ id: string; name: string }>> {
const { data, error } = await supa.from('events').select('id,name').order('name',{ascending:true});
if (error) throw error;
return data || [];
}

/* Matches */
export async function insertMatch(m: { id?: string; event_id: string; type: string; court_no?: string; rules_json?: string; }) {
const rules = m.rules_json ? JSON.parse(m.rules_json) : null;
const { error } = await supa.from('matches').insert({
id: m.id, event_id: m.event_id, type: m.type, court_no: m.court_no ?? null, rules_json: rules
});
if (error) throw error;
}

export async function listMatches(eventId: string) {
const { data, error } = await supa.from('matches')
.select('id,type,court_no,rules_json,record_mode')
.eq('event_id', eventId)
.order('created_at',{ascending:false});
if (error) throw error;
return (data||[]).map((row:any)=>({ ...row, rules_json: toJsonString(row.rules_json) }));
}
export async function updateMatchRules(matchId: string, rulesJson: string) {
const { error } = await supa.from('matches').update({ rules_json: JSON.parse(rulesJson) }).eq('id', matchId);
if (error) throw error;
}
export async function setMatchRecordMode(matchId: string, mode: 'tap'|'route') {
const { error } = await supa.from('matches').update({ record_mode: mode }).eq('id', matchId);
if (error) throw error;
}
export async function saveMatchState(matchId: string, stateJson: string) {
const { error } = await supa.from('matches').update({ state_json: JSON.parse(stateJson) }).eq('id', matchId);
if (error) throw error;
}
export async function getMatch(matchId: string) {
const { data, error } = await supa.from('matches').select('*').eq('id', matchId).single();
if (error) throw error;
const row:any = data || {};
return { ...row, rules_json: toJsonString(row.rules_json), state_json: toJsonString(row.state_json) };
}

/* Players */
export async function upsertMatchPlayers(args: {
matchId: string;
home: { idx: 0 | 1; name?: string; gender?: string; handedness?: string }[];
away: { idx: 0 | 1; name?: string; gender?: string; handedness?: string }[];
}) {
const all = [...args.home.map(p=>({...p,side:'home'})), ...args.away.map(p=>({...p,side:'away'}))];
for (const p of all) {
const { error } = await supa.from('match_players').upsert({
match_id: args.matchId, side: p.side, idx: p.idx, name: p.name ?? null, gender: p.gender ?? null, handedness: p.handedness ?? null,
});
if (error) throw error;
}
}
export async function getMatchPlayers(matchId: string) {
const { data, error } = await supa.from('match_players').select('side,idx,name,gender,handedness').eq('match_id', matchId);
if (error) throw error;
return data || [];
}
export async function updateStartConfigs(args: {
matchId: string; startingServerTeam: 0|1; startingServerIndex: 0|1; homeRightWhenEven: 0|1; awayRightWhenEven: 0|1;
}) {
const { error } = await supa.from('matches').update({
starting_server_team: args.startingServerTeam,
starting_server_index: args.startingServerIndex,
home_right_when_even_index: args.homeRightWhenEven,
away_right_when_even_index: args.awayRightWhenEven,
}).eq('id', args.matchId);
if (error) throw error;
}

/* Rallies */
export async function insertRally(r: {
id?: string; match_id: string; game_index: number; rally_no: number;
winner_side: string; end_zone: string; meta_json: string;
route_start_x?: number | null; route_start_y?: number | null;
route_end_x?: number | null; route_end_y?: number | null;
route_start_rx?: number | null; route_start_ry?: number | null;
route_end_rx?: number | null; route_end_ry?: number | null;
created_at: string;
}) {
const { id: _ignore, ...row } = r as any;
const { error } = await supa.from('rallies').insert(row);
if (error) throw error;
}


export async function listRecentRallies(matchId: string, limit = 20) {
const { data, error } = await supa.from('rallies').select('*').eq('match_id', matchId).order('created_at',{ascending:false}).limit(limit);
if (error) throw error;
return (data||[]).map((row:any)=>({ ...row, meta_json: toJsonString(row.meta_json) }));
}
export async function listRalliesOrdered(matchId: string) {
const { data, error } = await supa.from('rallies').select('*').eq('match_id', matchId)
.order('game_index',{ascending:true})
.order('rally_no',{ascending:true});
if (error) throw error;
return (data||[]).map((row:any)=>({ ...row, meta_json: toJsonString(row.meta_json) }));
}
export async function getLastRally(matchId: string) {
const { data, error } = await supa.from('rallies').select('*').eq('match_id', matchId).order('created_at',{ascending:false}).limit(1);
if (error) throw error;
const row = data && data.length ? data[0] : null;
return row ? { ...row, meta_json: toJsonString(row.meta_json) } : null;
}
export async function deleteRally(id: string) {
const { error } = await supa.from('rallies').delete().eq('id', id);
if (error) throw error;
}

/* Games summary */
export async function upsertGameSummary(args: {
matchId: string; gameIndex: number;
home: number; away: number;
winnerTeam: 0 | 1 | null;
intervalTaken: boolean; deciderSwitched: boolean;
}) {
const { error } = await supa.from('games').upsert({
match_id: args.matchId,
index_no: args.gameIndex,
home_score: args.home,
away_score: args.away,
winner_team: args.winnerTeam,
interval_taken: args.intervalTaken,
decider_sides_switched: args.deciderSwitched,
}, { onConflict: 'match_id,index_no' });
if (error) throw error;
}

/* Chat */
export async function insertChatMessage(args: { matchId: string; user?: string; text: string; createdAt?: string }) {
const { error } = await supa.from('chat_messages').insert({
match_id: args.matchId, user_name: args.user ?? null, text: args.text, created_at: args.createdAt ?? new Date().toISOString()
});
if (error) throw error;
}
export async function listChatMessages(matchId: string, limit = 200) {
const { data, error } = await supa.from('chat_messages').select('*').eq('match_id', matchId).order('created_at',{ascending:false}).limit(limit);
if (error) throw error;
return (data||[]).map((row:any)=>({ ...row, user: row.user_name }));
}

/* Media */
export async function insertMedia(m: { id?: string; owner_type: 'event'|'match'; owner_id: string; kind: 'youtube'|'photo'; url: string; description?: string }) {
const { error } = await supa.from('media').insert({
id: m.id, owner_type: m.owner_type, owner_id: m.owner_id, kind: m.kind, url: m.url, description: m.description ?? null
});
if (error) throw error;
}
export async function listMedia(owner_type: 'event'|'match', owner_id: string) {
const { data, error } = await supa.from('media').select('*').eq('owner_type', owner_type).eq('owner_id', owner_id).order('created_at',{ascending:false});
if (error) throw error;
return data || [];
}
export async function deleteMedia(id: string) {
const { error } = await supa.from('media').delete().eq('id', id);
if (error) throw error;
}

/* Dictionaries */
export async function listDictionary(kind: 'shot_type'|'error_reason') {
const { data, error } = await supa.from('dictionaries').select('id,label,value,order_no').eq('kind', kind)
.order('order_no',{ascending:true}).order('label',{ascending:true});
if (error) throw error;
return data || [];
}
export async function upsertDictionary(item: { id?: string; kind:'shot_type'|'error_reason'; label:string; value?:string; order_no?:number }) {
const { error } = await supa.from('dictionaries').upsert({
id: item.id, kind: item.kind, label: item.label, value: item.value ?? item.label, order_no: item.order_no ?? 0
});
if (error) throw error;
}
export async function deleteDictionary(id: string) {
const { error } = await supa.from('dictionaries').delete().eq('id', id);
if (error) throw error;
}

/* Live/Replay 補充 */
export async function getRalliesByIds(ids: string[]): Promise<any[]> {
if (!ids || !ids.length) return [];
const { data, error } = await supa.from('rallies').select('*').in('id', ids);
if (error) throw error;
const out = (data||[]).map((row:any)=>({ ...row, meta_json: toJsonString(row.meta_json) }));
out.sort((a:any,b:any)=>(a.game_index===b.game_index ? (a.rally_no-b.rally_no) : (a.game_index-b.game_index)));
return out;
}

/* Event members */
export async function getCurrentUserId(): Promise<string|null> {
const { data } = await supa.auth.getUser();
return data?.user?.id || null;
}
/* 取得本人角色（建議有 get_my_event_role RPC；若沒有就用 list_event_members 再比對） */
export async function getMyEventRole(eventId: string) {
const { data } = await supa.rpc('get_my_event_role', { p_event_id: eventId });
return (data as MemberRole) || null;
}

/* 事件成員列表（RPC） */
export async function listEventMembers(eventId: string) {
const { data, error } = await supa.rpc('list_event_members_with_names', { p_event_id: eventId });
if (error) throw error;
return (data || []) as Array<{
id: string;
user_id: string;
role: 'owner'|'coach'|'recorder'|'player'|'viewer';
name: string | null;
email: string | null;
}>;
}

/* 新增/變更角色（RPC） */
export async function upsertEventMember(args: { eventId: string; userId: string; role: MemberRole }) {
const { error } = await supa.rpc('upsert_event_member', {
p_event_id: args.eventId,
p_user_id: args.userId,
p_role: args.role,
});
if (error) throw error;
}

/* 移除成員（RPC） */
export async function deleteEventMember(memberId: string) {
const { error } = await supa.rpc('delete_event_member', { p_member_id: memberId });
if (error) throw error;
}
export async function setEventJoinCode(eventId: string, code: string|null) {
const { error } = await supa.from('events').update({ join_code: code }).eq('id', eventId);
if (error) throw error;
}
export async function getEventJoinCode(eventId: string): Promise<string|null> {
const { data, error } = await supa.from('events').select('join_code').eq('id', eventId).single();
if (error) throw error;
return (data?.join_code as string) || null;
}

/* Match members */
// 讀取場次成員（含 name）
export async function listMatchMembers(matchId: string) {
const { data, error } = await supa.rpc('list_match_members_with_names', { p_match_id: matchId });
if (error) throw error;
return (data || []) as Array<{ id:string; user_id:string; role:'owner'|'coach'|'recorder'|'player'|'viewer'; name:string }>;
}

export async function upsertMatchMember(args: { matchId: string; userId: string; role: 'owner'|'coach'|'recorder'|'player'|'viewer' }) {
const { error } = await supa.rpc('upsert_match_member', {
p_match_id: args.matchId,
p_user_id: args.userId,
p_role: args.role,
});
if (error) throw error;
}

export async function deleteMatchMember(id: string) {
const { error } = await supa.rpc('delete_match_member', { p_member_id: id });
if (error) throw error;
}

export async function listEventMembersBasic(eventId: string): Promise<Array<{ user_id:string; name:string }>> {
const { data, error } = await supa.from('event_members').select('user_id').eq('event_id', eventId);
if (error) throw error;
const ids = (data||[]).map((r:any)=>r.user_id as string);
if (!ids.length) return [];
const { data: prof } = await supa.from('profiles').select('id,name').in('id', ids as any);
return (prof||[]).map((p:any)=>({ user_id: p.id as string, name: (p.name || (p.id as string).slice(0,8)+'…') as string }));
}

/* Edge Function: 邀請成員（Email） */
export async function inviteEventMemberByEmail(args: {
eventId: string;
email: string;
role: 'owner'|'coach'|'recorder'|'player'|'viewer';
}) {
// 1) 取目前使用者 access_token
const { data: sess } = await supa.auth.getSession();
const token = sess?.session?.access_token || null;
if (!token) throw new Error('Not logged in');

// 2) 直接打 Edge Function HTTP 端點，讀回應文字
const url = `${SUPABASE_URL}/functions/v1/invite-by-email`;
const res = await fetch(url, {
method: 'POST',
headers: {
'Content-Type': 'application/json',
// 必須帶 Bearer <access_token>
'Authorization': `Bearer ${token}`,
},
body: JSON.stringify(args),
});

const text = await res.text();

// 3) 非 2xx => 把狀態碼與 body 一起丟出去，UI 才看得到
if (!res.ok) {
// 盡量把 Edge 回的 JSON error 轉成更乾淨訊息
try {
const j = JSON.parse(text);
const msg = j?.error || j?.message || text || `HTTP ${res.status}`;
throw new Error(msg);
} catch {
throw new Error(`${res.status} ${res.statusText}: ${text || 'Edge error'}`);
}
}

// 4) 成功回傳 JSON
try {
return JSON.parse(text);
} catch {
return { ok: true };
}
}




// 讀「我的賽事」（RPC）
export async function listMyEvents(): Promise<Array<{ id:string; name:string }>> {
const { data, error } = await supa.rpc('list_my_events');
if (error) throw error;
return (data || []) as Array<{ id:string; name:string }>;
}

// 建立賽事（RPC）
export async function createEventRPC(args: {
name: string; level?: string; venue?: string; start_at?: string; end_at?: string; join_code?: string;
}) {
const { data, error } = await supa.rpc('create_event', {
p_name: args.name,
p_level: args.level ?? null,
p_venue: args.venue ?? null,
p_start_at: args.start_at ?? null,
p_end_at: args.end_at ?? null,
p_join_code: args.join_code ?? null,
});
if (error) throw error;
return data as string; // event_id
}
// 建立場次（RPC）
export async function createMatchRPC(args: { event_id: string; type: string; court_no?: string; rules?: any }) {
const { data, error } = await supa.rpc('create_match', {
p_event_id: args.event_id,
p_type: args.type,
p_court_no: args.court_no ?? null,
p_rules_json: args.rules ?? null,
});
if (error) throw error;
return data as string; // match_id
}

// 移交擁有者（RPC）
export async function setEventOwnerRPC(args: { eventId: string; userId: string }) {
const { error } = await supa.rpc('set_event_owner', { p_event_id: args.eventId, p_user_id: args.userId });
if (error) throw error;
}

/* 新增：刪賽事/檢查是否有場次 */
// 是否有此賽事的場次
export async function hasEventMatches(eventId: string): Promise<boolean> {
const { count, error } = await supa
.from('matches')
.select('id', { count: 'exact', head: true })
.eq('event_id', eventId);
if (error) throw error;
return (count || 0) > 0;
}

export async function deleteEvent(eventId: string): Promise<void> {
const { data, error } = await supa.rpc('delete_event_safe', { p_event_id: eventId });
if (error) throw error;
if (data && data.deleted === false) {
if (data.reason === 'HAS_MATCHES') throw new Error('HAS_MATCHES');
throw new Error('DELETE_FAILED');
}
}

/* 新增：是否有記錄、刪除場次（含相依資料） */
// 是否有此場次的記錄
export async function hasMatchRallies(matchId: string): Promise<boolean> {
// 同樣用 limit(1) 檢查是否存在
const { data, error } = await supa
.from('rallies')
.select('id')
.eq('match_id', matchId)
.limit(1);
if (error) throw error;
return (data || []).length > 0;
}
export async function deleteMatch(matchId: string): Promise<void> {
  try { await supa.from('rallies').delete().eq('match_id', matchId); } catch(_e) {}
  try { await supa.from('games').delete().eq('match_id', matchId); } catch(_e) {}
  try { await supa.from('match_players').delete().eq('match_id', matchId); } catch(_e) {}
  try { await supa.from('chat_messages').delete().eq('match_id', matchId); } catch(_e) {}
  try { await supa.from('media').delete().eq('owner_type','match').eq('owner_id', matchId); } catch(_e) {}
  try { await supa.from('match_members').delete().eq('match_id', matchId); } catch(_e) {}
  const { error } = await supa.from('matches').delete().eq('id', matchId);
  if (error) throw error;
}

export async function listGamesByMatch(matchId: string) {
  const { data, error } = await supa
    .from('games')
    .select('index_no,home_score,away_score,winner_team')
    .eq('match_id', matchId)
    .order('index_no', { ascending: true });
  if (error) throw error;
  return data || [];
}

type LiveSnapshot = {
scoreA: number; scoreB: number;
servingTeam: 0|1;
server?: { team:0|1; index:0|1; court:'R'|'L' };
receiver?: { team:0|1; index:0|1; court:'R'|'L' };
players?: Array<{ name?: string }>;
};

export async function importEventMembersToMatch(matchId: string): Promise<number> {
if (!matchId) throw new Error('matchId is required');
const { data, error } = await supa.rpc('upsert_match_members_from_event', { p_match_id: matchId });
if (error) throw error;
return (data as number) ?? 0;
}


// Clubs
export async function listClubs(): Promise<Array<{ id:string; name:string; description?:string|null }>> {
const { data, error } = await supa.from('clubs').select('id,name,description').order('created_at',{ ascending:false });
if (error) throw error;
return data || [];
}
export async function createClub(args: { name: string; description?: string }) {
// 先建立社團
const { data, error } = await supa
.from('clubs')
.insert({ name: args.name, description: args.description ?? null })
.select('id')
.single();
if (error) throw error;

// 再把建立者加為 owner（若已存在就覆寫角色）
const { data: me } = await supa.auth.getUser();
const uid = me?.user?.id;
if (uid && data?.id) {
const { error: e2 } = await supa
.from('club_members')
.upsert(
{ club_id: data.id as string, user_id: uid, role: 'owner' },
{ onConflict: 'club_id,user_id' }
);
if (e2) throw e2;
}
}
export async function getMyClubRoles(clubIds: string[]): Promise<Record<string,string>> {
if (!clubIds.length) return {};
const { data, error } = await supa.from('club_members').select('club_id,role').in('club_id', clubIds as any);
if (error) return {};
const map: Record<string,string> = {};
(data||[]).forEach((r:any)=>{ map[r.club_id] = String(r.role||''); });
return map;
}

// Buddies
export async function listBuddies(clubId: string) {
const { data, error } = await supa.from('buddies').select('id,name,level,gender,handedness,note').eq('club_id', clubId).order('name',{ ascending:true });
if (error) throw error;
return data || [];
}
export async function upsertBuddy(args: { clubId: string; name: string; level: number; note?: string }) {
const { error } = await supa.from('buddies').insert({ club_id: args.clubId, name: args.name, level: args.level, note: args.note ?? null });
if (error) throw error;
}
export async function deleteBuddy(id: string) {
const { error } = await supa.from('buddies').delete().eq('id', id);
if (error) throw error;
}

// Sessions
export async function listSessions(clubId: string) {
const { data, error } = await supa.from('sessions').select('id,date,courts,round_minutes').eq('club_id', clubId).order('date',{ ascending:false });
if (error) throw error;
return data || [];
}

export async function createSession(args: { clubId: string; date: string; courts: number; roundMinutes: number }) {
// 取目前登入者
const { data: me } = await supa.auth.getUser();
const uid = me?.user?.id;
if (!uid) throw new Error('Not logged in');

// 帶入 created_by 以符合 RLS
const { error } = await supa.from('sessions').insert({
club_id: args.clubId,
date: args.date,
courts: args.courts,
round_minutes: args.roundMinutes,
created_by: uid,
});
if (error) throw error;
}

// Attendees
export async function listSessionAttendees(sessionId: string) {
// A) 先嘗試從 view 讀（若你的 view 有 checked_in 就會帶回來）
try {
const { data, error } = await supa
.from('session_attendees_view')
.select('id,session_id,buddy_id,name,level,gender,handedness,checked_in')
.eq('session_id', sessionId)
.order('id', { ascending: true });
if (!error && data) {
return (data || []).map((r: any) => ({
id: r.id as string,
session_id: r.session_id as string,
buddy_id: (r.buddy_id ?? null) as string | null,
display_name: String(r.name || ''),
level: (r.level ?? null) as number | null,
gender: (r.gender ?? null) as 'M'|'F'|'U'|null,
handedness: (r.handedness ?? null) as 'L'|'R'|'U'|null,
checked_in: !!(r.checked_in ?? true), // 若 view 沒給，一律視為 true
}));
}
} catch {}

// B) 若 view 存在但沒有 checked_in 欄位，就用精簡欄位再試
try {
const { data, error } = await supa
.from('session_attendees_view')
.select('id,session_id,buddy_id,name,level,gender,handedness')
.eq('session_id', sessionId)
.order('id', { ascending: true });
if (!error && data) {
return (data || []).map((r: any) => ({
id: r.id as string,
session_id: r.session_id as string,
buddy_id: (r.buddy_id ?? null) as string | null,
display_name: String(r.name || ''),
level: (r.level ?? null) as number | null,
gender: (r.gender ?? null) as 'M'|'F'|'U'|null,
handedness: (r.handedness ?? null) as 'L'|'R'|'U'|null,
checked_in: true, // 沒欄位就預設已報到
}));
}
} catch {}

// C) 再退回查表（表沒有 checked_in 就不要 select 它）
const { data: raw, error: e2 } = await supa
.from('session_attendees')
.select('id,session_id,buddy_id')
.eq('session_id', sessionId)
.order('id', { ascending: true });
if (e2) throw e2;

const ids = (raw || []).map((r: any) => r.buddy_id).filter(Boolean);
const meta = new Map<string, { name?: string; level?: number|null; gender?: any; handedness?: any }>();
if (ids.length) {
const { data: bs } = await supa
.from('buddies')
.select('id,name,level,gender,handedness')
.in('id', ids as any);
(bs || []).forEach((b: any) =>
meta.set(b.id, {
name: b.name || '',
level: b.level ?? null,
gender: b.gender ?? null,
handedness: b.handedness ?? null,
}),
);
}

return (raw || []).map((r: any) => {
const b = meta.get(r.buddy_id) || {};
return {
id: r.id as string,
session_id: r.session_id as string,
buddy_id: (r.buddy_id ?? null) as string | null,
display_name: String(b.name || ''),
level: (b.level ?? null) as number | null,
gender: (b.gender ?? null) as 'M'|'F'|'U'|null,
handedness: (b.handedness ?? null) as 'L'|'R'|'U'|null,
checked_in: true, // 表沒有此欄，一律視為已報到
};
});
}

// ---------- Rounds / Courts ----------
/*
export async function listRounds(sessionId: string): Promise<Array<{ id:string; index_no:number; status?:string|null }>> {
const { data, error } = await supa.from('session_rounds').select('id,index_no,status').eq('session_id', sessionId).order('index_no',{ ascending:true });
if (error) throw error;
return data || [];
}*/
export async function createRound(args: { sessionId: string; indexNo: number }): Promise<string> {
const { data, error } = await supa.from('session_rounds').insert({ session_id: args.sessionId, index_no: args.indexNo }).select('id').single();
if (error) throw error;
return String(data?.id);
}
export async function listRoundCourts(roundId: string): Promise<Array<{ id:string; court_no:number; team_a_ids:string[]; team_b_ids:string[] }>> {
const { data, error } = await supa.from('round_courts').select('id,court_no,team_a_ids,team_b_ids').eq('round_id', roundId).order('court_no',{ ascending:true });
if (error) throw error;
return (data || []).map((r:any)=>({
id: r.id, court_no: Number(r.court_no||0),
team_a_ids: Array.isArray(r.team_a_ids)? r.team_a_ids : (r.team_a_ids||[]),
team_b_ids: Array.isArray(r.team_b_ids)? r.team_b_ids : (r.team_b_ids||[]),
}));
}
export async function upsertRoundCourts(roundId: string, rows: Array<{ court_no:number; team_a_ids:string[]; team_b_ids:string[] }>) {
for (const r of rows) {
const { error } = await supa
.from('round_courts')
.upsert(
{ round_id: roundId, court_no: r.court_no, team_a_ids: r.team_a_ids, team_b_ids: r.team_b_ids },
{ onConflict: 'round_id,court_no' }
);
if (error) throw error;
}
}

// 取該場地的隊員姓名
export async function getRoundCourtTeams(args: { roundId: string; courtNo: number }): Promise<{ A:[string,string]; B:[string,string] }> {
// 優先：round_courts
try {
const { data, error } = await supa
.from('round_courts')
.select('team_a_ids,team_b_ids')
.eq('round_id', args.roundId)
.eq('court_no', args.courtNo)
.maybeSingle();
if (!error && data) {
const aIds = (data?.team_a_ids || []) as string[];
const bIds = (data?.team_b_ids || []) as string[];
const ids = [...aIds, ...bIds].filter(Boolean);
if (ids.length) {
const { data: buddies } = await supa
.from('buddies')
.select('id,name')
.in('id', ids as any);
const nameOf = (id?: string) =>
(buddies || []).find(b => b.id === id)?.name || (id ? id.slice(0, 6) + '…' : '');
return { A: [nameOf(aIds[0]), nameOf(aIds[1])], B: [nameOf(bIds[0]), nameOf(bIds[1])] };
}
}
} catch {}

// 後援：round_matches（PairingScreen 發布的 upsert_round 可能只寫 matches）
const { data: rm, error: me } = await supa
.from('round_matches')
.select('team_a, team_b, court_no')
.eq('round_id', args.roundId)
.eq('court_no', args.courtNo)
.maybeSingle();
if (me) throw me;

const Aplayers = (rm as any)?.team_a?.players || [];
const Bplayers = (rm as any)?.team_b?.players || [];
const toName = (x: any) => (x?.name && String(x.name)) || '';
return {
A: [toName(Aplayers[0]) || 'A0', toName(Aplayers[1]) || 'A1'],
B: [toName(Bplayers[0]) || 'B0', toName(Bplayers[1]) || 'B1'],
};
}

// ---------- Scoreboard (round_results) ----------
export async function getRoundResultState(args: { roundId: string; courtNo: number }): Promise<{ state_json?: string|null } | null> {
const { data, error } = await supa.from('round_results').select('serve_state_json').eq('round_id', args.roundId).eq('court_no', args.courtNo).maybeSingle();
if (error) throw error;
return data ? { state_json: data.serve_state_json ? JSON.stringify(data.serve_state_json) : null } : null;
}
export async function upsertRoundResultState(args: { roundId: string; courtNo: number; stateJson: string }) {
const payload = { round_id: args.roundId, court_no: args.courtNo, serve_state_json: JSON.parse(args.stateJson) };
const { error } = await supa.from('round_results').upsert(payload, { onConflict: 'round_id,court_no' });
if (error) throw error;
}

// 1) 角色（單一社團）
export async function getMyClubRole(clubId: string): Promise<string|null> {
const { data: me } = await supa.auth.getUser();
const uid = me?.user?.id;
if (!uid) return null;

// 先查 club_members
const { data: cm } = await supa
.from('club_members')
.select('role')
.eq('club_id', clubId)
.eq('user_id', uid)
.maybeSingle();
if (cm?.role) return String(cm.role);

// 後援：若 clubs.created_by 是我，視為 owner
const { data: club } = await supa
.from('clubs')
.select('created_by')
.eq('id', clubId)
.maybeSingle();
if (club?.created_by && String(club.created_by) === uid) return 'owner';

return null;
}

// 2) Club Chats
export async function listClubChatMessages(clubId: string, limit = 200) {
const { data, error } = await supa.from('club_chats').select('*').eq('club_id', clubId).order('created_at',{ ascending:false }).limit(limit);
if (error) throw error;
return (data||[]).map((row:any)=>({ id: row.id, user: row.user_name || '匿名', text: row.text || '', created_at: row.created_at || new Date().toISOString() }));
}
export async function insertClubChatMessage(args: { clubId: string; user?: string; text: string; createdAt?: string }) {
const { error } = await supa.from('club_chats').insert({
club_id: args.clubId, user_name: args.user ?? null, text: args.text, created_at: args.createdAt ?? new Date().toISOString(),
});
if (error) throw error;
}

// 3) Club Media（沿用 media 表，owner_type 支援 'club'）
export async function listClubMedia(clubId: string) {
const { data, error } = await supa.from('media').select('*').eq('owner_type','club').eq('owner_id', clubId).order('created_at',{ ascending:false });
if (error) throw error;
return data || [];
}

export async function insertClubMedia(args: { clubId: string; kind: 'youtube'|'photo'; url: string; description?: string }) { 
const { error } = await supa.from('media').insert({ 
owner_type: 'club', owner_id: args.clubId, kind: args.kind, url: args.url, description: args.description ?? null, }); 
if (error) throw error; }

export type SessionRow = {
id: string;
club_id?: string | null;
date: string;
start_at?: string | null;
end_at?: string | null;
courts: number;
round_minutes: number;
status: 'draft'|'ongoing'|'finished';
created_by: string;
created_at: string;
};

export type Attendee = {
id: string;
session_id: string;
user_id?: string|null;
buddy_id?: string|null;
display_name: string;
level?: number|null;
gender?: 'M'|'F'|'U'|null;
handedness?: 'L'|'R'|'U'|null;
checked_in: boolean;
arrive_at?: string|null;
leave_at?: string|null;
};

export type RoundRow = {
id: string;
session_id: string;
index_no: number;
start_at?: string|null;
end_at?: string|null;
status: 'planned'|'published'|'ongoing'|'finished';
meta?: any;
created_at: string;
};

export type RoundMatch = {
id: string;
round_id: string;
court_no: number;
team_a: any; // { players: [{id,name,level}], ... }
team_b: any;
result?: any;
created_at: string;
};

export async function insertSession(args: {
club_id?: string|null;
date: string; start_at?: string|null; end_at?: string|null;
courts: number; round_minutes: number;
status?: 'draft'|'ongoing'|'finished';
}): Promise<string> {
const { data, error } = await supa
.from('sessions')
.insert({
club_id: args.club_id ?? null,
date: args.date,
start_at: args.start_at ?? null,
end_at: args.end_at ?? null,
courts: args.courts,
round_minutes: args.round_minutes,
status: args.status ?? 'draft',
})
.select('id')
.single();
if (error) throw error;
return data!.id as string;
}

export async function listSessionsOfMe(): Promise<SessionRow[]> {
const { data, error } = await supa
.from('sessions')
.select('*')
.order('date', { ascending: false })
.limit(200);
if (error) throw error;
return (data || []) as SessionRow[];
}

export async function upsertAttendee(a: Omit<Attendee,'id'|'created_at'> & { id?: string }) {
const payload = { ...a };
const { error } = await supa
.from('session_attendees')
.upsert(payload, { onConflict: 'id' });
if (error) throw error;
}

export async function removeAttendee(id: string) {
const { error } = await supa
.from('session_attendees')
.delete()
.eq('id', id);
if (error) throw error;
}

/** 呼叫 RPC: upsert_round */
export async function upsertRound(session_id: string, payload: {
index_no: number;
start_at?: string|null;
end_at?: string|null;
status?: 'planned'|'published'|'ongoing'|'finished';
matches: Array<{ court_no: number; team_a: any; team_b: any }>;
}): Promise<string> {
const { data, error } = await supa.rpc('upsert_round', {
p_session_id: session_id,
p_round: payload as any,
});
if (error) throw error;
return data as string; // round_id
}


export async function listRounds(session_id: string): Promise<Array<RoundRow & { matches: RoundMatch[] }>> {
// 只選一定存在的欄位，避免資料庫沒有的欄位（meta/start_at/end_at/created_at）造成 5xx
const { data: rounds, error: re } = await supa
.from('session_rounds')
.select('id, session_id, index_no, status')
.eq('session_id', session_id)
.order('index_no', { ascending: true });

if (re) throw re;
// 這裡用 any 承接，以免你的 RoundRow 型別還包含可選欄位時產生型別警告
const arr = (rounds || []) as any[];

// 批次撈每輪的 matches
const ids = arr.map(r => r.id);
if (!ids.length) return arr.map(r => ({ ...r, matches: [] }));

const { data: matches, error: me } = await supa
.from('round_matches')
.select('id, round_id, court_no, team_a, team_b, result')
.in('round_id', ids as any)
.order('court_no', { ascending: true });

if (me) throw me;

const map = new Map<string, RoundMatch[]>();
(matches || []).forEach((m: any) => {
const rid = String(m.round_id);
if (!map.has(rid)) map.set(rid, []);
map.get(rid)!.push(m as RoundMatch);
});

return arr.map(r => ({ ...r, matches: map.get(r.id) || [] }));
}

/** 投影看板/倒數 */
export async function listProjection(session_id: string): Promise<{
server_time: string;
now?: { index: number; start_at?: string|null; end_at?: string|null; matches: any[] } | null;
next?: { index: number; planned_start_at?: string|null; matchesPreview: any[] } | null;
}> {
const { data, error } = await supa.rpc('list_projection', { p_session_id: session_id });
if (error) throw error;
return data as any;
}

/* Club members */ 
export async function listClubMembers(clubId: string): Promise<Array<{ id:string; user_id:string; role:string; name:string; email?:string|null }>> {
const { data, error } = await supa
.rpc('list_club_members_with_names', { p_club_id: clubId });
if (error) throw error;
return (data || []).map((r: any) => ({
id: r.id as string,
user_id: r.user_id as string,
role: String(r.role || 'member'),
name: String(r.name || ''),           // 已是暱稱或 email 前綴
email: r.email ? String(r.email) : null,
}));
}
    
export async function upsertClubMember(args: { clubId: string; userId: string; role: string }) 
{ const { error } = await supa.from('club_members').upsert( 
  { club_id: args.clubId, user_id: args.userId, role: args.role }, 
  { onConflict: 'club_id,user_id' } ); if (error) throw error; } 
  
  export async function deleteClubMember(id: string) { const { error } = await supa.from('club_members')
  .delete().eq('id', id); if (error) throw error; } 
  
  /* Edge Function: 邀請社團成員（Email） */ 
  export async function inviteClubMemberByEmail(args: { clubId: string; 
    email: string; 
    role: 'owner'|'admin'|'scheduler'|'scorer'|'member' }) 
    { const { data: sess } = await supa.auth.getSession(); const token = sess?.session?.access_token || null; 
    if (!token) throw new Error('Not logged in'); 
    const url = `${SUPABASE_URL}/functions/v1/invite-club-by-email`; 
    const res = await fetch(url, { method: 'POST', headers: { 'Content-Type':'application/json', 'Authorization': `Bearer ${token}` }
      , body: JSON.stringify(args), }); 
      const text = await res.text(); if (!res.ok) { 
        try { const j = JSON.parse(text); throw new Error(j?.error || j?.message || text || `HTTP ${res.status}`); } 
        catch { throw new Error(`${res.status} ${res.statusText} : ${text || 'Edge error'}`); } } 
        try { return JSON.parse(text); } catch { return { ok:true }; } }

export async function getSession(sessionId: string): Promise<{ id:string; date?:string|null; courts?:number|null; round_minutes?:number|null } | null> {
const { data, error } = await supa
.from('sessions')
.select('id,date,courts,round_minutes')
.eq('id', sessionId)
.maybeSingle();
if (error) throw error;
return (data || null) as any;
}

export async function listMyInviteContactsWithNames(): Promise<Array<{
email: string;
name?: string | null;
last_role: string;
total_count?: number | null;
last_invited_at?: string | null;
}>> {
const { data, error } = await supa.rpc('list_my_invite_contacts');
if (error) throw error;
return (data || []) as any;
}

export async function upsertRoundResultOutcome(args: {
roundId: string;
courtNo: number;
serveStateJson?: string;           // 序列化後的 MatchState（可選）
scoreHome?: number | null;
scoreAway?: number | null;
winnerTeam?: 0 | 1 | null;        // 0 主 / 1 客 / null 未定
finishedAt?: string | null;        // ISO time
}): Promise<void> {
const payload: any = {
round_id: args.roundId,
court_no: args.courtNo,
};
if (args.serveStateJson != null) payload.serve_state_json = JSON.parse(args.serveStateJson);
if (args.scoreHome != null) payload.score_home = args.scoreHome;
if (args.scoreAway != null) payload.score_away = args.scoreAway;
if (args.winnerTeam != null) payload.winner_team = args.winnerTeam;
if (args.finishedAt != null) payload.finished_at = args.finishedAt;

const { error } = await supa
.from('round_results')
.upsert(payload, { onConflict: 'round_id,court_no' });
if (error) throw error;
}

// ========== Notifications: push_subscriptions / device_tokens ==========

/** 追蹤某場次（sessionId）通知：在 push_subscriptions 寫入 kind='event', target_id=sessionId */
export async function subscribeSessionNotification(sessionId: string): Promise<void> {
const { data: me } = await supa.auth.getUser();
const uid = me?.user?.id;
if (!uid) throw new Error('Not logged in');

// upsert（需在資料庫有 unique index: (kind, target_id, user_id)）
const { error } = await supa
.from('push_subscriptions')
.upsert(
{ kind: 'event', target_id: sessionId, user_id: uid },
{ onConflict: 'kind,target_id,user_id' }
);
if (error) throw error;
}

/** 取消追蹤某場次（sessionId）通知 */
export async function unsubscribeSessionNotification(sessionId: string): Promise<void> {
const { data: me } = await supa.auth.getUser();
const uid = me?.user?.id;
if (!uid) throw new Error('Not logged in');

const { error } = await supa
.from('push_subscriptions')
.delete()
.eq('kind', 'event')
.eq('target_id', sessionId)
.eq('user_id', uid);
if (error) throw error;
}

/** 查詢我對多個場次是否有追蹤通知 */
export async function listSessionSubscriptions(sessionIds: string[]): Promise<Record<string, boolean>> {
const map: Record<string, boolean> = {};
if (!sessionIds.length) return map;

const { data: me } = await supa.auth.getUser();
const uid = me?.user?.id;
if (!uid) return map;

const { data, error } = await supa
.from('push_subscriptions')
.select('target_id')
.eq('kind', 'event')
.eq('user_id', uid)
.in('target_id', sessionIds as any);
if (error) return map;

(data || []).forEach((r: any) => { map[String(r.target_id)] = true; });
return map;
}

/** 註冊裝置的推播 token（之後整合 FCM/Expo 用） */
export async function registerDeviceToken(token: string): Promise<void> {
const { data: me } = await supa.auth.getUser();
const uid = me?.user?.id;
if (!uid) throw new Error('Not logged in');
if (!token) throw new Error('empty token');

// upsert（建議資料庫有 unique index on token 或 (user_id, token)）
const { error } = await supa
.from('device_tokens')
.upsert(
{ user_id: uid, token },
{ onConflict: 'token' }
);
if (error) throw error;
}

ezbmt-tracked/src/global.d.ts
 
declare module 'react-native-sqlite-storage';

declare module 'react-native-keep-awake' {
const KeepAwake: {
activate(): void;
deactivate(): void;
};
export default KeepAwake;
}ezbmt-tracked/src/store/records.ts
 
import { create } from 'zustand';
import type { RallyRecord } from '../types';
import { insertRally, listRecentRallies } from '../db';
import { enqueueSync } from '../db';
import { BACKEND } from '../lib/backend';

type RecordsState = {
currentMatchId: string | null;
records: RallyRecord[]; // 最新在前
setCurrentMatch: (id: string | null) => void;
loadRecent: () => Promise<void>;
addRecord: (r: Omit<RallyRecord, 'id' | 'createdAt' | 'matchId'> & {
routeNorm?: { start?: { x: number; y: number }; end?: { x: number; y: number } };
}) => Promise<void>;
clearLocal: () => void;
};

export const useRecordsStore = create<RecordsState>((set, get) => ({
currentMatchId: null,
records: [],

setCurrentMatch: (id) => set({ currentMatchId: id, records: [] }),

loadRecent: async () => {
const mid = get().currentMatchId;
if (!mid) return;
const rows = await listRecentRallies(mid, 20);
const list: RallyRecord[] = rows.map((x: any) => ({
id: x.id,
matchId: x.match_id,
gameIndex: x.game_index,
rallyNo: x.rally_no,
winnerSide: x.winner_side,
endZone: (x.end_zone === 'out' ? 'out' : Number(x.end_zone)) as any,
meta: JSON.parse(x.meta_json || '{}'),
route:
x.route_start_x != null && x.route_end_x != null
? { start: { x: x.route_start_x, y: x.route_start_y }, end: { x: x.route_end_x, y: x.route_end_y } }
: undefined,
createdAt: x.created_at,
}));
set({ records: list });
},

addRecord: async (r) => {
const mid = get().currentMatchId;
if (!mid) throw new Error('請先選擇一個場次（match）');

const recId = Math.random().toString(36).slice(2);
const createdAt = new Date().toISOString();

// 1) 寫入（依 BACKEND 切換：supabase 會直寫雲端；sqlite 寫本地）
await insertRally({
  id: recId,
  match_id: mid,
  game_index: r.gameIndex,
  rally_no: r.rallyNo,
  winner_side: r.winnerSide,
  end_zone: String(r.endZone),
  meta_json: JSON.stringify(r.meta || {}),
  route_start_x: r.route?.start.x ?? null,
  route_start_y: r.route?.start.y ?? null,
  route_end_x: r.route?.end.x ?? null,
  route_end_y: r.route?.end.y ?? null,
  route_start_rx: r.routeNorm?.start?.x ?? null,
  route_start_ry: r.routeNorm?.start?.y ?? null,
  route_end_rx: r.routeNorm?.end?.x ?? null,
  route_end_ry: r.routeNorm?.end?.y ?? null,
  created_at: createdAt,
});

// 2) 本地 UI 立即更新
const rec: RallyRecord = {
  id: recId,
  matchId: mid,
  createdAt,
  gameIndex: r.gameIndex,
  rallyNo: r.rallyNo,
  winnerSide: r.winnerSide,
  endZone: r.endZone,
  meta: r.meta,
  route: r.route,
};
set((s) => ({ records: [rec, ...s.records].slice(0, 20) }));

// 3) 只在離線模式才丟到同步佇列（避免 supabase 模式重複上傳）
if (BACKEND === 'sqlite') {
  enqueueSync({
    kind: 'rally',
    payload: {
      id: recId,
      match_id: mid,
      game_index: r.gameIndex,
      rally_no: r.rallyNo,
      winner_side: r.winnerSide,
      end_zone: String(r.endZone),
      meta_json: JSON.stringify(r.meta || {}),
      route_start_x: r.route?.start.x ?? null,
      route_start_y: r.route?.start.y ?? null,
      route_end_x: r.route?.end.x ?? null,
      route_end_y: r.route?.end.y ?? null,
      route_start_rx: r.routeNorm?.start?.x ?? null,
      route_start_ry: r.routeNorm?.start?.y ?? null,
      route_end_rx: r.routeNorm?.end?.x ?? null,
      route_end_ry: r.routeNorm?.end?.y ?? null,
      created_at: createdAt,
    },
  }).catch(() => {});
}
},

clearLocal: () => set({ records: [] }),
}));ezbmt-tracked/src/store/bg.ts
 
import { create } from 'zustand';
import AsyncStorage from '@react-native-async-storage/async-storage';
import RNFS from 'react-native-fs';

type BgState = {
uri: string | null;
opacity: number; // 0..1
load: () => Promise<void>;
setOpacity: (v: number) => Promise<void>;
setFromBase64: (base64: string, ext?: string) => Promise<void>; // 寫入檔案後啟用
clear: () => Promise<void>;
};

const KEY = 'app_bg_v1';

export const useBgStore = create<BgState>((set, get) => ({
uri: null,
opacity: 0.25,

load: async () => {
try {
const s = await AsyncStorage.getItem(KEY);
if (!s) return;
const obj = JSON.parse(s || '{}') as { uri?: string; opacity?: number };
// 檢查檔案是否存在（file://）
if (obj?.uri && obj.uri.startsWith('file://')) {
const p = obj.uri.replace('file://', '');
const ok = await RNFS.exists(p);
if (!ok) {
await AsyncStorage.removeItem(KEY);
set({ uri: null, opacity: obj.opacity ?? 0.25 });
return;
}
}
set({ uri: obj?.uri || null, opacity: typeof obj?.opacity === 'number' ? obj.opacity : 0.25 });
} catch {
// ignore
}
},

setOpacity: async (v: number) => {
set({ opacity: v });
try {
const cur = get();
await AsyncStorage.setItem(KEY, JSON.stringify({ uri: cur.uri, opacity: v }));
} catch {}
},

setFromBase64: async (base64: string, ext = 'jpg') => {
try {
const dir = RNFS.DocumentDirectoryPath;
const dest = `${dir}/app_bg.${ext.toLowerCase()}`;
await RNFS.writeFile(dest, base64, 'base64');
const uri = `file://${dest}`;
set({ uri });
const cur = get();
await AsyncStorage.setItem(KEY, JSON.stringify({ uri, opacity: cur.opacity }));
} catch (e) {
throw e;
}
},

clear: async () => {
try {
const s = await AsyncStorage.getItem(KEY);
if (s) {
const obj = JSON.parse(s || '{}') as { uri?: string; opacity?: number };
if (obj?.uri?.startsWith('file://')) {
const p = obj.uri.replace('file://', '');
try { await RNFS.unlink(p); } catch {}
}
}
} catch {}
set({ uri: null });
try {
const cur = get();
await AsyncStorage.setItem(KEY, JSON.stringify({ uri: null, opacity: cur.opacity }));
} catch {}
},
}));